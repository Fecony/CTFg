schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "award"
"""
type award {
  date: timestamp
  description: String
  icon: String
  id: uuid!
  name: String
  requirements(
    """JSON select path"""
    path: String
  ): json

  """An object relationship"""
  team: team
  team_id: uuid
  type: String

  """An object relationship"""
  user: user
  user_id: uuid
  value: Int
}

"""
aggregated selection of "award"
"""
type award_aggregate {
  aggregate: award_aggregate_fields
  nodes: [award!]!
}

"""
aggregate fields of "award"
"""
type award_aggregate_fields {
  avg: award_avg_fields
  count(columns: [award_select_column!], distinct: Boolean): Int!
  max: award_max_fields
  min: award_min_fields
  stddev: award_stddev_fields
  stddev_pop: award_stddev_pop_fields
  stddev_samp: award_stddev_samp_fields
  sum: award_sum_fields
  var_pop: award_var_pop_fields
  var_samp: award_var_samp_fields
  variance: award_variance_fields
}

"""
order by aggregate values of table "award"
"""
input award_aggregate_order_by {
  avg: award_avg_order_by
  count: order_by
  max: award_max_order_by
  min: award_min_order_by
  stddev: award_stddev_order_by
  stddev_pop: award_stddev_pop_order_by
  stddev_samp: award_stddev_samp_order_by
  sum: award_sum_order_by
  var_pop: award_var_pop_order_by
  var_samp: award_var_samp_order_by
  variance: award_variance_order_by
}

"""
input type for inserting array relation for remote table "award"
"""
input award_arr_rel_insert_input {
  data: [award_insert_input!]!

  """upsert condition"""
  on_conflict: award_on_conflict
}

"""aggregate avg on columns"""
type award_avg_fields {
  value: Float
}

"""
order by avg() on columns of table "award"
"""
input award_avg_order_by {
  value: order_by
}

"""
Boolean expression to filter rows from the table "award". All fields are combined with a logical 'AND'.
"""
input award_bool_exp {
  _and: [award_bool_exp!]
  _not: award_bool_exp
  _or: [award_bool_exp!]
  date: timestamp_comparison_exp
  description: String_comparison_exp
  icon: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  requirements: json_comparison_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
  type: String_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
  value: Int_comparison_exp
}

"""
unique or primary key constraints on table "award"
"""
enum award_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  award_pkey
}

"""
input type for incrementing numeric columns in table "award"
"""
input award_inc_input {
  value: Int
}

"""
input type for inserting data into table "award"
"""
input award_insert_input {
  date: timestamp
  description: String
  icon: String
  id: uuid
  name: String
  requirements: json
  team: team_obj_rel_insert_input
  team_id: uuid
  type: String
  user: user_obj_rel_insert_input
  user_id: uuid
  value: Int
}

"""aggregate max on columns"""
type award_max_fields {
  date: timestamp
  description: String
  icon: String
  id: uuid
  name: String
  team_id: uuid
  type: String
  user_id: uuid
  value: Int
}

"""
order by max() on columns of table "award"
"""
input award_max_order_by {
  date: order_by
  description: order_by
  icon: order_by
  id: order_by
  name: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
  value: order_by
}

"""aggregate min on columns"""
type award_min_fields {
  date: timestamp
  description: String
  icon: String
  id: uuid
  name: String
  team_id: uuid
  type: String
  user_id: uuid
  value: Int
}

"""
order by min() on columns of table "award"
"""
input award_min_order_by {
  date: order_by
  description: order_by
  icon: order_by
  id: order_by
  name: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
  value: order_by
}

"""
response of any mutation on the table "award"
"""
type award_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [award!]!
}

"""
on_conflict condition type for table "award"
"""
input award_on_conflict {
  constraint: award_constraint!
  update_columns: [award_update_column!]! = []
  where: award_bool_exp
}

"""Ordering options when selecting data from "award"."""
input award_order_by {
  date: order_by
  description: order_by
  icon: order_by
  id: order_by
  name: order_by
  requirements: order_by
  team: team_order_by
  team_id: order_by
  type: order_by
  user: user_order_by
  user_id: order_by
  value: order_by
}

"""primary key columns input for table: award"""
input award_pk_columns_input {
  id: uuid!
}

"""
select columns of table "award"
"""
enum award_select_column {
  """column name"""
  date

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  requirements

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value
}

"""
input type for updating data in table "award"
"""
input award_set_input {
  date: timestamp
  description: String
  icon: String
  id: uuid
  name: String
  requirements: json
  team_id: uuid
  type: String
  user_id: uuid
  value: Int
}

"""aggregate stddev on columns"""
type award_stddev_fields {
  value: Float
}

"""
order by stddev() on columns of table "award"
"""
input award_stddev_order_by {
  value: order_by
}

"""aggregate stddev_pop on columns"""
type award_stddev_pop_fields {
  value: Float
}

"""
order by stddev_pop() on columns of table "award"
"""
input award_stddev_pop_order_by {
  value: order_by
}

"""aggregate stddev_samp on columns"""
type award_stddev_samp_fields {
  value: Float
}

"""
order by stddev_samp() on columns of table "award"
"""
input award_stddev_samp_order_by {
  value: order_by
}

"""aggregate sum on columns"""
type award_sum_fields {
  value: Int
}

"""
order by sum() on columns of table "award"
"""
input award_sum_order_by {
  value: order_by
}

"""
update columns of table "award"
"""
enum award_update_column {
  """column name"""
  date

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  requirements

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type award_var_pop_fields {
  value: Float
}

"""
order by var_pop() on columns of table "award"
"""
input award_var_pop_order_by {
  value: order_by
}

"""aggregate var_samp on columns"""
type award_var_samp_fields {
  value: Float
}

"""
order by var_samp() on columns of table "award"
"""
input award_var_samp_order_by {
  value: order_by
}

"""aggregate variance on columns"""
type award_variance_fields {
  value: Float
}

"""
order by variance() on columns of table "award"
"""
input award_variance_order_by {
  value: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "challenge"
"""
type challenge {
  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): [comment!]!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): comment_aggregate!
  connection_info: String
  description: String

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [file_order_by!]

    """filter the rows returned"""
    where: file_bool_exp
  ): [file!]!

  """An aggregate relationship"""
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [file_order_by!]

    """filter the rows returned"""
    where: file_bool_exp
  ): file_aggregate!

  """An array relationship"""
  flags(
    """distinct select on columns"""
    distinct_on: [flag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [flag_order_by!]

    """filter the rows returned"""
    where: flag_bool_exp
  ): [flag!]!

  """An aggregate relationship"""
  flags_aggregate(
    """distinct select on columns"""
    distinct_on: [flag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [flag_order_by!]

    """filter the rows returned"""
    where: flag_bool_exp
  ): flag_aggregate!

  """An array relationship"""
  hints(
    """distinct select on columns"""
    distinct_on: [hint_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hint_order_by!]

    """filter the rows returned"""
    where: hint_bool_exp
  ): [hint!]!

  """An aggregate relationship"""
  hints_aggregate(
    """distinct select on columns"""
    distinct_on: [hint_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hint_order_by!]

    """filter the rows returned"""
    where: hint_bool_exp
  ): hint_aggregate!
  id: uuid!
  max_attempts: Int
  name: String
  next_id: uuid
  requirements(
    """JSON select path"""
    path: String
  ): json

  """
  A computed field, executes function "challenges_solved"
  """
  solved: Boolean

  """An array relationship"""
  solves(
    """distinct select on columns"""
    distinct_on: [solve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solve_order_by!]

    """filter the rows returned"""
    where: solve_bool_exp
  ): [solve!]!

  """An aggregate relationship"""
  solves_aggregate(
    """distinct select on columns"""
    distinct_on: [solve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solve_order_by!]

    """filter the rows returned"""
    where: solve_bool_exp
  ): solve_aggregate!
  state: String!

  """An array relationship"""
  submissions(
    """distinct select on columns"""
    distinct_on: [submission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submission_order_by!]

    """filter the rows returned"""
    where: submission_bool_exp
  ): [submission!]!

  """An aggregate relationship"""
  submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [submission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submission_order_by!]

    """filter the rows returned"""
    where: submission_bool_exp
  ): submission_aggregate!

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinct_on: [challenge_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenge_tag_order_by!]

    """filter the rows returned"""
    where: challenge_tag_bool_exp
  ): [challenge_tag!]!

  """An aggregate relationship"""
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [challenge_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenge_tag_order_by!]

    """filter the rows returned"""
    where: challenge_tag_bool_exp
  ): challenge_tag_aggregate!
  type: String
  value: Int
}

"""
aggregated selection of "challenge"
"""
type challenge_aggregate {
  aggregate: challenge_aggregate_fields
  nodes: [challenge!]!
}

"""
aggregate fields of "challenge"
"""
type challenge_aggregate_fields {
  avg: challenge_avg_fields
  count(columns: [challenge_select_column!], distinct: Boolean): Int!
  max: challenge_max_fields
  min: challenge_min_fields
  stddev: challenge_stddev_fields
  stddev_pop: challenge_stddev_pop_fields
  stddev_samp: challenge_stddev_samp_fields
  sum: challenge_sum_fields
  var_pop: challenge_var_pop_fields
  var_samp: challenge_var_samp_fields
  variance: challenge_variance_fields
}

"""aggregate avg on columns"""
type challenge_avg_fields {
  max_attempts: Float
  value: Float
}

"""
Boolean expression to filter rows from the table "challenge". All fields are combined with a logical 'AND'.
"""
input challenge_bool_exp {
  _and: [challenge_bool_exp!]
  _not: challenge_bool_exp
  _or: [challenge_bool_exp!]
  comments: comment_bool_exp
  connection_info: String_comparison_exp
  description: String_comparison_exp
  files: file_bool_exp
  flags: flag_bool_exp
  hints: hint_bool_exp
  id: uuid_comparison_exp
  max_attempts: Int_comparison_exp
  name: String_comparison_exp
  next_id: uuid_comparison_exp
  requirements: json_comparison_exp
  solved: Boolean_comparison_exp
  solves: solve_bool_exp
  state: String_comparison_exp
  submissions: submission_bool_exp
  tags: challenge_tag_bool_exp
  type: String_comparison_exp
  value: Int_comparison_exp
}

"""
unique or primary key constraints on table "challenge"
"""
enum challenge_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  challenge_pkey
}

"""
input type for incrementing numeric columns in table "challenge"
"""
input challenge_inc_input {
  max_attempts: Int
  value: Int
}

"""
input type for inserting data into table "challenge"
"""
input challenge_insert_input {
  comments: comment_arr_rel_insert_input
  connection_info: String
  description: String
  files: file_arr_rel_insert_input
  flags: flag_arr_rel_insert_input
  hints: hint_arr_rel_insert_input
  id: uuid
  max_attempts: Int
  name: String
  next_id: uuid
  requirements: json
  solves: solve_arr_rel_insert_input
  state: String
  submissions: submission_arr_rel_insert_input
  tags: challenge_tag_arr_rel_insert_input
  type: String
  value: Int
}

"""aggregate max on columns"""
type challenge_max_fields {
  connection_info: String
  description: String
  id: uuid
  max_attempts: Int
  name: String
  next_id: uuid
  state: String
  type: String
  value: Int
}

"""aggregate min on columns"""
type challenge_min_fields {
  connection_info: String
  description: String
  id: uuid
  max_attempts: Int
  name: String
  next_id: uuid
  state: String
  type: String
  value: Int
}

"""
response of any mutation on the table "challenge"
"""
type challenge_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [challenge!]!
}

"""
input type for inserting object relation for remote table "challenge"
"""
input challenge_obj_rel_insert_input {
  data: challenge_insert_input!

  """upsert condition"""
  on_conflict: challenge_on_conflict
}

"""
on_conflict condition type for table "challenge"
"""
input challenge_on_conflict {
  constraint: challenge_constraint!
  update_columns: [challenge_update_column!]! = []
  where: challenge_bool_exp
}

"""Ordering options when selecting data from "challenge"."""
input challenge_order_by {
  comments_aggregate: comment_aggregate_order_by
  connection_info: order_by
  description: order_by
  files_aggregate: file_aggregate_order_by
  flags_aggregate: flag_aggregate_order_by
  hints_aggregate: hint_aggregate_order_by
  id: order_by
  max_attempts: order_by
  name: order_by
  next_id: order_by
  requirements: order_by
  solved: order_by
  solves_aggregate: solve_aggregate_order_by
  state: order_by
  submissions_aggregate: submission_aggregate_order_by
  tags_aggregate: challenge_tag_aggregate_order_by
  type: order_by
  value: order_by
}

"""primary key columns input for table: challenge"""
input challenge_pk_columns_input {
  id: uuid!
}

"""
select columns of table "challenge"
"""
enum challenge_select_column {
  """column name"""
  connection_info

  """column name"""
  description

  """column name"""
  id

  """column name"""
  max_attempts

  """column name"""
  name

  """column name"""
  next_id

  """column name"""
  requirements

  """column name"""
  state

  """column name"""
  type

  """column name"""
  value
}

"""
input type for updating data in table "challenge"
"""
input challenge_set_input {
  connection_info: String
  description: String
  id: uuid
  max_attempts: Int
  name: String
  next_id: uuid
  requirements: json
  state: String
  type: String
  value: Int
}

"""aggregate stddev on columns"""
type challenge_stddev_fields {
  max_attempts: Float
  value: Float
}

"""aggregate stddev_pop on columns"""
type challenge_stddev_pop_fields {
  max_attempts: Float
  value: Float
}

"""aggregate stddev_samp on columns"""
type challenge_stddev_samp_fields {
  max_attempts: Float
  value: Float
}

"""aggregate sum on columns"""
type challenge_sum_fields {
  max_attempts: Int
  value: Int
}

"""
columns and relationships of "challenge_tag"
"""
type challenge_tag {
  """An object relationship"""
  challenge: challenge
  challenge_id: uuid
  id: uuid!

  """An object relationship"""
  tag: tag
  tag_id: uuid
}

"""
aggregated selection of "challenge_tag"
"""
type challenge_tag_aggregate {
  aggregate: challenge_tag_aggregate_fields
  nodes: [challenge_tag!]!
}

"""
aggregate fields of "challenge_tag"
"""
type challenge_tag_aggregate_fields {
  count(columns: [challenge_tag_select_column!], distinct: Boolean): Int!
  max: challenge_tag_max_fields
  min: challenge_tag_min_fields
}

"""
order by aggregate values of table "challenge_tag"
"""
input challenge_tag_aggregate_order_by {
  count: order_by
  max: challenge_tag_max_order_by
  min: challenge_tag_min_order_by
}

"""
input type for inserting array relation for remote table "challenge_tag"
"""
input challenge_tag_arr_rel_insert_input {
  data: [challenge_tag_insert_input!]!

  """upsert condition"""
  on_conflict: challenge_tag_on_conflict
}

"""
Boolean expression to filter rows from the table "challenge_tag". All fields are combined with a logical 'AND'.
"""
input challenge_tag_bool_exp {
  _and: [challenge_tag_bool_exp!]
  _not: challenge_tag_bool_exp
  _or: [challenge_tag_bool_exp!]
  challenge: challenge_bool_exp
  challenge_id: uuid_comparison_exp
  id: uuid_comparison_exp
  tag: tag_bool_exp
  tag_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "challenge_tag"
"""
enum challenge_tag_constraint {
  """
  unique or primary key constraint on columns "challenge_id", "tag_id"
  """
  challenge_id_tag_id

  """
  unique or primary key constraint on columns "id"
  """
  challenge_tag_pkey
}

"""
input type for inserting data into table "challenge_tag"
"""
input challenge_tag_insert_input {
  challenge: challenge_obj_rel_insert_input
  challenge_id: uuid
  id: uuid
  tag: tag_obj_rel_insert_input
  tag_id: uuid
}

"""aggregate max on columns"""
type challenge_tag_max_fields {
  challenge_id: uuid
  id: uuid
  tag_id: uuid
}

"""
order by max() on columns of table "challenge_tag"
"""
input challenge_tag_max_order_by {
  challenge_id: order_by
  id: order_by
  tag_id: order_by
}

"""aggregate min on columns"""
type challenge_tag_min_fields {
  challenge_id: uuid
  id: uuid
  tag_id: uuid
}

"""
order by min() on columns of table "challenge_tag"
"""
input challenge_tag_min_order_by {
  challenge_id: order_by
  id: order_by
  tag_id: order_by
}

"""
response of any mutation on the table "challenge_tag"
"""
type challenge_tag_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [challenge_tag!]!
}

"""
on_conflict condition type for table "challenge_tag"
"""
input challenge_tag_on_conflict {
  constraint: challenge_tag_constraint!
  update_columns: [challenge_tag_update_column!]! = []
  where: challenge_tag_bool_exp
}

"""Ordering options when selecting data from "challenge_tag"."""
input challenge_tag_order_by {
  challenge: challenge_order_by
  challenge_id: order_by
  id: order_by
  tag: tag_order_by
  tag_id: order_by
}

"""primary key columns input for table: challenge_tag"""
input challenge_tag_pk_columns_input {
  id: uuid!
}

"""
select columns of table "challenge_tag"
"""
enum challenge_tag_select_column {
  """column name"""
  challenge_id

  """column name"""
  id

  """column name"""
  tag_id
}

"""
input type for updating data in table "challenge_tag"
"""
input challenge_tag_set_input {
  challenge_id: uuid
  id: uuid
  tag_id: uuid
}

"""
update columns of table "challenge_tag"
"""
enum challenge_tag_update_column {
  """column name"""
  challenge_id

  """column name"""
  id

  """column name"""
  tag_id
}

"""
update columns of table "challenge"
"""
enum challenge_update_column {
  """column name"""
  connection_info

  """column name"""
  description

  """column name"""
  id

  """column name"""
  max_attempts

  """column name"""
  name

  """column name"""
  next_id

  """column name"""
  requirements

  """column name"""
  state

  """column name"""
  type

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type challenge_var_pop_fields {
  max_attempts: Float
  value: Float
}

"""aggregate var_samp on columns"""
type challenge_var_samp_fields {
  max_attempts: Float
  value: Float
}

"""aggregate variance on columns"""
type challenge_variance_fields {
  max_attempts: Float
  value: Float
}

"""
columns and relationships of "comment"
"""
type comment {
  author_id: uuid

  """An object relationship"""
  challenge: challenge
  challenge_id: uuid
  content: String
  date: timestamp
  id: uuid!

  """An object relationship"""
  page: page
  page_id: uuid

  """An object relationship"""
  team: team
  team_id: uuid
  type: String

  """An object relationship"""
  user: user

  """An object relationship"""
  userByUserId: user
  user_id: uuid
}

"""
aggregated selection of "comment"
"""
type comment_aggregate {
  aggregate: comment_aggregate_fields
  nodes: [comment!]!
}

"""
aggregate fields of "comment"
"""
type comment_aggregate_fields {
  count(columns: [comment_select_column!], distinct: Boolean): Int!
  max: comment_max_fields
  min: comment_min_fields
}

"""
order by aggregate values of table "comment"
"""
input comment_aggregate_order_by {
  count: order_by
  max: comment_max_order_by
  min: comment_min_order_by
}

"""
input type for inserting array relation for remote table "comment"
"""
input comment_arr_rel_insert_input {
  data: [comment_insert_input!]!

  """upsert condition"""
  on_conflict: comment_on_conflict
}

"""
Boolean expression to filter rows from the table "comment". All fields are combined with a logical 'AND'.
"""
input comment_bool_exp {
  _and: [comment_bool_exp!]
  _not: comment_bool_exp
  _or: [comment_bool_exp!]
  author_id: uuid_comparison_exp
  challenge: challenge_bool_exp
  challenge_id: uuid_comparison_exp
  content: String_comparison_exp
  date: timestamp_comparison_exp
  id: uuid_comparison_exp
  page: page_bool_exp
  page_id: uuid_comparison_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
  type: String_comparison_exp
  user: user_bool_exp
  userByUserId: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "comment"
"""
enum comment_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  comment_pkey
}

"""
input type for inserting data into table "comment"
"""
input comment_insert_input {
  author_id: uuid
  challenge: challenge_obj_rel_insert_input
  challenge_id: uuid
  content: String
  date: timestamp
  id: uuid
  page: page_obj_rel_insert_input
  page_id: uuid
  team: team_obj_rel_insert_input
  team_id: uuid
  type: String
  user: user_obj_rel_insert_input
  userByUserId: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type comment_max_fields {
  author_id: uuid
  challenge_id: uuid
  content: String
  date: timestamp
  id: uuid
  page_id: uuid
  team_id: uuid
  type: String
  user_id: uuid
}

"""
order by max() on columns of table "comment"
"""
input comment_max_order_by {
  author_id: order_by
  challenge_id: order_by
  content: order_by
  date: order_by
  id: order_by
  page_id: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type comment_min_fields {
  author_id: uuid
  challenge_id: uuid
  content: String
  date: timestamp
  id: uuid
  page_id: uuid
  team_id: uuid
  type: String
  user_id: uuid
}

"""
order by min() on columns of table "comment"
"""
input comment_min_order_by {
  author_id: order_by
  challenge_id: order_by
  content: order_by
  date: order_by
  id: order_by
  page_id: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""
response of any mutation on the table "comment"
"""
type comment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [comment!]!
}

"""
on_conflict condition type for table "comment"
"""
input comment_on_conflict {
  constraint: comment_constraint!
  update_columns: [comment_update_column!]! = []
  where: comment_bool_exp
}

"""Ordering options when selecting data from "comment"."""
input comment_order_by {
  author_id: order_by
  challenge: challenge_order_by
  challenge_id: order_by
  content: order_by
  date: order_by
  id: order_by
  page: page_order_by
  page_id: order_by
  team: team_order_by
  team_id: order_by
  type: order_by
  user: user_order_by
  userByUserId: user_order_by
  user_id: order_by
}

"""primary key columns input for table: comment"""
input comment_pk_columns_input {
  id: uuid!
}

"""
select columns of table "comment"
"""
enum comment_select_column {
  """column name"""
  author_id

  """column name"""
  challenge_id

  """column name"""
  content

  """column name"""
  date

  """column name"""
  id

  """column name"""
  page_id

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id
}

"""
input type for updating data in table "comment"
"""
input comment_set_input {
  author_id: uuid
  challenge_id: uuid
  content: String
  date: timestamp
  id: uuid
  page_id: uuid
  team_id: uuid
  type: String
  user_id: uuid
}

"""
update columns of table "comment"
"""
enum comment_update_column {
  """column name"""
  author_id

  """column name"""
  challenge_id

  """column name"""
  content

  """column name"""
  date

  """column name"""
  id

  """column name"""
  page_id

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id
}

"""
columns and relationships of "config"
"""
type config {
  id: uuid!
  key: String
  value: String
}

"""
aggregated selection of "config"
"""
type config_aggregate {
  aggregate: config_aggregate_fields
  nodes: [config!]!
}

"""
aggregate fields of "config"
"""
type config_aggregate_fields {
  count(columns: [config_select_column!], distinct: Boolean): Int!
  max: config_max_fields
  min: config_min_fields
}

"""
Boolean expression to filter rows from the table "config". All fields are combined with a logical 'AND'.
"""
input config_bool_exp {
  _and: [config_bool_exp!]
  _not: config_bool_exp
  _or: [config_bool_exp!]
  id: uuid_comparison_exp
  key: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "config"
"""
enum config_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  config_pkey
}

"""
input type for inserting data into table "config"
"""
input config_insert_input {
  id: uuid
  key: String
  value: String
}

"""aggregate max on columns"""
type config_max_fields {
  id: uuid
  key: String
  value: String
}

"""aggregate min on columns"""
type config_min_fields {
  id: uuid
  key: String
  value: String
}

"""
response of any mutation on the table "config"
"""
type config_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [config!]!
}

"""
on_conflict condition type for table "config"
"""
input config_on_conflict {
  constraint: config_constraint!
  update_columns: [config_update_column!]! = []
  where: config_bool_exp
}

"""Ordering options when selecting data from "config"."""
input config_order_by {
  id: order_by
  key: order_by
  value: order_by
}

"""primary key columns input for table: config"""
input config_pk_columns_input {
  id: uuid!
}

"""
select columns of table "config"
"""
enum config_select_column {
  """column name"""
  id

  """column name"""
  key

  """column name"""
  value
}

"""
input type for updating data in table "config"
"""
input config_set_input {
  id: uuid
  key: String
  value: String
}

"""
update columns of table "config"
"""
enum config_update_column {
  """column name"""
  id

  """column name"""
  key

  """column name"""
  value
}

"""
columns and relationships of "dynamic_challenge"
"""
type dynamic_challenge {
  """An object relationship"""
  challenge: challenge!
  decay: Int
  id: uuid!
  initial: Int
  minimum: Int
}

"""
aggregated selection of "dynamic_challenge"
"""
type dynamic_challenge_aggregate {
  aggregate: dynamic_challenge_aggregate_fields
  nodes: [dynamic_challenge!]!
}

"""
aggregate fields of "dynamic_challenge"
"""
type dynamic_challenge_aggregate_fields {
  avg: dynamic_challenge_avg_fields
  count(columns: [dynamic_challenge_select_column!], distinct: Boolean): Int!
  max: dynamic_challenge_max_fields
  min: dynamic_challenge_min_fields
  stddev: dynamic_challenge_stddev_fields
  stddev_pop: dynamic_challenge_stddev_pop_fields
  stddev_samp: dynamic_challenge_stddev_samp_fields
  sum: dynamic_challenge_sum_fields
  var_pop: dynamic_challenge_var_pop_fields
  var_samp: dynamic_challenge_var_samp_fields
  variance: dynamic_challenge_variance_fields
}

"""aggregate avg on columns"""
type dynamic_challenge_avg_fields {
  decay: Float
  initial: Float
  minimum: Float
}

"""
Boolean expression to filter rows from the table "dynamic_challenge". All fields are combined with a logical 'AND'.
"""
input dynamic_challenge_bool_exp {
  _and: [dynamic_challenge_bool_exp!]
  _not: dynamic_challenge_bool_exp
  _or: [dynamic_challenge_bool_exp!]
  challenge: challenge_bool_exp
  decay: Int_comparison_exp
  id: uuid_comparison_exp
  initial: Int_comparison_exp
  minimum: Int_comparison_exp
}

"""
unique or primary key constraints on table "dynamic_challenge"
"""
enum dynamic_challenge_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  dynamic_challenge_pkey
}

"""
input type for incrementing numeric columns in table "dynamic_challenge"
"""
input dynamic_challenge_inc_input {
  decay: Int
  initial: Int
  minimum: Int
}

"""
input type for inserting data into table "dynamic_challenge"
"""
input dynamic_challenge_insert_input {
  challenge: challenge_obj_rel_insert_input
  decay: Int
  id: uuid
  initial: Int
  minimum: Int
}

"""aggregate max on columns"""
type dynamic_challenge_max_fields {
  decay: Int
  id: uuid
  initial: Int
  minimum: Int
}

"""aggregate min on columns"""
type dynamic_challenge_min_fields {
  decay: Int
  id: uuid
  initial: Int
  minimum: Int
}

"""
response of any mutation on the table "dynamic_challenge"
"""
type dynamic_challenge_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [dynamic_challenge!]!
}

"""
on_conflict condition type for table "dynamic_challenge"
"""
input dynamic_challenge_on_conflict {
  constraint: dynamic_challenge_constraint!
  update_columns: [dynamic_challenge_update_column!]! = []
  where: dynamic_challenge_bool_exp
}

"""Ordering options when selecting data from "dynamic_challenge"."""
input dynamic_challenge_order_by {
  challenge: challenge_order_by
  decay: order_by
  id: order_by
  initial: order_by
  minimum: order_by
}

"""primary key columns input for table: dynamic_challenge"""
input dynamic_challenge_pk_columns_input {
  id: uuid!
}

"""
select columns of table "dynamic_challenge"
"""
enum dynamic_challenge_select_column {
  """column name"""
  decay

  """column name"""
  id

  """column name"""
  initial

  """column name"""
  minimum
}

"""
input type for updating data in table "dynamic_challenge"
"""
input dynamic_challenge_set_input {
  decay: Int
  id: uuid
  initial: Int
  minimum: Int
}

"""aggregate stddev on columns"""
type dynamic_challenge_stddev_fields {
  decay: Float
  initial: Float
  minimum: Float
}

"""aggregate stddev_pop on columns"""
type dynamic_challenge_stddev_pop_fields {
  decay: Float
  initial: Float
  minimum: Float
}

"""aggregate stddev_samp on columns"""
type dynamic_challenge_stddev_samp_fields {
  decay: Float
  initial: Float
  minimum: Float
}

"""aggregate sum on columns"""
type dynamic_challenge_sum_fields {
  decay: Int
  initial: Int
  minimum: Int
}

"""
update columns of table "dynamic_challenge"
"""
enum dynamic_challenge_update_column {
  """column name"""
  decay

  """column name"""
  id

  """column name"""
  initial

  """column name"""
  minimum
}

"""aggregate var_pop on columns"""
type dynamic_challenge_var_pop_fields {
  decay: Float
  initial: Float
  minimum: Float
}

"""aggregate var_samp on columns"""
type dynamic_challenge_var_samp_fields {
  decay: Float
  initial: Float
  minimum: Float
}

"""aggregate variance on columns"""
type dynamic_challenge_variance_fields {
  decay: Float
  initial: Float
  minimum: Float
}

"""
columns and relationships of "field"
"""
type field {
  description: String
  editable: Boolean

  """An array relationship"""
  field_entries(
    """distinct select on columns"""
    distinct_on: [field_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entry_order_by!]

    """filter the rows returned"""
    where: field_entry_bool_exp
  ): [field_entry!]!

  """An aggregate relationship"""
  field_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [field_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entry_order_by!]

    """filter the rows returned"""
    where: field_entry_bool_exp
  ): field_entry_aggregate!
  field_type: String
  id: uuid!
  name: String
  public: Boolean
  required: Boolean
  type: String
}

"""
aggregated selection of "field"
"""
type field_aggregate {
  aggregate: field_aggregate_fields
  nodes: [field!]!
}

"""
aggregate fields of "field"
"""
type field_aggregate_fields {
  count(columns: [field_select_column!], distinct: Boolean): Int!
  max: field_max_fields
  min: field_min_fields
}

"""
Boolean expression to filter rows from the table "field". All fields are combined with a logical 'AND'.
"""
input field_bool_exp {
  _and: [field_bool_exp!]
  _not: field_bool_exp
  _or: [field_bool_exp!]
  description: String_comparison_exp
  editable: Boolean_comparison_exp
  field_entries: field_entry_bool_exp
  field_type: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  public: Boolean_comparison_exp
  required: Boolean_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "field"
"""
enum field_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  field_pkey
}

"""
columns and relationships of "field_entry"
"""
type field_entry {
  """An object relationship"""
  field: field
  field_id: uuid
  id: uuid!

  """An object relationship"""
  team: team
  team_id: uuid
  type: String

  """An object relationship"""
  user: user
  user_id: uuid
  value(
    """JSON select path"""
    path: String
  ): json
}

"""
aggregated selection of "field_entry"
"""
type field_entry_aggregate {
  aggregate: field_entry_aggregate_fields
  nodes: [field_entry!]!
}

"""
aggregate fields of "field_entry"
"""
type field_entry_aggregate_fields {
  count(columns: [field_entry_select_column!], distinct: Boolean): Int!
  max: field_entry_max_fields
  min: field_entry_min_fields
}

"""
order by aggregate values of table "field_entry"
"""
input field_entry_aggregate_order_by {
  count: order_by
  max: field_entry_max_order_by
  min: field_entry_min_order_by
}

"""
input type for inserting array relation for remote table "field_entry"
"""
input field_entry_arr_rel_insert_input {
  data: [field_entry_insert_input!]!

  """upsert condition"""
  on_conflict: field_entry_on_conflict
}

"""
Boolean expression to filter rows from the table "field_entry". All fields are combined with a logical 'AND'.
"""
input field_entry_bool_exp {
  _and: [field_entry_bool_exp!]
  _not: field_entry_bool_exp
  _or: [field_entry_bool_exp!]
  field: field_bool_exp
  field_id: uuid_comparison_exp
  id: uuid_comparison_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
  type: String_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
  value: json_comparison_exp
}

"""
unique or primary key constraints on table "field_entry"
"""
enum field_entry_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  field_entry_pkey
}

"""
input type for inserting data into table "field_entry"
"""
input field_entry_insert_input {
  field: field_obj_rel_insert_input
  field_id: uuid
  id: uuid
  team: team_obj_rel_insert_input
  team_id: uuid
  type: String
  user: user_obj_rel_insert_input
  user_id: uuid
  value: json
}

"""aggregate max on columns"""
type field_entry_max_fields {
  field_id: uuid
  id: uuid
  team_id: uuid
  type: String
  user_id: uuid
}

"""
order by max() on columns of table "field_entry"
"""
input field_entry_max_order_by {
  field_id: order_by
  id: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type field_entry_min_fields {
  field_id: uuid
  id: uuid
  team_id: uuid
  type: String
  user_id: uuid
}

"""
order by min() on columns of table "field_entry"
"""
input field_entry_min_order_by {
  field_id: order_by
  id: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""
response of any mutation on the table "field_entry"
"""
type field_entry_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [field_entry!]!
}

"""
on_conflict condition type for table "field_entry"
"""
input field_entry_on_conflict {
  constraint: field_entry_constraint!
  update_columns: [field_entry_update_column!]! = []
  where: field_entry_bool_exp
}

"""Ordering options when selecting data from "field_entry"."""
input field_entry_order_by {
  field: field_order_by
  field_id: order_by
  id: order_by
  team: team_order_by
  team_id: order_by
  type: order_by
  user: user_order_by
  user_id: order_by
  value: order_by
}

"""primary key columns input for table: field_entry"""
input field_entry_pk_columns_input {
  id: uuid!
}

"""
select columns of table "field_entry"
"""
enum field_entry_select_column {
  """column name"""
  field_id

  """column name"""
  id

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value
}

"""
input type for updating data in table "field_entry"
"""
input field_entry_set_input {
  field_id: uuid
  id: uuid
  team_id: uuid
  type: String
  user_id: uuid
  value: json
}

"""
update columns of table "field_entry"
"""
enum field_entry_update_column {
  """column name"""
  field_id

  """column name"""
  id

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value
}

"""
input type for inserting data into table "field"
"""
input field_insert_input {
  description: String
  editable: Boolean
  field_entries: field_entry_arr_rel_insert_input
  field_type: String
  id: uuid
  name: String
  public: Boolean
  required: Boolean
  type: String
}

"""aggregate max on columns"""
type field_max_fields {
  description: String
  field_type: String
  id: uuid
  name: String
  type: String
}

"""aggregate min on columns"""
type field_min_fields {
  description: String
  field_type: String
  id: uuid
  name: String
  type: String
}

"""
response of any mutation on the table "field"
"""
type field_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [field!]!
}

"""
input type for inserting object relation for remote table "field"
"""
input field_obj_rel_insert_input {
  data: field_insert_input!

  """upsert condition"""
  on_conflict: field_on_conflict
}

"""
on_conflict condition type for table "field"
"""
input field_on_conflict {
  constraint: field_constraint!
  update_columns: [field_update_column!]! = []
  where: field_bool_exp
}

"""Ordering options when selecting data from "field"."""
input field_order_by {
  description: order_by
  editable: order_by
  field_entries_aggregate: field_entry_aggregate_order_by
  field_type: order_by
  id: order_by
  name: order_by
  public: order_by
  required: order_by
  type: order_by
}

"""primary key columns input for table: field"""
input field_pk_columns_input {
  id: uuid!
}

"""
select columns of table "field"
"""
enum field_select_column {
  """column name"""
  description

  """column name"""
  editable

  """column name"""
  field_type

  """column name"""
  id

  """column name"""
  name

  """column name"""
  public

  """column name"""
  required

  """column name"""
  type
}

"""
input type for updating data in table "field"
"""
input field_set_input {
  description: String
  editable: Boolean
  field_type: String
  id: uuid
  name: String
  public: Boolean
  required: Boolean
  type: String
}

"""
update columns of table "field"
"""
enum field_update_column {
  """column name"""
  description

  """column name"""
  editable

  """column name"""
  field_type

  """column name"""
  id

  """column name"""
  name

  """column name"""
  public

  """column name"""
  required

  """column name"""
  type
}

"""
columns and relationships of "file"
"""
type file {
  """An object relationship"""
  challenge: challenge
  challenge_id: uuid
  id: uuid!
  location: String

  """An object relationship"""
  page: page
  page_id: uuid
  type: String
}

"""
aggregated selection of "file"
"""
type file_aggregate {
  aggregate: file_aggregate_fields
  nodes: [file!]!
}

"""
aggregate fields of "file"
"""
type file_aggregate_fields {
  count(columns: [file_select_column!], distinct: Boolean): Int!
  max: file_max_fields
  min: file_min_fields
}

"""
order by aggregate values of table "file"
"""
input file_aggregate_order_by {
  count: order_by
  max: file_max_order_by
  min: file_min_order_by
}

"""
input type for inserting array relation for remote table "file"
"""
input file_arr_rel_insert_input {
  data: [file_insert_input!]!

  """upsert condition"""
  on_conflict: file_on_conflict
}

"""
Boolean expression to filter rows from the table "file". All fields are combined with a logical 'AND'.
"""
input file_bool_exp {
  _and: [file_bool_exp!]
  _not: file_bool_exp
  _or: [file_bool_exp!]
  challenge: challenge_bool_exp
  challenge_id: uuid_comparison_exp
  id: uuid_comparison_exp
  location: String_comparison_exp
  page: page_bool_exp
  page_id: uuid_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "file"
"""
enum file_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  file_pkey
}

"""
input type for inserting data into table "file"
"""
input file_insert_input {
  challenge: challenge_obj_rel_insert_input
  challenge_id: uuid
  id: uuid
  location: String
  page: page_obj_rel_insert_input
  page_id: uuid
  type: String
}

"""aggregate max on columns"""
type file_max_fields {
  challenge_id: uuid
  id: uuid
  location: String
  page_id: uuid
  type: String
}

"""
order by max() on columns of table "file"
"""
input file_max_order_by {
  challenge_id: order_by
  id: order_by
  location: order_by
  page_id: order_by
  type: order_by
}

"""aggregate min on columns"""
type file_min_fields {
  challenge_id: uuid
  id: uuid
  location: String
  page_id: uuid
  type: String
}

"""
order by min() on columns of table "file"
"""
input file_min_order_by {
  challenge_id: order_by
  id: order_by
  location: order_by
  page_id: order_by
  type: order_by
}

"""
response of any mutation on the table "file"
"""
type file_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [file!]!
}

"""
on_conflict condition type for table "file"
"""
input file_on_conflict {
  constraint: file_constraint!
  update_columns: [file_update_column!]! = []
  where: file_bool_exp
}

"""Ordering options when selecting data from "file"."""
input file_order_by {
  challenge: challenge_order_by
  challenge_id: order_by
  id: order_by
  location: order_by
  page: page_order_by
  page_id: order_by
  type: order_by
}

"""primary key columns input for table: file"""
input file_pk_columns_input {
  id: uuid!
}

"""
select columns of table "file"
"""
enum file_select_column {
  """column name"""
  challenge_id

  """column name"""
  id

  """column name"""
  location

  """column name"""
  page_id

  """column name"""
  type
}

"""
input type for updating data in table "file"
"""
input file_set_input {
  challenge_id: uuid
  id: uuid
  location: String
  page_id: uuid
  type: String
}

"""
update columns of table "file"
"""
enum file_update_column {
  """column name"""
  challenge_id

  """column name"""
  id

  """column name"""
  location

  """column name"""
  page_id

  """column name"""
  type
}

"""
columns and relationships of "flag"
"""
type flag {
  """An object relationship"""
  challenge: challenge
  challenge_id: uuid
  content: String
  data: String
  id: uuid!
  type: String
}

"""
aggregated selection of "flag"
"""
type flag_aggregate {
  aggregate: flag_aggregate_fields
  nodes: [flag!]!
}

"""
aggregate fields of "flag"
"""
type flag_aggregate_fields {
  count(columns: [flag_select_column!], distinct: Boolean): Int!
  max: flag_max_fields
  min: flag_min_fields
}

"""
order by aggregate values of table "flag"
"""
input flag_aggregate_order_by {
  count: order_by
  max: flag_max_order_by
  min: flag_min_order_by
}

"""
input type for inserting array relation for remote table "flag"
"""
input flag_arr_rel_insert_input {
  data: [flag_insert_input!]!

  """upsert condition"""
  on_conflict: flag_on_conflict
}

"""
Boolean expression to filter rows from the table "flag". All fields are combined with a logical 'AND'.
"""
input flag_bool_exp {
  _and: [flag_bool_exp!]
  _not: flag_bool_exp
  _or: [flag_bool_exp!]
  challenge: challenge_bool_exp
  challenge_id: uuid_comparison_exp
  content: String_comparison_exp
  data: String_comparison_exp
  id: uuid_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "flag"
"""
enum flag_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  flag_pkey
}

"""
input type for inserting data into table "flag"
"""
input flag_insert_input {
  challenge: challenge_obj_rel_insert_input
  challenge_id: uuid
  content: String
  data: String
  id: uuid
  type: String
}

"""aggregate max on columns"""
type flag_max_fields {
  challenge_id: uuid
  content: String
  data: String
  id: uuid
  type: String
}

"""
order by max() on columns of table "flag"
"""
input flag_max_order_by {
  challenge_id: order_by
  content: order_by
  data: order_by
  id: order_by
  type: order_by
}

"""aggregate min on columns"""
type flag_min_fields {
  challenge_id: uuid
  content: String
  data: String
  id: uuid
  type: String
}

"""
order by min() on columns of table "flag"
"""
input flag_min_order_by {
  challenge_id: order_by
  content: order_by
  data: order_by
  id: order_by
  type: order_by
}

"""
response of any mutation on the table "flag"
"""
type flag_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [flag!]!
}

"""
on_conflict condition type for table "flag"
"""
input flag_on_conflict {
  constraint: flag_constraint!
  update_columns: [flag_update_column!]! = []
  where: flag_bool_exp
}

"""Ordering options when selecting data from "flag"."""
input flag_order_by {
  challenge: challenge_order_by
  challenge_id: order_by
  content: order_by
  data: order_by
  id: order_by
  type: order_by
}

"""primary key columns input for table: flag"""
input flag_pk_columns_input {
  id: uuid!
}

"""
select columns of table "flag"
"""
enum flag_select_column {
  """column name"""
  challenge_id

  """column name"""
  content

  """column name"""
  data

  """column name"""
  id

  """column name"""
  type
}

"""
input type for updating data in table "flag"
"""
input flag_set_input {
  challenge_id: uuid
  content: String
  data: String
  id: uuid
  type: String
}

"""
update columns of table "flag"
"""
enum flag_update_column {
  """column name"""
  challenge_id

  """column name"""
  content

  """column name"""
  data

  """column name"""
  id

  """column name"""
  type
}

"""
columns and relationships of "hint"
"""
type hint {
  """An object relationship"""
  challenge: challenge
  challenge_id: uuid
  content: String
  cost: Int
  id: uuid!
  requirements(
    """JSON select path"""
    path: String
  ): json
  type: String

  """An object relationship"""
  unlocked_content: hints_content

  """An array relationship"""
  unlocks(
    """distinct select on columns"""
    distinct_on: [unlock_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlock_order_by!]

    """filter the rows returned"""
    where: unlock_bool_exp
  ): [unlock!]!

  """An aggregate relationship"""
  unlocks_aggregate(
    """distinct select on columns"""
    distinct_on: [unlock_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlock_order_by!]

    """filter the rows returned"""
    where: unlock_bool_exp
  ): unlock_aggregate!
}

"""
aggregated selection of "hint"
"""
type hint_aggregate {
  aggregate: hint_aggregate_fields
  nodes: [hint!]!
}

"""
aggregate fields of "hint"
"""
type hint_aggregate_fields {
  avg: hint_avg_fields
  count(columns: [hint_select_column!], distinct: Boolean): Int!
  max: hint_max_fields
  min: hint_min_fields
  stddev: hint_stddev_fields
  stddev_pop: hint_stddev_pop_fields
  stddev_samp: hint_stddev_samp_fields
  sum: hint_sum_fields
  var_pop: hint_var_pop_fields
  var_samp: hint_var_samp_fields
  variance: hint_variance_fields
}

"""
order by aggregate values of table "hint"
"""
input hint_aggregate_order_by {
  avg: hint_avg_order_by
  count: order_by
  max: hint_max_order_by
  min: hint_min_order_by
  stddev: hint_stddev_order_by
  stddev_pop: hint_stddev_pop_order_by
  stddev_samp: hint_stddev_samp_order_by
  sum: hint_sum_order_by
  var_pop: hint_var_pop_order_by
  var_samp: hint_var_samp_order_by
  variance: hint_variance_order_by
}

"""
input type for inserting array relation for remote table "hint"
"""
input hint_arr_rel_insert_input {
  data: [hint_insert_input!]!

  """upsert condition"""
  on_conflict: hint_on_conflict
}

"""aggregate avg on columns"""
type hint_avg_fields {
  cost: Float
}

"""
order by avg() on columns of table "hint"
"""
input hint_avg_order_by {
  cost: order_by
}

"""
Boolean expression to filter rows from the table "hint". All fields are combined with a logical 'AND'.
"""
input hint_bool_exp {
  _and: [hint_bool_exp!]
  _not: hint_bool_exp
  _or: [hint_bool_exp!]
  challenge: challenge_bool_exp
  challenge_id: uuid_comparison_exp
  content: String_comparison_exp
  cost: Int_comparison_exp
  id: uuid_comparison_exp
  requirements: json_comparison_exp
  type: String_comparison_exp
  unlocked_content: hints_content_bool_exp
  unlocks: unlock_bool_exp
}

"""
unique or primary key constraints on table "hint"
"""
enum hint_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  hint_pkey
}

"""
input type for incrementing numeric columns in table "hint"
"""
input hint_inc_input {
  cost: Int
}

"""
input type for inserting data into table "hint"
"""
input hint_insert_input {
  challenge: challenge_obj_rel_insert_input
  challenge_id: uuid
  content: String
  cost: Int
  id: uuid
  requirements: json
  type: String
  unlocked_content: hints_content_obj_rel_insert_input
  unlocks: unlock_arr_rel_insert_input
}

"""aggregate max on columns"""
type hint_max_fields {
  challenge_id: uuid
  content: String
  cost: Int
  id: uuid
  type: String
}

"""
order by max() on columns of table "hint"
"""
input hint_max_order_by {
  challenge_id: order_by
  content: order_by
  cost: order_by
  id: order_by
  type: order_by
}

"""aggregate min on columns"""
type hint_min_fields {
  challenge_id: uuid
  content: String
  cost: Int
  id: uuid
  type: String
}

"""
order by min() on columns of table "hint"
"""
input hint_min_order_by {
  challenge_id: order_by
  content: order_by
  cost: order_by
  id: order_by
  type: order_by
}

"""
response of any mutation on the table "hint"
"""
type hint_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [hint!]!
}

"""
input type for inserting object relation for remote table "hint"
"""
input hint_obj_rel_insert_input {
  data: hint_insert_input!

  """upsert condition"""
  on_conflict: hint_on_conflict
}

"""
on_conflict condition type for table "hint"
"""
input hint_on_conflict {
  constraint: hint_constraint!
  update_columns: [hint_update_column!]! = []
  where: hint_bool_exp
}

"""Ordering options when selecting data from "hint"."""
input hint_order_by {
  challenge: challenge_order_by
  challenge_id: order_by
  content: order_by
  cost: order_by
  id: order_by
  requirements: order_by
  type: order_by
  unlocked_content: hints_content_order_by
  unlocks_aggregate: unlock_aggregate_order_by
}

"""primary key columns input for table: hint"""
input hint_pk_columns_input {
  id: uuid!
}

"""
select columns of table "hint"
"""
enum hint_select_column {
  """column name"""
  challenge_id

  """column name"""
  content

  """column name"""
  cost

  """column name"""
  id

  """column name"""
  requirements

  """column name"""
  type
}

"""
input type for updating data in table "hint"
"""
input hint_set_input {
  challenge_id: uuid
  content: String
  cost: Int
  id: uuid
  requirements: json
  type: String
}

"""aggregate stddev on columns"""
type hint_stddev_fields {
  cost: Float
}

"""
order by stddev() on columns of table "hint"
"""
input hint_stddev_order_by {
  cost: order_by
}

"""aggregate stddev_pop on columns"""
type hint_stddev_pop_fields {
  cost: Float
}

"""
order by stddev_pop() on columns of table "hint"
"""
input hint_stddev_pop_order_by {
  cost: order_by
}

"""aggregate stddev_samp on columns"""
type hint_stddev_samp_fields {
  cost: Float
}

"""
order by stddev_samp() on columns of table "hint"
"""
input hint_stddev_samp_order_by {
  cost: order_by
}

"""aggregate sum on columns"""
type hint_sum_fields {
  cost: Int
}

"""
order by sum() on columns of table "hint"
"""
input hint_sum_order_by {
  cost: order_by
}

"""
update columns of table "hint"
"""
enum hint_update_column {
  """column name"""
  challenge_id

  """column name"""
  content

  """column name"""
  cost

  """column name"""
  id

  """column name"""
  requirements

  """column name"""
  type
}

"""aggregate var_pop on columns"""
type hint_var_pop_fields {
  cost: Float
}

"""
order by var_pop() on columns of table "hint"
"""
input hint_var_pop_order_by {
  cost: order_by
}

"""aggregate var_samp on columns"""
type hint_var_samp_fields {
  cost: Float
}

"""
order by var_samp() on columns of table "hint"
"""
input hint_var_samp_order_by {
  cost: order_by
}

"""aggregate variance on columns"""
type hint_variance_fields {
  cost: Float
}

"""
order by variance() on columns of table "hint"
"""
input hint_variance_order_by {
  cost: order_by
}

"""
columns and relationships of "hints_content"
"""
type hints_content {
  content: String

  """An object relationship"""
  hint: hint
  id: uuid
}

"""
aggregated selection of "hints_content"
"""
type hints_content_aggregate {
  aggregate: hints_content_aggregate_fields
  nodes: [hints_content!]!
}

"""
aggregate fields of "hints_content"
"""
type hints_content_aggregate_fields {
  count(columns: [hints_content_select_column!], distinct: Boolean): Int!
  max: hints_content_max_fields
  min: hints_content_min_fields
}

"""
Boolean expression to filter rows from the table "hints_content". All fields are combined with a logical 'AND'.
"""
input hints_content_bool_exp {
  _and: [hints_content_bool_exp!]
  _not: hints_content_bool_exp
  _or: [hints_content_bool_exp!]
  content: String_comparison_exp
  hint: hint_bool_exp
  id: uuid_comparison_exp
}

"""
input type for inserting data into table "hints_content"
"""
input hints_content_insert_input {
  content: String
  hint: hint_obj_rel_insert_input
  id: uuid
}

"""aggregate max on columns"""
type hints_content_max_fields {
  content: String
  id: uuid
}

"""aggregate min on columns"""
type hints_content_min_fields {
  content: String
  id: uuid
}

"""
response of any mutation on the table "hints_content"
"""
type hints_content_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [hints_content!]!
}

"""
input type for inserting object relation for remote table "hints_content"
"""
input hints_content_obj_rel_insert_input {
  data: hints_content_insert_input!
}

"""Ordering options when selecting data from "hints_content"."""
input hints_content_order_by {
  content: order_by
  hint: hint_order_by
  id: order_by
}

"""
select columns of table "hints_content"
"""
enum hints_content_select_column {
  """column name"""
  content

  """column name"""
  id
}

"""
input type for updating data in table "hints_content"
"""
input hints_content_set_input {
  content: String
  id: uuid
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "award"
  """
  delete_award(
    """filter the rows which have to be deleted"""
    where: award_bool_exp!
  ): award_mutation_response

  """
  delete single row from the table: "award"
  """
  delete_award_by_pk(id: uuid!): award

  """
  delete data from the table: "challenge"
  """
  delete_challenge(
    """filter the rows which have to be deleted"""
    where: challenge_bool_exp!
  ): challenge_mutation_response

  """
  delete single row from the table: "challenge"
  """
  delete_challenge_by_pk(id: uuid!): challenge

  """
  delete data from the table: "challenge_tag"
  """
  delete_challenge_tag(
    """filter the rows which have to be deleted"""
    where: challenge_tag_bool_exp!
  ): challenge_tag_mutation_response

  """
  delete single row from the table: "challenge_tag"
  """
  delete_challenge_tag_by_pk(id: uuid!): challenge_tag

  """
  delete data from the table: "comment"
  """
  delete_comment(
    """filter the rows which have to be deleted"""
    where: comment_bool_exp!
  ): comment_mutation_response

  """
  delete single row from the table: "comment"
  """
  delete_comment_by_pk(id: uuid!): comment

  """
  delete data from the table: "config"
  """
  delete_config(
    """filter the rows which have to be deleted"""
    where: config_bool_exp!
  ): config_mutation_response

  """
  delete single row from the table: "config"
  """
  delete_config_by_pk(id: uuid!): config

  """
  delete data from the table: "dynamic_challenge"
  """
  delete_dynamic_challenge(
    """filter the rows which have to be deleted"""
    where: dynamic_challenge_bool_exp!
  ): dynamic_challenge_mutation_response

  """
  delete single row from the table: "dynamic_challenge"
  """
  delete_dynamic_challenge_by_pk(id: uuid!): dynamic_challenge

  """
  delete data from the table: "field"
  """
  delete_field(
    """filter the rows which have to be deleted"""
    where: field_bool_exp!
  ): field_mutation_response

  """
  delete single row from the table: "field"
  """
  delete_field_by_pk(id: uuid!): field

  """
  delete data from the table: "field_entry"
  """
  delete_field_entry(
    """filter the rows which have to be deleted"""
    where: field_entry_bool_exp!
  ): field_entry_mutation_response

  """
  delete single row from the table: "field_entry"
  """
  delete_field_entry_by_pk(id: uuid!): field_entry

  """
  delete data from the table: "file"
  """
  delete_file(
    """filter the rows which have to be deleted"""
    where: file_bool_exp!
  ): file_mutation_response

  """
  delete single row from the table: "file"
  """
  delete_file_by_pk(id: uuid!): file

  """
  delete data from the table: "flag"
  """
  delete_flag(
    """filter the rows which have to be deleted"""
    where: flag_bool_exp!
  ): flag_mutation_response

  """
  delete single row from the table: "flag"
  """
  delete_flag_by_pk(id: uuid!): flag

  """
  delete data from the table: "hint"
  """
  delete_hint(
    """filter the rows which have to be deleted"""
    where: hint_bool_exp!
  ): hint_mutation_response

  """
  delete single row from the table: "hint"
  """
  delete_hint_by_pk(id: uuid!): hint

  """
  delete data from the table: "hints_content"
  """
  delete_hints_content(
    """filter the rows which have to be deleted"""
    where: hints_content_bool_exp!
  ): hints_content_mutation_response

  """
  delete data from the table: "notification"
  """
  delete_notification(
    """filter the rows which have to be deleted"""
    where: notification_bool_exp!
  ): notification_mutation_response

  """
  delete single row from the table: "notification"
  """
  delete_notification_by_pk(id: uuid!): notification

  """
  delete data from the table: "page"
  """
  delete_page(
    """filter the rows which have to be deleted"""
    where: page_bool_exp!
  ): page_mutation_response

  """
  delete single row from the table: "page"
  """
  delete_page_by_pk(id: uuid!): page

  """
  delete data from the table: "solve"
  """
  delete_solve(
    """filter the rows which have to be deleted"""
    where: solve_bool_exp!
  ): solve_mutation_response

  """
  delete single row from the table: "solve"
  """
  delete_solve_by_pk(id: uuid!): solve

  """
  delete data from the table: "submission"
  """
  delete_submission(
    """filter the rows which have to be deleted"""
    where: submission_bool_exp!
  ): submission_mutation_response

  """
  delete single row from the table: "submission"
  """
  delete_submission_by_pk(id: uuid!): submission

  """
  delete data from the table: "tag"
  """
  delete_tag(
    """filter the rows which have to be deleted"""
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  delete single row from the table: "tag"
  """
  delete_tag_by_pk(id: uuid!): tag

  """
  delete data from the table: "team"
  """
  delete_team(
    """filter the rows which have to be deleted"""
    where: team_bool_exp!
  ): team_mutation_response

  """
  delete single row from the table: "team"
  """
  delete_team_by_pk(id: uuid!): team

  """
  delete data from the table: "token"
  """
  delete_token(
    """filter the rows which have to be deleted"""
    where: token_bool_exp!
  ): token_mutation_response

  """
  delete single row from the table: "token"
  """
  delete_token_by_pk(id: uuid!): token

  """
  delete data from the table: "tracking"
  """
  delete_tracking(
    """filter the rows which have to be deleted"""
    where: tracking_bool_exp!
  ): tracking_mutation_response

  """
  delete single row from the table: "tracking"
  """
  delete_tracking_by_pk(id: uuid!): tracking

  """
  delete data from the table: "unlock"
  """
  delete_unlock(
    """filter the rows which have to be deleted"""
    where: unlock_bool_exp!
  ): unlock_mutation_response

  """
  delete single row from the table: "unlock"
  """
  delete_unlock_by_pk(id: uuid!): unlock

  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: uuid!): user

  """
  insert data into the table: "award"
  """
  insert_award(
    """the rows to be inserted"""
    objects: [award_insert_input!]!

    """upsert condition"""
    on_conflict: award_on_conflict
  ): award_mutation_response

  """
  insert a single row into the table: "award"
  """
  insert_award_one(
    """the row to be inserted"""
    object: award_insert_input!

    """upsert condition"""
    on_conflict: award_on_conflict
  ): award

  """
  insert data into the table: "challenge"
  """
  insert_challenge(
    """the rows to be inserted"""
    objects: [challenge_insert_input!]!

    """upsert condition"""
    on_conflict: challenge_on_conflict
  ): challenge_mutation_response

  """
  insert a single row into the table: "challenge"
  """
  insert_challenge_one(
    """the row to be inserted"""
    object: challenge_insert_input!

    """upsert condition"""
    on_conflict: challenge_on_conflict
  ): challenge

  """
  insert data into the table: "challenge_tag"
  """
  insert_challenge_tag(
    """the rows to be inserted"""
    objects: [challenge_tag_insert_input!]!

    """upsert condition"""
    on_conflict: challenge_tag_on_conflict
  ): challenge_tag_mutation_response

  """
  insert a single row into the table: "challenge_tag"
  """
  insert_challenge_tag_one(
    """the row to be inserted"""
    object: challenge_tag_insert_input!

    """upsert condition"""
    on_conflict: challenge_tag_on_conflict
  ): challenge_tag

  """
  insert data into the table: "comment"
  """
  insert_comment(
    """the rows to be inserted"""
    objects: [comment_insert_input!]!

    """upsert condition"""
    on_conflict: comment_on_conflict
  ): comment_mutation_response

  """
  insert a single row into the table: "comment"
  """
  insert_comment_one(
    """the row to be inserted"""
    object: comment_insert_input!

    """upsert condition"""
    on_conflict: comment_on_conflict
  ): comment

  """
  insert data into the table: "config"
  """
  insert_config(
    """the rows to be inserted"""
    objects: [config_insert_input!]!

    """upsert condition"""
    on_conflict: config_on_conflict
  ): config_mutation_response

  """
  insert a single row into the table: "config"
  """
  insert_config_one(
    """the row to be inserted"""
    object: config_insert_input!

    """upsert condition"""
    on_conflict: config_on_conflict
  ): config

  """
  insert data into the table: "dynamic_challenge"
  """
  insert_dynamic_challenge(
    """the rows to be inserted"""
    objects: [dynamic_challenge_insert_input!]!

    """upsert condition"""
    on_conflict: dynamic_challenge_on_conflict
  ): dynamic_challenge_mutation_response

  """
  insert a single row into the table: "dynamic_challenge"
  """
  insert_dynamic_challenge_one(
    """the row to be inserted"""
    object: dynamic_challenge_insert_input!

    """upsert condition"""
    on_conflict: dynamic_challenge_on_conflict
  ): dynamic_challenge

  """
  insert data into the table: "field"
  """
  insert_field(
    """the rows to be inserted"""
    objects: [field_insert_input!]!

    """upsert condition"""
    on_conflict: field_on_conflict
  ): field_mutation_response

  """
  insert data into the table: "field_entry"
  """
  insert_field_entry(
    """the rows to be inserted"""
    objects: [field_entry_insert_input!]!

    """upsert condition"""
    on_conflict: field_entry_on_conflict
  ): field_entry_mutation_response

  """
  insert a single row into the table: "field_entry"
  """
  insert_field_entry_one(
    """the row to be inserted"""
    object: field_entry_insert_input!

    """upsert condition"""
    on_conflict: field_entry_on_conflict
  ): field_entry

  """
  insert a single row into the table: "field"
  """
  insert_field_one(
    """the row to be inserted"""
    object: field_insert_input!

    """upsert condition"""
    on_conflict: field_on_conflict
  ): field

  """
  insert data into the table: "file"
  """
  insert_file(
    """the rows to be inserted"""
    objects: [file_insert_input!]!

    """upsert condition"""
    on_conflict: file_on_conflict
  ): file_mutation_response

  """
  insert a single row into the table: "file"
  """
  insert_file_one(
    """the row to be inserted"""
    object: file_insert_input!

    """upsert condition"""
    on_conflict: file_on_conflict
  ): file

  """
  insert data into the table: "flag"
  """
  insert_flag(
    """the rows to be inserted"""
    objects: [flag_insert_input!]!

    """upsert condition"""
    on_conflict: flag_on_conflict
  ): flag_mutation_response

  """
  insert a single row into the table: "flag"
  """
  insert_flag_one(
    """the row to be inserted"""
    object: flag_insert_input!

    """upsert condition"""
    on_conflict: flag_on_conflict
  ): flag

  """
  insert data into the table: "hint"
  """
  insert_hint(
    """the rows to be inserted"""
    objects: [hint_insert_input!]!

    """upsert condition"""
    on_conflict: hint_on_conflict
  ): hint_mutation_response

  """
  insert a single row into the table: "hint"
  """
  insert_hint_one(
    """the row to be inserted"""
    object: hint_insert_input!

    """upsert condition"""
    on_conflict: hint_on_conflict
  ): hint

  """
  insert data into the table: "hints_content"
  """
  insert_hints_content(
    """the rows to be inserted"""
    objects: [hints_content_insert_input!]!
  ): hints_content_mutation_response

  """
  insert a single row into the table: "hints_content"
  """
  insert_hints_content_one(
    """the row to be inserted"""
    object: hints_content_insert_input!
  ): hints_content

  """
  insert data into the table: "notification"
  """
  insert_notification(
    """the rows to be inserted"""
    objects: [notification_insert_input!]!

    """upsert condition"""
    on_conflict: notification_on_conflict
  ): notification_mutation_response

  """
  insert a single row into the table: "notification"
  """
  insert_notification_one(
    """the row to be inserted"""
    object: notification_insert_input!

    """upsert condition"""
    on_conflict: notification_on_conflict
  ): notification

  """
  insert data into the table: "page"
  """
  insert_page(
    """the rows to be inserted"""
    objects: [page_insert_input!]!

    """upsert condition"""
    on_conflict: page_on_conflict
  ): page_mutation_response

  """
  insert a single row into the table: "page"
  """
  insert_page_one(
    """the row to be inserted"""
    object: page_insert_input!

    """upsert condition"""
    on_conflict: page_on_conflict
  ): page

  """
  insert data into the table: "solve"
  """
  insert_solve(
    """the rows to be inserted"""
    objects: [solve_insert_input!]!

    """upsert condition"""
    on_conflict: solve_on_conflict
  ): solve_mutation_response

  """
  insert a single row into the table: "solve"
  """
  insert_solve_one(
    """the row to be inserted"""
    object: solve_insert_input!

    """upsert condition"""
    on_conflict: solve_on_conflict
  ): solve

  """
  insert data into the table: "submission"
  """
  insert_submission(
    """the rows to be inserted"""
    objects: [submission_insert_input!]!

    """upsert condition"""
    on_conflict: submission_on_conflict
  ): submission_mutation_response

  """
  insert a single row into the table: "submission"
  """
  insert_submission_one(
    """the row to be inserted"""
    object: submission_insert_input!

    """upsert condition"""
    on_conflict: submission_on_conflict
  ): submission

  """
  insert data into the table: "tag"
  """
  insert_tag(
    """the rows to be inserted"""
    objects: [tag_insert_input!]!

    """upsert condition"""
    on_conflict: tag_on_conflict
  ): tag_mutation_response

  """
  insert a single row into the table: "tag"
  """
  insert_tag_one(
    """the row to be inserted"""
    object: tag_insert_input!

    """upsert condition"""
    on_conflict: tag_on_conflict
  ): tag

  """
  insert data into the table: "team"
  """
  insert_team(
    """the rows to be inserted"""
    objects: [team_insert_input!]!

    """upsert condition"""
    on_conflict: team_on_conflict
  ): team_mutation_response

  """
  insert a single row into the table: "team"
  """
  insert_team_one(
    """the row to be inserted"""
    object: team_insert_input!

    """upsert condition"""
    on_conflict: team_on_conflict
  ): team

  """
  insert data into the table: "token"
  """
  insert_token(
    """the rows to be inserted"""
    objects: [token_insert_input!]!

    """upsert condition"""
    on_conflict: token_on_conflict
  ): token_mutation_response

  """
  insert a single row into the table: "token"
  """
  insert_token_one(
    """the row to be inserted"""
    object: token_insert_input!

    """upsert condition"""
    on_conflict: token_on_conflict
  ): token

  """
  insert data into the table: "tracking"
  """
  insert_tracking(
    """the rows to be inserted"""
    objects: [tracking_insert_input!]!

    """upsert condition"""
    on_conflict: tracking_on_conflict
  ): tracking_mutation_response

  """
  insert a single row into the table: "tracking"
  """
  insert_tracking_one(
    """the row to be inserted"""
    object: tracking_insert_input!

    """upsert condition"""
    on_conflict: tracking_on_conflict
  ): tracking

  """
  insert data into the table: "unlock"
  """
  insert_unlock(
    """the rows to be inserted"""
    objects: [unlock_insert_input!]!

    """upsert condition"""
    on_conflict: unlock_on_conflict
  ): unlock_mutation_response

  """
  insert a single row into the table: "unlock"
  """
  insert_unlock_one(
    """the row to be inserted"""
    object: unlock_insert_input!

    """upsert condition"""
    on_conflict: unlock_on_conflict
  ): unlock

  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user

  """
  update data of the table: "award"
  """
  update_award(
    """increments the numeric columns with given value of the filtered values"""
    _inc: award_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: award_set_input

    """filter the rows which have to be updated"""
    where: award_bool_exp!
  ): award_mutation_response

  """
  update single row of the table: "award"
  """
  update_award_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: award_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: award_set_input
    pk_columns: award_pk_columns_input!
  ): award

  """
  update data of the table: "challenge"
  """
  update_challenge(
    """increments the numeric columns with given value of the filtered values"""
    _inc: challenge_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: challenge_set_input

    """filter the rows which have to be updated"""
    where: challenge_bool_exp!
  ): challenge_mutation_response

  """
  update single row of the table: "challenge"
  """
  update_challenge_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: challenge_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: challenge_set_input
    pk_columns: challenge_pk_columns_input!
  ): challenge

  """
  update data of the table: "challenge_tag"
  """
  update_challenge_tag(
    """sets the columns of the filtered rows to the given values"""
    _set: challenge_tag_set_input

    """filter the rows which have to be updated"""
    where: challenge_tag_bool_exp!
  ): challenge_tag_mutation_response

  """
  update single row of the table: "challenge_tag"
  """
  update_challenge_tag_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: challenge_tag_set_input
    pk_columns: challenge_tag_pk_columns_input!
  ): challenge_tag

  """
  update data of the table: "comment"
  """
  update_comment(
    """sets the columns of the filtered rows to the given values"""
    _set: comment_set_input

    """filter the rows which have to be updated"""
    where: comment_bool_exp!
  ): comment_mutation_response

  """
  update single row of the table: "comment"
  """
  update_comment_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: comment_set_input
    pk_columns: comment_pk_columns_input!
  ): comment

  """
  update data of the table: "config"
  """
  update_config(
    """sets the columns of the filtered rows to the given values"""
    _set: config_set_input

    """filter the rows which have to be updated"""
    where: config_bool_exp!
  ): config_mutation_response

  """
  update single row of the table: "config"
  """
  update_config_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: config_set_input
    pk_columns: config_pk_columns_input!
  ): config

  """
  update data of the table: "dynamic_challenge"
  """
  update_dynamic_challenge(
    """increments the numeric columns with given value of the filtered values"""
    _inc: dynamic_challenge_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: dynamic_challenge_set_input

    """filter the rows which have to be updated"""
    where: dynamic_challenge_bool_exp!
  ): dynamic_challenge_mutation_response

  """
  update single row of the table: "dynamic_challenge"
  """
  update_dynamic_challenge_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: dynamic_challenge_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: dynamic_challenge_set_input
    pk_columns: dynamic_challenge_pk_columns_input!
  ): dynamic_challenge

  """
  update data of the table: "field"
  """
  update_field(
    """sets the columns of the filtered rows to the given values"""
    _set: field_set_input

    """filter the rows which have to be updated"""
    where: field_bool_exp!
  ): field_mutation_response

  """
  update single row of the table: "field"
  """
  update_field_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: field_set_input
    pk_columns: field_pk_columns_input!
  ): field

  """
  update data of the table: "field_entry"
  """
  update_field_entry(
    """sets the columns of the filtered rows to the given values"""
    _set: field_entry_set_input

    """filter the rows which have to be updated"""
    where: field_entry_bool_exp!
  ): field_entry_mutation_response

  """
  update single row of the table: "field_entry"
  """
  update_field_entry_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: field_entry_set_input
    pk_columns: field_entry_pk_columns_input!
  ): field_entry

  """
  update data of the table: "file"
  """
  update_file(
    """sets the columns of the filtered rows to the given values"""
    _set: file_set_input

    """filter the rows which have to be updated"""
    where: file_bool_exp!
  ): file_mutation_response

  """
  update single row of the table: "file"
  """
  update_file_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: file_set_input
    pk_columns: file_pk_columns_input!
  ): file

  """
  update data of the table: "flag"
  """
  update_flag(
    """sets the columns of the filtered rows to the given values"""
    _set: flag_set_input

    """filter the rows which have to be updated"""
    where: flag_bool_exp!
  ): flag_mutation_response

  """
  update single row of the table: "flag"
  """
  update_flag_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: flag_set_input
    pk_columns: flag_pk_columns_input!
  ): flag

  """
  update data of the table: "hint"
  """
  update_hint(
    """increments the numeric columns with given value of the filtered values"""
    _inc: hint_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: hint_set_input

    """filter the rows which have to be updated"""
    where: hint_bool_exp!
  ): hint_mutation_response

  """
  update single row of the table: "hint"
  """
  update_hint_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: hint_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: hint_set_input
    pk_columns: hint_pk_columns_input!
  ): hint

  """
  update data of the table: "hints_content"
  """
  update_hints_content(
    """sets the columns of the filtered rows to the given values"""
    _set: hints_content_set_input

    """filter the rows which have to be updated"""
    where: hints_content_bool_exp!
  ): hints_content_mutation_response

  """
  update data of the table: "notification"
  """
  update_notification(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_set_input

    """filter the rows which have to be updated"""
    where: notification_bool_exp!
  ): notification_mutation_response

  """
  update single row of the table: "notification"
  """
  update_notification_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_set_input
    pk_columns: notification_pk_columns_input!
  ): notification

  """
  update data of the table: "page"
  """
  update_page(
    """sets the columns of the filtered rows to the given values"""
    _set: page_set_input

    """filter the rows which have to be updated"""
    where: page_bool_exp!
  ): page_mutation_response

  """
  update single row of the table: "page"
  """
  update_page_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: page_set_input
    pk_columns: page_pk_columns_input!
  ): page

  """
  update data of the table: "solve"
  """
  update_solve(
    """sets the columns of the filtered rows to the given values"""
    _set: solve_set_input

    """filter the rows which have to be updated"""
    where: solve_bool_exp!
  ): solve_mutation_response

  """
  update single row of the table: "solve"
  """
  update_solve_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: solve_set_input
    pk_columns: solve_pk_columns_input!
  ): solve

  """
  update data of the table: "submission"
  """
  update_submission(
    """sets the columns of the filtered rows to the given values"""
    _set: submission_set_input

    """filter the rows which have to be updated"""
    where: submission_bool_exp!
  ): submission_mutation_response

  """
  update single row of the table: "submission"
  """
  update_submission_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: submission_set_input
    pk_columns: submission_pk_columns_input!
  ): submission

  """
  update data of the table: "tag"
  """
  update_tag(
    """sets the columns of the filtered rows to the given values"""
    _set: tag_set_input

    """filter the rows which have to be updated"""
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  update single row of the table: "tag"
  """
  update_tag_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: tag_set_input
    pk_columns: tag_pk_columns_input!
  ): tag

  """
  update data of the table: "team"
  """
  update_team(
    """sets the columns of the filtered rows to the given values"""
    _set: team_set_input

    """filter the rows which have to be updated"""
    where: team_bool_exp!
  ): team_mutation_response

  """
  update single row of the table: "team"
  """
  update_team_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: team_set_input
    pk_columns: team_pk_columns_input!
  ): team

  """
  update data of the table: "token"
  """
  update_token(
    """sets the columns of the filtered rows to the given values"""
    _set: token_set_input

    """filter the rows which have to be updated"""
    where: token_bool_exp!
  ): token_mutation_response

  """
  update single row of the table: "token"
  """
  update_token_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: token_set_input
    pk_columns: token_pk_columns_input!
  ): token

  """
  update data of the table: "tracking"
  """
  update_tracking(
    """sets the columns of the filtered rows to the given values"""
    _set: tracking_set_input

    """filter the rows which have to be updated"""
    where: tracking_bool_exp!
  ): tracking_mutation_response

  """
  update single row of the table: "tracking"
  """
  update_tracking_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: tracking_set_input
    pk_columns: tracking_pk_columns_input!
  ): tracking

  """
  update data of the table: "unlock"
  """
  update_unlock(
    """increments the numeric columns with given value of the filtered values"""
    _inc: unlock_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: unlock_set_input

    """filter the rows which have to be updated"""
    where: unlock_bool_exp!
  ): unlock_mutation_response

  """
  update single row of the table: "unlock"
  """
  update_unlock_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: unlock_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: unlock_set_input
    pk_columns: unlock_pk_columns_input!
  ): unlock

  """
  update data of the table: "user"
  """
  update_user(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user
}

"""
columns and relationships of "notification"
"""
type notification {
  content: String
  date: timestamp
  id: uuid!

  """An object relationship"""
  team: team
  team_id: uuid
  title: String

  """An object relationship"""
  user: user
  user_id: uuid
}

"""
aggregated selection of "notification"
"""
type notification_aggregate {
  aggregate: notification_aggregate_fields
  nodes: [notification!]!
}

"""
aggregate fields of "notification"
"""
type notification_aggregate_fields {
  count(columns: [notification_select_column!], distinct: Boolean): Int!
  max: notification_max_fields
  min: notification_min_fields
}

"""
Boolean expression to filter rows from the table "notification". All fields are combined with a logical 'AND'.
"""
input notification_bool_exp {
  _and: [notification_bool_exp!]
  _not: notification_bool_exp
  _or: [notification_bool_exp!]
  content: String_comparison_exp
  date: timestamp_comparison_exp
  id: uuid_comparison_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
  title: String_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "notification"
"""
enum notification_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notification_pkey
}

"""
input type for inserting data into table "notification"
"""
input notification_insert_input {
  content: String
  date: timestamp
  id: uuid
  team: team_obj_rel_insert_input
  team_id: uuid
  title: String
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type notification_max_fields {
  content: String
  date: timestamp
  id: uuid
  team_id: uuid
  title: String
  user_id: uuid
}

"""aggregate min on columns"""
type notification_min_fields {
  content: String
  date: timestamp
  id: uuid
  team_id: uuid
  title: String
  user_id: uuid
}

"""
response of any mutation on the table "notification"
"""
type notification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notification!]!
}

"""
on_conflict condition type for table "notification"
"""
input notification_on_conflict {
  constraint: notification_constraint!
  update_columns: [notification_update_column!]! = []
  where: notification_bool_exp
}

"""Ordering options when selecting data from "notification"."""
input notification_order_by {
  content: order_by
  date: order_by
  id: order_by
  team: team_order_by
  team_id: order_by
  title: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: notification"""
input notification_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notification"
"""
enum notification_select_column {
  """column name"""
  content

  """column name"""
  date

  """column name"""
  id

  """column name"""
  team_id

  """column name"""
  title

  """column name"""
  user_id
}

"""
input type for updating data in table "notification"
"""
input notification_set_input {
  content: String
  date: timestamp
  id: uuid
  team_id: uuid
  title: String
  user_id: uuid
}

"""
update columns of table "notification"
"""
enum notification_update_column {
  """column name"""
  content

  """column name"""
  date

  """column name"""
  id

  """column name"""
  team_id

  """column name"""
  title

  """column name"""
  user_id
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "page"
"""
type page {
  auth_required: Boolean

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): [comment!]!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): comment_aggregate!
  content: String
  draft: Boolean
  format: String
  hidden: Boolean
  id: uuid!
  route: String
  title: String
}

"""
aggregated selection of "page"
"""
type page_aggregate {
  aggregate: page_aggregate_fields
  nodes: [page!]!
}

"""
aggregate fields of "page"
"""
type page_aggregate_fields {
  count(columns: [page_select_column!], distinct: Boolean): Int!
  max: page_max_fields
  min: page_min_fields
}

"""
Boolean expression to filter rows from the table "page". All fields are combined with a logical 'AND'.
"""
input page_bool_exp {
  _and: [page_bool_exp!]
  _not: page_bool_exp
  _or: [page_bool_exp!]
  auth_required: Boolean_comparison_exp
  comments: comment_bool_exp
  content: String_comparison_exp
  draft: Boolean_comparison_exp
  format: String_comparison_exp
  hidden: Boolean_comparison_exp
  id: uuid_comparison_exp
  route: String_comparison_exp
  title: String_comparison_exp
}

"""
unique or primary key constraints on table "page"
"""
enum page_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  page_pkey

  """
  unique or primary key constraint on columns "route"
  """
  page_route_key
}

"""
input type for inserting data into table "page"
"""
input page_insert_input {
  auth_required: Boolean
  comments: comment_arr_rel_insert_input
  content: String
  draft: Boolean
  format: String
  hidden: Boolean
  id: uuid
  route: String
  title: String
}

"""aggregate max on columns"""
type page_max_fields {
  content: String
  format: String
  id: uuid
  route: String
  title: String
}

"""aggregate min on columns"""
type page_min_fields {
  content: String
  format: String
  id: uuid
  route: String
  title: String
}

"""
response of any mutation on the table "page"
"""
type page_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [page!]!
}

"""
input type for inserting object relation for remote table "page"
"""
input page_obj_rel_insert_input {
  data: page_insert_input!

  """upsert condition"""
  on_conflict: page_on_conflict
}

"""
on_conflict condition type for table "page"
"""
input page_on_conflict {
  constraint: page_constraint!
  update_columns: [page_update_column!]! = []
  where: page_bool_exp
}

"""Ordering options when selecting data from "page"."""
input page_order_by {
  auth_required: order_by
  comments_aggregate: comment_aggregate_order_by
  content: order_by
  draft: order_by
  format: order_by
  hidden: order_by
  id: order_by
  route: order_by
  title: order_by
}

"""primary key columns input for table: page"""
input page_pk_columns_input {
  id: uuid!
}

"""
select columns of table "page"
"""
enum page_select_column {
  """column name"""
  auth_required

  """column name"""
  content

  """column name"""
  draft

  """column name"""
  format

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  route

  """column name"""
  title
}

"""
input type for updating data in table "page"
"""
input page_set_input {
  auth_required: Boolean
  content: String
  draft: Boolean
  format: String
  hidden: Boolean
  id: uuid
  route: String
  title: String
}

"""
update columns of table "page"
"""
enum page_update_column {
  """column name"""
  auth_required

  """column name"""
  content

  """column name"""
  draft

  """column name"""
  format

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  route

  """column name"""
  title
}

type query_root {
  """
  fetch data from the table: "award"
  """
  award(
    """distinct select on columns"""
    distinct_on: [award_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [award_order_by!]

    """filter the rows returned"""
    where: award_bool_exp
  ): [award!]!

  """
  fetch aggregated fields from the table: "award"
  """
  award_aggregate(
    """distinct select on columns"""
    distinct_on: [award_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [award_order_by!]

    """filter the rows returned"""
    where: award_bool_exp
  ): award_aggregate!

  """fetch data from the table: "award" using primary key columns"""
  award_by_pk(id: uuid!): award

  """
  fetch data from the table: "challenge"
  """
  challenge(
    """distinct select on columns"""
    distinct_on: [challenge_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenge_order_by!]

    """filter the rows returned"""
    where: challenge_bool_exp
  ): [challenge!]!

  """
  fetch aggregated fields from the table: "challenge"
  """
  challenge_aggregate(
    """distinct select on columns"""
    distinct_on: [challenge_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenge_order_by!]

    """filter the rows returned"""
    where: challenge_bool_exp
  ): challenge_aggregate!

  """fetch data from the table: "challenge" using primary key columns"""
  challenge_by_pk(id: uuid!): challenge

  """
  fetch data from the table: "challenge_tag"
  """
  challenge_tag(
    """distinct select on columns"""
    distinct_on: [challenge_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenge_tag_order_by!]

    """filter the rows returned"""
    where: challenge_tag_bool_exp
  ): [challenge_tag!]!

  """
  fetch aggregated fields from the table: "challenge_tag"
  """
  challenge_tag_aggregate(
    """distinct select on columns"""
    distinct_on: [challenge_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenge_tag_order_by!]

    """filter the rows returned"""
    where: challenge_tag_bool_exp
  ): challenge_tag_aggregate!

  """fetch data from the table: "challenge_tag" using primary key columns"""
  challenge_tag_by_pk(id: uuid!): challenge_tag

  """
  fetch data from the table: "comment"
  """
  comment(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): [comment!]!

  """
  fetch aggregated fields from the table: "comment"
  """
  comment_aggregate(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): comment_aggregate!

  """fetch data from the table: "comment" using primary key columns"""
  comment_by_pk(id: uuid!): comment

  """
  fetch data from the table: "config"
  """
  config(
    """distinct select on columns"""
    distinct_on: [config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [config_order_by!]

    """filter the rows returned"""
    where: config_bool_exp
  ): [config!]!

  """
  fetch aggregated fields from the table: "config"
  """
  config_aggregate(
    """distinct select on columns"""
    distinct_on: [config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [config_order_by!]

    """filter the rows returned"""
    where: config_bool_exp
  ): config_aggregate!

  """fetch data from the table: "config" using primary key columns"""
  config_by_pk(id: uuid!): config

  """
  execute function "current_user" which returns "user"
  """
  current_user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  execute function "current_user" and query aggregates on result of table type "user"
  """
  current_user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch data from the table: "dynamic_challenge"
  """
  dynamic_challenge(
    """distinct select on columns"""
    distinct_on: [dynamic_challenge_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_challenge_order_by!]

    """filter the rows returned"""
    where: dynamic_challenge_bool_exp
  ): [dynamic_challenge!]!

  """
  fetch aggregated fields from the table: "dynamic_challenge"
  """
  dynamic_challenge_aggregate(
    """distinct select on columns"""
    distinct_on: [dynamic_challenge_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_challenge_order_by!]

    """filter the rows returned"""
    where: dynamic_challenge_bool_exp
  ): dynamic_challenge_aggregate!

  """
  fetch data from the table: "dynamic_challenge" using primary key columns
  """
  dynamic_challenge_by_pk(id: uuid!): dynamic_challenge

  """
  fetch data from the table: "field"
  """
  field(
    """distinct select on columns"""
    distinct_on: [field_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_order_by!]

    """filter the rows returned"""
    where: field_bool_exp
  ): [field!]!

  """
  fetch aggregated fields from the table: "field"
  """
  field_aggregate(
    """distinct select on columns"""
    distinct_on: [field_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_order_by!]

    """filter the rows returned"""
    where: field_bool_exp
  ): field_aggregate!

  """fetch data from the table: "field" using primary key columns"""
  field_by_pk(id: uuid!): field

  """
  fetch data from the table: "field_entry"
  """
  field_entry(
    """distinct select on columns"""
    distinct_on: [field_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entry_order_by!]

    """filter the rows returned"""
    where: field_entry_bool_exp
  ): [field_entry!]!

  """
  fetch aggregated fields from the table: "field_entry"
  """
  field_entry_aggregate(
    """distinct select on columns"""
    distinct_on: [field_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entry_order_by!]

    """filter the rows returned"""
    where: field_entry_bool_exp
  ): field_entry_aggregate!

  """fetch data from the table: "field_entry" using primary key columns"""
  field_entry_by_pk(id: uuid!): field_entry

  """
  fetch data from the table: "file"
  """
  file(
    """distinct select on columns"""
    distinct_on: [file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [file_order_by!]

    """filter the rows returned"""
    where: file_bool_exp
  ): [file!]!

  """
  fetch aggregated fields from the table: "file"
  """
  file_aggregate(
    """distinct select on columns"""
    distinct_on: [file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [file_order_by!]

    """filter the rows returned"""
    where: file_bool_exp
  ): file_aggregate!

  """fetch data from the table: "file" using primary key columns"""
  file_by_pk(id: uuid!): file

  """
  fetch data from the table: "flag"
  """
  flag(
    """distinct select on columns"""
    distinct_on: [flag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [flag_order_by!]

    """filter the rows returned"""
    where: flag_bool_exp
  ): [flag!]!

  """
  fetch aggregated fields from the table: "flag"
  """
  flag_aggregate(
    """distinct select on columns"""
    distinct_on: [flag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [flag_order_by!]

    """filter the rows returned"""
    where: flag_bool_exp
  ): flag_aggregate!

  """fetch data from the table: "flag" using primary key columns"""
  flag_by_pk(id: uuid!): flag

  """
  fetch data from the table: "hint"
  """
  hint(
    """distinct select on columns"""
    distinct_on: [hint_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hint_order_by!]

    """filter the rows returned"""
    where: hint_bool_exp
  ): [hint!]!

  """
  fetch aggregated fields from the table: "hint"
  """
  hint_aggregate(
    """distinct select on columns"""
    distinct_on: [hint_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hint_order_by!]

    """filter the rows returned"""
    where: hint_bool_exp
  ): hint_aggregate!

  """fetch data from the table: "hint" using primary key columns"""
  hint_by_pk(id: uuid!): hint

  """
  fetch data from the table: "hints_content"
  """
  hints_content(
    """distinct select on columns"""
    distinct_on: [hints_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_content_order_by!]

    """filter the rows returned"""
    where: hints_content_bool_exp
  ): [hints_content!]!

  """
  fetch aggregated fields from the table: "hints_content"
  """
  hints_content_aggregate(
    """distinct select on columns"""
    distinct_on: [hints_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_content_order_by!]

    """filter the rows returned"""
    where: hints_content_bool_exp
  ): hints_content_aggregate!

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch aggregated fields from the table: "notification"
  """
  notification_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!

  """fetch data from the table: "notification" using primary key columns"""
  notification_by_pk(id: uuid!): notification

  """
  fetch data from the table: "page"
  """
  page(
    """distinct select on columns"""
    distinct_on: [page_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_order_by!]

    """filter the rows returned"""
    where: page_bool_exp
  ): [page!]!

  """
  fetch aggregated fields from the table: "page"
  """
  page_aggregate(
    """distinct select on columns"""
    distinct_on: [page_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_order_by!]

    """filter the rows returned"""
    where: page_bool_exp
  ): page_aggregate!

  """fetch data from the table: "page" using primary key columns"""
  page_by_pk(id: uuid!): page

  """
  fetch data from the table: "score_event"
  """
  score_event(
    """distinct select on columns"""
    distinct_on: [score_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_event_order_by!]

    """filter the rows returned"""
    where: score_event_bool_exp
  ): [score_event!]!

  """
  fetch aggregated fields from the table: "score_event"
  """
  score_event_aggregate(
    """distinct select on columns"""
    distinct_on: [score_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_event_order_by!]

    """filter the rows returned"""
    where: score_event_bool_exp
  ): score_event_aggregate!

  """An array relationship"""
  score_timeline(
    """distinct select on columns"""
    distinct_on: [score_timeline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_order_by!]

    """filter the rows returned"""
    where: score_timeline_bool_exp
  ): [score_timeline!]!

  """An aggregate relationship"""
  score_timeline_aggregate(
    """distinct select on columns"""
    distinct_on: [score_timeline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_order_by!]

    """filter the rows returned"""
    where: score_timeline_bool_exp
  ): score_timeline_aggregate!

  """
  fetch data from the table: "score_timeline_user"
  """
  score_timeline_user(
    """distinct select on columns"""
    distinct_on: [score_timeline_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_user_order_by!]

    """filter the rows returned"""
    where: score_timeline_user_bool_exp
  ): [score_timeline_user!]!

  """
  fetch aggregated fields from the table: "score_timeline_user"
  """
  score_timeline_user_aggregate(
    """distinct select on columns"""
    distinct_on: [score_timeline_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_user_order_by!]

    """filter the rows returned"""
    where: score_timeline_user_bool_exp
  ): score_timeline_user_aggregate!

  """
  fetch data from the table: "scoreboard"
  """
  scoreboard(
    """distinct select on columns"""
    distinct_on: [scoreboard_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_order_by!]

    """filter the rows returned"""
    where: scoreboard_bool_exp
  ): [scoreboard!]!

  """
  fetch aggregated fields from the table: "scoreboard"
  """
  scoreboard_aggregate(
    """distinct select on columns"""
    distinct_on: [scoreboard_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_order_by!]

    """filter the rows returned"""
    where: scoreboard_bool_exp
  ): scoreboard_aggregate!

  """
  fetch data from the table: "scoreboard_user"
  """
  scoreboard_user(
    """distinct select on columns"""
    distinct_on: [scoreboard_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_user_order_by!]

    """filter the rows returned"""
    where: scoreboard_user_bool_exp
  ): [scoreboard_user!]!

  """
  fetch aggregated fields from the table: "scoreboard_user"
  """
  scoreboard_user_aggregate(
    """distinct select on columns"""
    distinct_on: [scoreboard_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_user_order_by!]

    """filter the rows returned"""
    where: scoreboard_user_bool_exp
  ): scoreboard_user_aggregate!

  """
  fetch data from the table: "solve"
  """
  solve(
    """distinct select on columns"""
    distinct_on: [solve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solve_order_by!]

    """filter the rows returned"""
    where: solve_bool_exp
  ): [solve!]!

  """
  fetch aggregated fields from the table: "solve"
  """
  solve_aggregate(
    """distinct select on columns"""
    distinct_on: [solve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solve_order_by!]

    """filter the rows returned"""
    where: solve_bool_exp
  ): solve_aggregate!

  """fetch data from the table: "solve" using primary key columns"""
  solve_by_pk(id: uuid!): solve

  """
  fetch data from the table: "submission"
  """
  submission(
    """distinct select on columns"""
    distinct_on: [submission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submission_order_by!]

    """filter the rows returned"""
    where: submission_bool_exp
  ): [submission!]!

  """
  fetch aggregated fields from the table: "submission"
  """
  submission_aggregate(
    """distinct select on columns"""
    distinct_on: [submission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submission_order_by!]

    """filter the rows returned"""
    where: submission_bool_exp
  ): submission_aggregate!

  """fetch data from the table: "submission" using primary key columns"""
  submission_by_pk(id: uuid!): submission

  """
  fetch data from the table: "tag"
  """
  tag(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """
  fetch aggregated fields from the table: "tag"
  """
  tag_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """fetch data from the table: "tag" using primary key columns"""
  tag_by_pk(id: uuid!): tag

  """
  fetch data from the table: "team"
  """
  team(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  fetch aggregated fields from the table: "team"
  """
  team_aggregate(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """fetch data from the table: "team" using primary key columns"""
  team_by_pk(id: uuid!): team

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  fetch aggregated fields from the table: "token"
  """
  token_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """fetch data from the table: "token" using primary key columns"""
  token_by_pk(id: uuid!): token

  """
  fetch data from the table: "tracking"
  """
  tracking(
    """distinct select on columns"""
    distinct_on: [tracking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tracking_order_by!]

    """filter the rows returned"""
    where: tracking_bool_exp
  ): [tracking!]!

  """
  fetch aggregated fields from the table: "tracking"
  """
  tracking_aggregate(
    """distinct select on columns"""
    distinct_on: [tracking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tracking_order_by!]

    """filter the rows returned"""
    where: tracking_bool_exp
  ): tracking_aggregate!

  """fetch data from the table: "tracking" using primary key columns"""
  tracking_by_pk(id: uuid!): tracking

  """
  fetch data from the table: "unlock"
  """
  unlock(
    """distinct select on columns"""
    distinct_on: [unlock_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlock_order_by!]

    """filter the rows returned"""
    where: unlock_bool_exp
  ): [unlock!]!

  """
  fetch aggregated fields from the table: "unlock"
  """
  unlock_aggregate(
    """distinct select on columns"""
    distinct_on: [unlock_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlock_order_by!]

    """filter the rows returned"""
    where: unlock_bool_exp
  ): unlock_aggregate!

  """fetch data from the table: "unlock" using primary key columns"""
  unlock_by_pk(id: uuid!): unlock

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: uuid!): user
}

"""
columns and relationships of "score_event"
"""
type score_event {
  event_time: timestamp
  event_value: Int
  team_id: uuid
  user_id: uuid
}

"""
aggregated selection of "score_event"
"""
type score_event_aggregate {
  aggregate: score_event_aggregate_fields
  nodes: [score_event!]!
}

"""
aggregate fields of "score_event"
"""
type score_event_aggregate_fields {
  avg: score_event_avg_fields
  count(columns: [score_event_select_column!], distinct: Boolean): Int!
  max: score_event_max_fields
  min: score_event_min_fields
  stddev: score_event_stddev_fields
  stddev_pop: score_event_stddev_pop_fields
  stddev_samp: score_event_stddev_samp_fields
  sum: score_event_sum_fields
  var_pop: score_event_var_pop_fields
  var_samp: score_event_var_samp_fields
  variance: score_event_variance_fields
}

"""aggregate avg on columns"""
type score_event_avg_fields {
  event_value: Float
}

"""
Boolean expression to filter rows from the table "score_event". All fields are combined with a logical 'AND'.
"""
input score_event_bool_exp {
  _and: [score_event_bool_exp!]
  _not: score_event_bool_exp
  _or: [score_event_bool_exp!]
  event_time: timestamp_comparison_exp
  event_value: Int_comparison_exp
  team_id: uuid_comparison_exp
  user_id: uuid_comparison_exp
}

"""aggregate max on columns"""
type score_event_max_fields {
  event_time: timestamp
  event_value: Int
  team_id: uuid
  user_id: uuid
}

"""aggregate min on columns"""
type score_event_min_fields {
  event_time: timestamp
  event_value: Int
  team_id: uuid
  user_id: uuid
}

"""Ordering options when selecting data from "score_event"."""
input score_event_order_by {
  event_time: order_by
  event_value: order_by
  team_id: order_by
  user_id: order_by
}

"""
select columns of table "score_event"
"""
enum score_event_select_column {
  """column name"""
  event_time

  """column name"""
  event_value

  """column name"""
  team_id

  """column name"""
  user_id
}

"""aggregate stddev on columns"""
type score_event_stddev_fields {
  event_value: Float
}

"""aggregate stddev_pop on columns"""
type score_event_stddev_pop_fields {
  event_value: Float
}

"""aggregate stddev_samp on columns"""
type score_event_stddev_samp_fields {
  event_value: Float
}

"""aggregate sum on columns"""
type score_event_sum_fields {
  event_value: Int
}

"""aggregate var_pop on columns"""
type score_event_var_pop_fields {
  event_value: Float
}

"""aggregate var_samp on columns"""
type score_event_var_samp_fields {
  event_value: Float
}

"""aggregate variance on columns"""
type score_event_variance_fields {
  event_value: Float
}

"""
columns and relationships of "score_timeline"
"""
type score_timeline {
  event_time: timestamp
  score: bigint

  """An object relationship"""
  team: team
  team_id: uuid
}

"""
aggregated selection of "score_timeline"
"""
type score_timeline_aggregate {
  aggregate: score_timeline_aggregate_fields
  nodes: [score_timeline!]!
}

"""
aggregate fields of "score_timeline"
"""
type score_timeline_aggregate_fields {
  avg: score_timeline_avg_fields
  count(columns: [score_timeline_select_column!], distinct: Boolean): Int!
  max: score_timeline_max_fields
  min: score_timeline_min_fields
  stddev: score_timeline_stddev_fields
  stddev_pop: score_timeline_stddev_pop_fields
  stddev_samp: score_timeline_stddev_samp_fields
  sum: score_timeline_sum_fields
  var_pop: score_timeline_var_pop_fields
  var_samp: score_timeline_var_samp_fields
  variance: score_timeline_variance_fields
}

"""
order by aggregate values of table "score_timeline"
"""
input score_timeline_aggregate_order_by {
  avg: score_timeline_avg_order_by
  count: order_by
  max: score_timeline_max_order_by
  min: score_timeline_min_order_by
  stddev: score_timeline_stddev_order_by
  stddev_pop: score_timeline_stddev_pop_order_by
  stddev_samp: score_timeline_stddev_samp_order_by
  sum: score_timeline_sum_order_by
  var_pop: score_timeline_var_pop_order_by
  var_samp: score_timeline_var_samp_order_by
  variance: score_timeline_variance_order_by
}

"""
input type for inserting array relation for remote table "score_timeline"
"""
input score_timeline_arr_rel_insert_input {
  data: [score_timeline_insert_input!]!
}

"""aggregate avg on columns"""
type score_timeline_avg_fields {
  score: Float
}

"""
order by avg() on columns of table "score_timeline"
"""
input score_timeline_avg_order_by {
  score: order_by
}

"""
Boolean expression to filter rows from the table "score_timeline". All fields are combined with a logical 'AND'.
"""
input score_timeline_bool_exp {
  _and: [score_timeline_bool_exp!]
  _not: score_timeline_bool_exp
  _or: [score_timeline_bool_exp!]
  event_time: timestamp_comparison_exp
  score: bigint_comparison_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
}

"""
input type for inserting data into table "score_timeline"
"""
input score_timeline_insert_input {
  event_time: timestamp
  score: bigint
  team: team_obj_rel_insert_input
  team_id: uuid
}

"""aggregate max on columns"""
type score_timeline_max_fields {
  event_time: timestamp
  score: bigint
  team_id: uuid
}

"""
order by max() on columns of table "score_timeline"
"""
input score_timeline_max_order_by {
  event_time: order_by
  score: order_by
  team_id: order_by
}

"""aggregate min on columns"""
type score_timeline_min_fields {
  event_time: timestamp
  score: bigint
  team_id: uuid
}

"""
order by min() on columns of table "score_timeline"
"""
input score_timeline_min_order_by {
  event_time: order_by
  score: order_by
  team_id: order_by
}

"""Ordering options when selecting data from "score_timeline"."""
input score_timeline_order_by {
  event_time: order_by
  score: order_by
  team: team_order_by
  team_id: order_by
}

"""
select columns of table "score_timeline"
"""
enum score_timeline_select_column {
  """column name"""
  event_time

  """column name"""
  score

  """column name"""
  team_id
}

"""aggregate stddev on columns"""
type score_timeline_stddev_fields {
  score: Float
}

"""
order by stddev() on columns of table "score_timeline"
"""
input score_timeline_stddev_order_by {
  score: order_by
}

"""aggregate stddev_pop on columns"""
type score_timeline_stddev_pop_fields {
  score: Float
}

"""
order by stddev_pop() on columns of table "score_timeline"
"""
input score_timeline_stddev_pop_order_by {
  score: order_by
}

"""aggregate stddev_samp on columns"""
type score_timeline_stddev_samp_fields {
  score: Float
}

"""
order by stddev_samp() on columns of table "score_timeline"
"""
input score_timeline_stddev_samp_order_by {
  score: order_by
}

"""aggregate sum on columns"""
type score_timeline_sum_fields {
  score: bigint
}

"""
order by sum() on columns of table "score_timeline"
"""
input score_timeline_sum_order_by {
  score: order_by
}

"""
columns and relationships of "score_timeline_user"
"""
type score_timeline_user {
  event_time: timestamp
  score: bigint

  """An object relationship"""
  team: team
  team_id: uuid
  user_id: uuid
}

"""
aggregated selection of "score_timeline_user"
"""
type score_timeline_user_aggregate {
  aggregate: score_timeline_user_aggregate_fields
  nodes: [score_timeline_user!]!
}

"""
aggregate fields of "score_timeline_user"
"""
type score_timeline_user_aggregate_fields {
  avg: score_timeline_user_avg_fields
  count(columns: [score_timeline_user_select_column!], distinct: Boolean): Int!
  max: score_timeline_user_max_fields
  min: score_timeline_user_min_fields
  stddev: score_timeline_user_stddev_fields
  stddev_pop: score_timeline_user_stddev_pop_fields
  stddev_samp: score_timeline_user_stddev_samp_fields
  sum: score_timeline_user_sum_fields
  var_pop: score_timeline_user_var_pop_fields
  var_samp: score_timeline_user_var_samp_fields
  variance: score_timeline_user_variance_fields
}

"""
order by aggregate values of table "score_timeline_user"
"""
input score_timeline_user_aggregate_order_by {
  avg: score_timeline_user_avg_order_by
  count: order_by
  max: score_timeline_user_max_order_by
  min: score_timeline_user_min_order_by
  stddev: score_timeline_user_stddev_order_by
  stddev_pop: score_timeline_user_stddev_pop_order_by
  stddev_samp: score_timeline_user_stddev_samp_order_by
  sum: score_timeline_user_sum_order_by
  var_pop: score_timeline_user_var_pop_order_by
  var_samp: score_timeline_user_var_samp_order_by
  variance: score_timeline_user_variance_order_by
}

"""
input type for inserting array relation for remote table "score_timeline_user"
"""
input score_timeline_user_arr_rel_insert_input {
  data: [score_timeline_user_insert_input!]!
}

"""aggregate avg on columns"""
type score_timeline_user_avg_fields {
  score: Float
}

"""
order by avg() on columns of table "score_timeline_user"
"""
input score_timeline_user_avg_order_by {
  score: order_by
}

"""
Boolean expression to filter rows from the table "score_timeline_user". All fields are combined with a logical 'AND'.
"""
input score_timeline_user_bool_exp {
  _and: [score_timeline_user_bool_exp!]
  _not: score_timeline_user_bool_exp
  _or: [score_timeline_user_bool_exp!]
  event_time: timestamp_comparison_exp
  score: bigint_comparison_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
  user_id: uuid_comparison_exp
}

"""
input type for inserting data into table "score_timeline_user"
"""
input score_timeline_user_insert_input {
  event_time: timestamp
  score: bigint
  team: team_obj_rel_insert_input
  team_id: uuid
  user_id: uuid
}

"""aggregate max on columns"""
type score_timeline_user_max_fields {
  event_time: timestamp
  score: bigint
  team_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "score_timeline_user"
"""
input score_timeline_user_max_order_by {
  event_time: order_by
  score: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type score_timeline_user_min_fields {
  event_time: timestamp
  score: bigint
  team_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "score_timeline_user"
"""
input score_timeline_user_min_order_by {
  event_time: order_by
  score: order_by
  team_id: order_by
  user_id: order_by
}

"""Ordering options when selecting data from "score_timeline_user"."""
input score_timeline_user_order_by {
  event_time: order_by
  score: order_by
  team: team_order_by
  team_id: order_by
  user_id: order_by
}

"""
select columns of table "score_timeline_user"
"""
enum score_timeline_user_select_column {
  """column name"""
  event_time

  """column name"""
  score

  """column name"""
  team_id

  """column name"""
  user_id
}

"""aggregate stddev on columns"""
type score_timeline_user_stddev_fields {
  score: Float
}

"""
order by stddev() on columns of table "score_timeline_user"
"""
input score_timeline_user_stddev_order_by {
  score: order_by
}

"""aggregate stddev_pop on columns"""
type score_timeline_user_stddev_pop_fields {
  score: Float
}

"""
order by stddev_pop() on columns of table "score_timeline_user"
"""
input score_timeline_user_stddev_pop_order_by {
  score: order_by
}

"""aggregate stddev_samp on columns"""
type score_timeline_user_stddev_samp_fields {
  score: Float
}

"""
order by stddev_samp() on columns of table "score_timeline_user"
"""
input score_timeline_user_stddev_samp_order_by {
  score: order_by
}

"""aggregate sum on columns"""
type score_timeline_user_sum_fields {
  score: bigint
}

"""
order by sum() on columns of table "score_timeline_user"
"""
input score_timeline_user_sum_order_by {
  score: order_by
}

"""aggregate var_pop on columns"""
type score_timeline_user_var_pop_fields {
  score: Float
}

"""
order by var_pop() on columns of table "score_timeline_user"
"""
input score_timeline_user_var_pop_order_by {
  score: order_by
}

"""aggregate var_samp on columns"""
type score_timeline_user_var_samp_fields {
  score: Float
}

"""
order by var_samp() on columns of table "score_timeline_user"
"""
input score_timeline_user_var_samp_order_by {
  score: order_by
}

"""aggregate variance on columns"""
type score_timeline_user_variance_fields {
  score: Float
}

"""
order by variance() on columns of table "score_timeline_user"
"""
input score_timeline_user_variance_order_by {
  score: order_by
}

"""aggregate var_pop on columns"""
type score_timeline_var_pop_fields {
  score: Float
}

"""
order by var_pop() on columns of table "score_timeline"
"""
input score_timeline_var_pop_order_by {
  score: order_by
}

"""aggregate var_samp on columns"""
type score_timeline_var_samp_fields {
  score: Float
}

"""
order by var_samp() on columns of table "score_timeline"
"""
input score_timeline_var_samp_order_by {
  score: order_by
}

"""aggregate variance on columns"""
type score_timeline_variance_fields {
  score: Float
}

"""
order by variance() on columns of table "score_timeline"
"""
input score_timeline_variance_order_by {
  score: order_by
}

"""
columns and relationships of "scoreboard"
"""
type scoreboard {
  max_time: timestamp
  rank: bigint
  score: bigint

  """An object relationship"""
  team: team
  team_id: uuid
}

"""
aggregated selection of "scoreboard"
"""
type scoreboard_aggregate {
  aggregate: scoreboard_aggregate_fields
  nodes: [scoreboard!]!
}

"""
aggregate fields of "scoreboard"
"""
type scoreboard_aggregate_fields {
  avg: scoreboard_avg_fields
  count(columns: [scoreboard_select_column!], distinct: Boolean): Int!
  max: scoreboard_max_fields
  min: scoreboard_min_fields
  stddev: scoreboard_stddev_fields
  stddev_pop: scoreboard_stddev_pop_fields
  stddev_samp: scoreboard_stddev_samp_fields
  sum: scoreboard_sum_fields
  var_pop: scoreboard_var_pop_fields
  var_samp: scoreboard_var_samp_fields
  variance: scoreboard_variance_fields
}

"""aggregate avg on columns"""
type scoreboard_avg_fields {
  rank: Float
  score: Float
}

"""
Boolean expression to filter rows from the table "scoreboard". All fields are combined with a logical 'AND'.
"""
input scoreboard_bool_exp {
  _and: [scoreboard_bool_exp!]
  _not: scoreboard_bool_exp
  _or: [scoreboard_bool_exp!]
  max_time: timestamp_comparison_exp
  rank: bigint_comparison_exp
  score: bigint_comparison_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
}

"""
input type for inserting data into table "scoreboard"
"""
input scoreboard_insert_input {
  max_time: timestamp
  rank: bigint
  score: bigint
  team: team_obj_rel_insert_input
  team_id: uuid
}

"""aggregate max on columns"""
type scoreboard_max_fields {
  max_time: timestamp
  rank: bigint
  score: bigint
  team_id: uuid
}

"""aggregate min on columns"""
type scoreboard_min_fields {
  max_time: timestamp
  rank: bigint
  score: bigint
  team_id: uuid
}

"""
input type for inserting object relation for remote table "scoreboard"
"""
input scoreboard_obj_rel_insert_input {
  data: scoreboard_insert_input!
}

"""Ordering options when selecting data from "scoreboard"."""
input scoreboard_order_by {
  max_time: order_by
  rank: order_by
  score: order_by
  team: team_order_by
  team_id: order_by
}

"""
select columns of table "scoreboard"
"""
enum scoreboard_select_column {
  """column name"""
  max_time

  """column name"""
  rank

  """column name"""
  score

  """column name"""
  team_id
}

"""aggregate stddev on columns"""
type scoreboard_stddev_fields {
  rank: Float
  score: Float
}

"""aggregate stddev_pop on columns"""
type scoreboard_stddev_pop_fields {
  rank: Float
  score: Float
}

"""aggregate stddev_samp on columns"""
type scoreboard_stddev_samp_fields {
  rank: Float
  score: Float
}

"""aggregate sum on columns"""
type scoreboard_sum_fields {
  rank: bigint
  score: bigint
}

"""
columns and relationships of "scoreboard_user"
"""
type scoreboard_user {
  max_time: timestamp
  rank: bigint
  score: bigint

  """An object relationship"""
  team: team
  team_id: uuid

  """An object relationship"""
  user: user
  user_id: uuid
}

"""
aggregated selection of "scoreboard_user"
"""
type scoreboard_user_aggregate {
  aggregate: scoreboard_user_aggregate_fields
  nodes: [scoreboard_user!]!
}

"""
aggregate fields of "scoreboard_user"
"""
type scoreboard_user_aggregate_fields {
  avg: scoreboard_user_avg_fields
  count(columns: [scoreboard_user_select_column!], distinct: Boolean): Int!
  max: scoreboard_user_max_fields
  min: scoreboard_user_min_fields
  stddev: scoreboard_user_stddev_fields
  stddev_pop: scoreboard_user_stddev_pop_fields
  stddev_samp: scoreboard_user_stddev_samp_fields
  sum: scoreboard_user_sum_fields
  var_pop: scoreboard_user_var_pop_fields
  var_samp: scoreboard_user_var_samp_fields
  variance: scoreboard_user_variance_fields
}

"""aggregate avg on columns"""
type scoreboard_user_avg_fields {
  rank: Float
  score: Float
}

"""
Boolean expression to filter rows from the table "scoreboard_user". All fields are combined with a logical 'AND'.
"""
input scoreboard_user_bool_exp {
  _and: [scoreboard_user_bool_exp!]
  _not: scoreboard_user_bool_exp
  _or: [scoreboard_user_bool_exp!]
  max_time: timestamp_comparison_exp
  rank: bigint_comparison_exp
  score: bigint_comparison_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""aggregate max on columns"""
type scoreboard_user_max_fields {
  max_time: timestamp
  rank: bigint
  score: bigint
  team_id: uuid
  user_id: uuid
}

"""aggregate min on columns"""
type scoreboard_user_min_fields {
  max_time: timestamp
  rank: bigint
  score: bigint
  team_id: uuid
  user_id: uuid
}

"""Ordering options when selecting data from "scoreboard_user"."""
input scoreboard_user_order_by {
  max_time: order_by
  rank: order_by
  score: order_by
  team: team_order_by
  team_id: order_by
  user: user_order_by
  user_id: order_by
}

"""
select columns of table "scoreboard_user"
"""
enum scoreboard_user_select_column {
  """column name"""
  max_time

  """column name"""
  rank

  """column name"""
  score

  """column name"""
  team_id

  """column name"""
  user_id
}

"""aggregate stddev on columns"""
type scoreboard_user_stddev_fields {
  rank: Float
  score: Float
}

"""aggregate stddev_pop on columns"""
type scoreboard_user_stddev_pop_fields {
  rank: Float
  score: Float
}

"""aggregate stddev_samp on columns"""
type scoreboard_user_stddev_samp_fields {
  rank: Float
  score: Float
}

"""aggregate sum on columns"""
type scoreboard_user_sum_fields {
  rank: bigint
  score: bigint
}

"""aggregate var_pop on columns"""
type scoreboard_user_var_pop_fields {
  rank: Float
  score: Float
}

"""aggregate var_samp on columns"""
type scoreboard_user_var_samp_fields {
  rank: Float
  score: Float
}

"""aggregate variance on columns"""
type scoreboard_user_variance_fields {
  rank: Float
  score: Float
}

"""aggregate var_pop on columns"""
type scoreboard_var_pop_fields {
  rank: Float
  score: Float
}

"""aggregate var_samp on columns"""
type scoreboard_var_samp_fields {
  rank: Float
  score: Float
}

"""aggregate variance on columns"""
type scoreboard_variance_fields {
  rank: Float
  score: Float
}

"""
columns and relationships of "solve"
"""
type solve {
  """An object relationship"""
  challenge: challenge
  challenge_id: uuid
  id: uuid!

  """An object relationship"""
  submission: submission!

  """An object relationship"""
  team: team
  team_id: uuid

  """An object relationship"""
  user: user
  user_id: uuid
}

"""
aggregated selection of "solve"
"""
type solve_aggregate {
  aggregate: solve_aggregate_fields
  nodes: [solve!]!
}

"""
aggregate fields of "solve"
"""
type solve_aggregate_fields {
  count(columns: [solve_select_column!], distinct: Boolean): Int!
  max: solve_max_fields
  min: solve_min_fields
}

"""
order by aggregate values of table "solve"
"""
input solve_aggregate_order_by {
  count: order_by
  max: solve_max_order_by
  min: solve_min_order_by
}

"""
input type for inserting array relation for remote table "solve"
"""
input solve_arr_rel_insert_input {
  data: [solve_insert_input!]!

  """upsert condition"""
  on_conflict: solve_on_conflict
}

"""
Boolean expression to filter rows from the table "solve". All fields are combined with a logical 'AND'.
"""
input solve_bool_exp {
  _and: [solve_bool_exp!]
  _not: solve_bool_exp
  _or: [solve_bool_exp!]
  challenge: challenge_bool_exp
  challenge_id: uuid_comparison_exp
  id: uuid_comparison_exp
  submission: submission_bool_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "solve"
"""
enum solve_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  solve_pkey

  """
  unique or primary key constraint on columns "challenge_id", "team_id"
  """
  solves_challenge_id_team_id_key

  """
  unique or primary key constraint on columns "challenge_id", "user_id"
  """
  solves_challenge_id_user_id_key
}

"""
input type for inserting data into table "solve"
"""
input solve_insert_input {
  challenge: challenge_obj_rel_insert_input
  challenge_id: uuid
  id: uuid
  submission: submission_obj_rel_insert_input
  team: team_obj_rel_insert_input
  team_id: uuid
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type solve_max_fields {
  challenge_id: uuid
  id: uuid
  team_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "solve"
"""
input solve_max_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type solve_min_fields {
  challenge_id: uuid
  id: uuid
  team_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "solve"
"""
input solve_min_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "solve"
"""
type solve_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [solve!]!
}

"""
input type for inserting object relation for remote table "solve"
"""
input solve_obj_rel_insert_input {
  data: solve_insert_input!

  """upsert condition"""
  on_conflict: solve_on_conflict
}

"""
on_conflict condition type for table "solve"
"""
input solve_on_conflict {
  constraint: solve_constraint!
  update_columns: [solve_update_column!]! = []
  where: solve_bool_exp
}

"""Ordering options when selecting data from "solve"."""
input solve_order_by {
  challenge: challenge_order_by
  challenge_id: order_by
  id: order_by
  submission: submission_order_by
  team: team_order_by
  team_id: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: solve"""
input solve_pk_columns_input {
  id: uuid!
}

"""
select columns of table "solve"
"""
enum solve_select_column {
  """column name"""
  challenge_id

  """column name"""
  id

  """column name"""
  team_id

  """column name"""
  user_id
}

"""
input type for updating data in table "solve"
"""
input solve_set_input {
  challenge_id: uuid
  id: uuid
  team_id: uuid
  user_id: uuid
}

"""
update columns of table "solve"
"""
enum solve_update_column {
  """column name"""
  challenge_id

  """column name"""
  id

  """column name"""
  team_id

  """column name"""
  user_id
}

"""
columns and relationships of "submission"
"""
type submission {
  """An object relationship"""
  challenge: challenge
  challenge_id: uuid
  date: timestamp
  id: uuid!
  ip: String
  provided: String

  """An object relationship"""
  solve: solve

  """An object relationship"""
  team: team
  team_id: uuid
  type: String

  """An object relationship"""
  user: user
  user_id: uuid
}

"""
aggregated selection of "submission"
"""
type submission_aggregate {
  aggregate: submission_aggregate_fields
  nodes: [submission!]!
}

"""
aggregate fields of "submission"
"""
type submission_aggregate_fields {
  count(columns: [submission_select_column!], distinct: Boolean): Int!
  max: submission_max_fields
  min: submission_min_fields
}

"""
order by aggregate values of table "submission"
"""
input submission_aggregate_order_by {
  count: order_by
  max: submission_max_order_by
  min: submission_min_order_by
}

"""
input type for inserting array relation for remote table "submission"
"""
input submission_arr_rel_insert_input {
  data: [submission_insert_input!]!

  """upsert condition"""
  on_conflict: submission_on_conflict
}

"""
Boolean expression to filter rows from the table "submission". All fields are combined with a logical 'AND'.
"""
input submission_bool_exp {
  _and: [submission_bool_exp!]
  _not: submission_bool_exp
  _or: [submission_bool_exp!]
  challenge: challenge_bool_exp
  challenge_id: uuid_comparison_exp
  date: timestamp_comparison_exp
  id: uuid_comparison_exp
  ip: String_comparison_exp
  provided: String_comparison_exp
  solve: solve_bool_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
  type: String_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "submission"
"""
enum submission_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  submission_pkey
}

"""
input type for inserting data into table "submission"
"""
input submission_insert_input {
  challenge: challenge_obj_rel_insert_input
  challenge_id: uuid
  date: timestamp
  id: uuid
  ip: String
  provided: String
  solve: solve_obj_rel_insert_input
  team: team_obj_rel_insert_input
  team_id: uuid
  type: String
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type submission_max_fields {
  challenge_id: uuid
  date: timestamp
  id: uuid
  ip: String
  provided: String
  team_id: uuid
  type: String
  user_id: uuid
}

"""
order by max() on columns of table "submission"
"""
input submission_max_order_by {
  challenge_id: order_by
  date: order_by
  id: order_by
  ip: order_by
  provided: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type submission_min_fields {
  challenge_id: uuid
  date: timestamp
  id: uuid
  ip: String
  provided: String
  team_id: uuid
  type: String
  user_id: uuid
}

"""
order by min() on columns of table "submission"
"""
input submission_min_order_by {
  challenge_id: order_by
  date: order_by
  id: order_by
  ip: order_by
  provided: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""
response of any mutation on the table "submission"
"""
type submission_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [submission!]!
}

"""
input type for inserting object relation for remote table "submission"
"""
input submission_obj_rel_insert_input {
  data: submission_insert_input!

  """upsert condition"""
  on_conflict: submission_on_conflict
}

"""
on_conflict condition type for table "submission"
"""
input submission_on_conflict {
  constraint: submission_constraint!
  update_columns: [submission_update_column!]! = []
  where: submission_bool_exp
}

"""Ordering options when selecting data from "submission"."""
input submission_order_by {
  challenge: challenge_order_by
  challenge_id: order_by
  date: order_by
  id: order_by
  ip: order_by
  provided: order_by
  solve: solve_order_by
  team: team_order_by
  team_id: order_by
  type: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: submission"""
input submission_pk_columns_input {
  id: uuid!
}

"""
select columns of table "submission"
"""
enum submission_select_column {
  """column name"""
  challenge_id

  """column name"""
  date

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  provided

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id
}

"""
input type for updating data in table "submission"
"""
input submission_set_input {
  challenge_id: uuid
  date: timestamp
  id: uuid
  ip: String
  provided: String
  team_id: uuid
  type: String
  user_id: uuid
}

"""
update columns of table "submission"
"""
enum submission_update_column {
  """column name"""
  challenge_id

  """column name"""
  date

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  provided

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id
}

type subscription_root {
  """
  fetch data from the table: "award"
  """
  award(
    """distinct select on columns"""
    distinct_on: [award_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [award_order_by!]

    """filter the rows returned"""
    where: award_bool_exp
  ): [award!]!

  """
  fetch aggregated fields from the table: "award"
  """
  award_aggregate(
    """distinct select on columns"""
    distinct_on: [award_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [award_order_by!]

    """filter the rows returned"""
    where: award_bool_exp
  ): award_aggregate!

  """fetch data from the table: "award" using primary key columns"""
  award_by_pk(id: uuid!): award

  """
  fetch data from the table: "challenge"
  """
  challenge(
    """distinct select on columns"""
    distinct_on: [challenge_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenge_order_by!]

    """filter the rows returned"""
    where: challenge_bool_exp
  ): [challenge!]!

  """
  fetch aggregated fields from the table: "challenge"
  """
  challenge_aggregate(
    """distinct select on columns"""
    distinct_on: [challenge_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenge_order_by!]

    """filter the rows returned"""
    where: challenge_bool_exp
  ): challenge_aggregate!

  """fetch data from the table: "challenge" using primary key columns"""
  challenge_by_pk(id: uuid!): challenge

  """
  fetch data from the table: "challenge_tag"
  """
  challenge_tag(
    """distinct select on columns"""
    distinct_on: [challenge_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenge_tag_order_by!]

    """filter the rows returned"""
    where: challenge_tag_bool_exp
  ): [challenge_tag!]!

  """
  fetch aggregated fields from the table: "challenge_tag"
  """
  challenge_tag_aggregate(
    """distinct select on columns"""
    distinct_on: [challenge_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenge_tag_order_by!]

    """filter the rows returned"""
    where: challenge_tag_bool_exp
  ): challenge_tag_aggregate!

  """fetch data from the table: "challenge_tag" using primary key columns"""
  challenge_tag_by_pk(id: uuid!): challenge_tag

  """
  fetch data from the table: "comment"
  """
  comment(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): [comment!]!

  """
  fetch aggregated fields from the table: "comment"
  """
  comment_aggregate(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): comment_aggregate!

  """fetch data from the table: "comment" using primary key columns"""
  comment_by_pk(id: uuid!): comment

  """
  fetch data from the table: "config"
  """
  config(
    """distinct select on columns"""
    distinct_on: [config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [config_order_by!]

    """filter the rows returned"""
    where: config_bool_exp
  ): [config!]!

  """
  fetch aggregated fields from the table: "config"
  """
  config_aggregate(
    """distinct select on columns"""
    distinct_on: [config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [config_order_by!]

    """filter the rows returned"""
    where: config_bool_exp
  ): config_aggregate!

  """fetch data from the table: "config" using primary key columns"""
  config_by_pk(id: uuid!): config

  """
  execute function "current_user" which returns "user"
  """
  current_user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  execute function "current_user" and query aggregates on result of table type "user"
  """
  current_user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch data from the table: "dynamic_challenge"
  """
  dynamic_challenge(
    """distinct select on columns"""
    distinct_on: [dynamic_challenge_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_challenge_order_by!]

    """filter the rows returned"""
    where: dynamic_challenge_bool_exp
  ): [dynamic_challenge!]!

  """
  fetch aggregated fields from the table: "dynamic_challenge"
  """
  dynamic_challenge_aggregate(
    """distinct select on columns"""
    distinct_on: [dynamic_challenge_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_challenge_order_by!]

    """filter the rows returned"""
    where: dynamic_challenge_bool_exp
  ): dynamic_challenge_aggregate!

  """
  fetch data from the table: "dynamic_challenge" using primary key columns
  """
  dynamic_challenge_by_pk(id: uuid!): dynamic_challenge

  """
  fetch data from the table: "field"
  """
  field(
    """distinct select on columns"""
    distinct_on: [field_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_order_by!]

    """filter the rows returned"""
    where: field_bool_exp
  ): [field!]!

  """
  fetch aggregated fields from the table: "field"
  """
  field_aggregate(
    """distinct select on columns"""
    distinct_on: [field_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_order_by!]

    """filter the rows returned"""
    where: field_bool_exp
  ): field_aggregate!

  """fetch data from the table: "field" using primary key columns"""
  field_by_pk(id: uuid!): field

  """
  fetch data from the table: "field_entry"
  """
  field_entry(
    """distinct select on columns"""
    distinct_on: [field_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entry_order_by!]

    """filter the rows returned"""
    where: field_entry_bool_exp
  ): [field_entry!]!

  """
  fetch aggregated fields from the table: "field_entry"
  """
  field_entry_aggregate(
    """distinct select on columns"""
    distinct_on: [field_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entry_order_by!]

    """filter the rows returned"""
    where: field_entry_bool_exp
  ): field_entry_aggregate!

  """fetch data from the table: "field_entry" using primary key columns"""
  field_entry_by_pk(id: uuid!): field_entry

  """
  fetch data from the table: "file"
  """
  file(
    """distinct select on columns"""
    distinct_on: [file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [file_order_by!]

    """filter the rows returned"""
    where: file_bool_exp
  ): [file!]!

  """
  fetch aggregated fields from the table: "file"
  """
  file_aggregate(
    """distinct select on columns"""
    distinct_on: [file_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [file_order_by!]

    """filter the rows returned"""
    where: file_bool_exp
  ): file_aggregate!

  """fetch data from the table: "file" using primary key columns"""
  file_by_pk(id: uuid!): file

  """
  fetch data from the table: "flag"
  """
  flag(
    """distinct select on columns"""
    distinct_on: [flag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [flag_order_by!]

    """filter the rows returned"""
    where: flag_bool_exp
  ): [flag!]!

  """
  fetch aggregated fields from the table: "flag"
  """
  flag_aggregate(
    """distinct select on columns"""
    distinct_on: [flag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [flag_order_by!]

    """filter the rows returned"""
    where: flag_bool_exp
  ): flag_aggregate!

  """fetch data from the table: "flag" using primary key columns"""
  flag_by_pk(id: uuid!): flag

  """
  fetch data from the table: "hint"
  """
  hint(
    """distinct select on columns"""
    distinct_on: [hint_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hint_order_by!]

    """filter the rows returned"""
    where: hint_bool_exp
  ): [hint!]!

  """
  fetch aggregated fields from the table: "hint"
  """
  hint_aggregate(
    """distinct select on columns"""
    distinct_on: [hint_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hint_order_by!]

    """filter the rows returned"""
    where: hint_bool_exp
  ): hint_aggregate!

  """fetch data from the table: "hint" using primary key columns"""
  hint_by_pk(id: uuid!): hint

  """
  fetch data from the table: "hints_content"
  """
  hints_content(
    """distinct select on columns"""
    distinct_on: [hints_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_content_order_by!]

    """filter the rows returned"""
    where: hints_content_bool_exp
  ): [hints_content!]!

  """
  fetch aggregated fields from the table: "hints_content"
  """
  hints_content_aggregate(
    """distinct select on columns"""
    distinct_on: [hints_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_content_order_by!]

    """filter the rows returned"""
    where: hints_content_bool_exp
  ): hints_content_aggregate!

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch aggregated fields from the table: "notification"
  """
  notification_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!

  """fetch data from the table: "notification" using primary key columns"""
  notification_by_pk(id: uuid!): notification

  """
  fetch data from the table: "page"
  """
  page(
    """distinct select on columns"""
    distinct_on: [page_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_order_by!]

    """filter the rows returned"""
    where: page_bool_exp
  ): [page!]!

  """
  fetch aggregated fields from the table: "page"
  """
  page_aggregate(
    """distinct select on columns"""
    distinct_on: [page_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_order_by!]

    """filter the rows returned"""
    where: page_bool_exp
  ): page_aggregate!

  """fetch data from the table: "page" using primary key columns"""
  page_by_pk(id: uuid!): page

  """
  fetch data from the table: "score_event"
  """
  score_event(
    """distinct select on columns"""
    distinct_on: [score_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_event_order_by!]

    """filter the rows returned"""
    where: score_event_bool_exp
  ): [score_event!]!

  """
  fetch aggregated fields from the table: "score_event"
  """
  score_event_aggregate(
    """distinct select on columns"""
    distinct_on: [score_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_event_order_by!]

    """filter the rows returned"""
    where: score_event_bool_exp
  ): score_event_aggregate!

  """An array relationship"""
  score_timeline(
    """distinct select on columns"""
    distinct_on: [score_timeline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_order_by!]

    """filter the rows returned"""
    where: score_timeline_bool_exp
  ): [score_timeline!]!

  """An aggregate relationship"""
  score_timeline_aggregate(
    """distinct select on columns"""
    distinct_on: [score_timeline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_order_by!]

    """filter the rows returned"""
    where: score_timeline_bool_exp
  ): score_timeline_aggregate!

  """
  fetch data from the table: "score_timeline_user"
  """
  score_timeline_user(
    """distinct select on columns"""
    distinct_on: [score_timeline_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_user_order_by!]

    """filter the rows returned"""
    where: score_timeline_user_bool_exp
  ): [score_timeline_user!]!

  """
  fetch aggregated fields from the table: "score_timeline_user"
  """
  score_timeline_user_aggregate(
    """distinct select on columns"""
    distinct_on: [score_timeline_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_user_order_by!]

    """filter the rows returned"""
    where: score_timeline_user_bool_exp
  ): score_timeline_user_aggregate!

  """
  fetch data from the table: "scoreboard"
  """
  scoreboard(
    """distinct select on columns"""
    distinct_on: [scoreboard_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_order_by!]

    """filter the rows returned"""
    where: scoreboard_bool_exp
  ): [scoreboard!]!

  """
  fetch aggregated fields from the table: "scoreboard"
  """
  scoreboard_aggregate(
    """distinct select on columns"""
    distinct_on: [scoreboard_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_order_by!]

    """filter the rows returned"""
    where: scoreboard_bool_exp
  ): scoreboard_aggregate!

  """
  fetch data from the table: "scoreboard_user"
  """
  scoreboard_user(
    """distinct select on columns"""
    distinct_on: [scoreboard_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_user_order_by!]

    """filter the rows returned"""
    where: scoreboard_user_bool_exp
  ): [scoreboard_user!]!

  """
  fetch aggregated fields from the table: "scoreboard_user"
  """
  scoreboard_user_aggregate(
    """distinct select on columns"""
    distinct_on: [scoreboard_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_user_order_by!]

    """filter the rows returned"""
    where: scoreboard_user_bool_exp
  ): scoreboard_user_aggregate!

  """
  fetch data from the table: "solve"
  """
  solve(
    """distinct select on columns"""
    distinct_on: [solve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solve_order_by!]

    """filter the rows returned"""
    where: solve_bool_exp
  ): [solve!]!

  """
  fetch aggregated fields from the table: "solve"
  """
  solve_aggregate(
    """distinct select on columns"""
    distinct_on: [solve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solve_order_by!]

    """filter the rows returned"""
    where: solve_bool_exp
  ): solve_aggregate!

  """fetch data from the table: "solve" using primary key columns"""
  solve_by_pk(id: uuid!): solve

  """
  fetch data from the table: "submission"
  """
  submission(
    """distinct select on columns"""
    distinct_on: [submission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submission_order_by!]

    """filter the rows returned"""
    where: submission_bool_exp
  ): [submission!]!

  """
  fetch aggregated fields from the table: "submission"
  """
  submission_aggregate(
    """distinct select on columns"""
    distinct_on: [submission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submission_order_by!]

    """filter the rows returned"""
    where: submission_bool_exp
  ): submission_aggregate!

  """fetch data from the table: "submission" using primary key columns"""
  submission_by_pk(id: uuid!): submission

  """
  fetch data from the table: "tag"
  """
  tag(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """
  fetch aggregated fields from the table: "tag"
  """
  tag_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """fetch data from the table: "tag" using primary key columns"""
  tag_by_pk(id: uuid!): tag

  """
  fetch data from the table: "team"
  """
  team(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """
  fetch aggregated fields from the table: "team"
  """
  team_aggregate(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """fetch data from the table: "team" using primary key columns"""
  team_by_pk(id: uuid!): team

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  fetch aggregated fields from the table: "token"
  """
  token_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """fetch data from the table: "token" using primary key columns"""
  token_by_pk(id: uuid!): token

  """
  fetch data from the table: "tracking"
  """
  tracking(
    """distinct select on columns"""
    distinct_on: [tracking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tracking_order_by!]

    """filter the rows returned"""
    where: tracking_bool_exp
  ): [tracking!]!

  """
  fetch aggregated fields from the table: "tracking"
  """
  tracking_aggregate(
    """distinct select on columns"""
    distinct_on: [tracking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tracking_order_by!]

    """filter the rows returned"""
    where: tracking_bool_exp
  ): tracking_aggregate!

  """fetch data from the table: "tracking" using primary key columns"""
  tracking_by_pk(id: uuid!): tracking

  """
  fetch data from the table: "unlock"
  """
  unlock(
    """distinct select on columns"""
    distinct_on: [unlock_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlock_order_by!]

    """filter the rows returned"""
    where: unlock_bool_exp
  ): [unlock!]!

  """
  fetch aggregated fields from the table: "unlock"
  """
  unlock_aggregate(
    """distinct select on columns"""
    distinct_on: [unlock_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlock_order_by!]

    """filter the rows returned"""
    where: unlock_bool_exp
  ): unlock_aggregate!

  """fetch data from the table: "unlock" using primary key columns"""
  unlock_by_pk(id: uuid!): unlock

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: uuid!): user
}

"""
columns and relationships of "tag"
"""
type tag {
  """An array relationship"""
  challenge_tags(
    """distinct select on columns"""
    distinct_on: [challenge_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenge_tag_order_by!]

    """filter the rows returned"""
    where: challenge_tag_bool_exp
  ): [challenge_tag!]!

  """An aggregate relationship"""
  challenge_tags_aggregate(
    """distinct select on columns"""
    distinct_on: [challenge_tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenge_tag_order_by!]

    """filter the rows returned"""
    where: challenge_tag_bool_exp
  ): challenge_tag_aggregate!
  id: uuid!
  name: String
}

"""
aggregated selection of "tag"
"""
type tag_aggregate {
  aggregate: tag_aggregate_fields
  nodes: [tag!]!
}

"""
aggregate fields of "tag"
"""
type tag_aggregate_fields {
  count(columns: [tag_select_column!], distinct: Boolean): Int!
  max: tag_max_fields
  min: tag_min_fields
}

"""
Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'.
"""
input tag_bool_exp {
  _and: [tag_bool_exp!]
  _not: tag_bool_exp
  _or: [tag_bool_exp!]
  challenge_tags: challenge_tag_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "tag"
"""
enum tag_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  tag_name_key

  """
  unique or primary key constraint on columns "id"
  """
  tag_pkey
}

"""
input type for inserting data into table "tag"
"""
input tag_insert_input {
  challenge_tags: challenge_tag_arr_rel_insert_input
  id: uuid
  name: String
}

"""aggregate max on columns"""
type tag_max_fields {
  id: uuid
  name: String
}

"""aggregate min on columns"""
type tag_min_fields {
  id: uuid
  name: String
}

"""
response of any mutation on the table "tag"
"""
type tag_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tag!]!
}

"""
input type for inserting object relation for remote table "tag"
"""
input tag_obj_rel_insert_input {
  data: tag_insert_input!

  """upsert condition"""
  on_conflict: tag_on_conflict
}

"""
on_conflict condition type for table "tag"
"""
input tag_on_conflict {
  constraint: tag_constraint!
  update_columns: [tag_update_column!]! = []
  where: tag_bool_exp
}

"""Ordering options when selecting data from "tag"."""
input tag_order_by {
  challenge_tags_aggregate: challenge_tag_aggregate_order_by
  id: order_by
  name: order_by
}

"""primary key columns input for table: tag"""
input tag_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tag"
"""
enum tag_select_column {
  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "tag"
"""
input tag_set_input {
  id: uuid
  name: String
}

"""
update columns of table "tag"
"""
enum tag_update_column {
  """column name"""
  id

  """column name"""
  name
}

"""
columns and relationships of "team"
"""
type team {
  affiliation: String

  """An array relationship"""
  awards(
    """distinct select on columns"""
    distinct_on: [award_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [award_order_by!]

    """filter the rows returned"""
    where: award_bool_exp
  ): [award!]!

  """An aggregate relationship"""
  awards_aggregate(
    """distinct select on columns"""
    distinct_on: [award_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [award_order_by!]

    """filter the rows returned"""
    where: award_bool_exp
  ): award_aggregate!
  banned: Boolean
  bracket: String

  """An object relationship"""
  captain: user
  captain_id: uuid

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): [comment!]!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): comment_aggregate!
  country: String
  created: timestamp
  email: String

  """An array relationship"""
  field_entries(
    """distinct select on columns"""
    distinct_on: [field_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entry_order_by!]

    """filter the rows returned"""
    where: field_entry_bool_exp
  ): [field_entry!]!

  """An aggregate relationship"""
  field_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [field_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entry_order_by!]

    """filter the rows returned"""
    where: field_entry_bool_exp
  ): field_entry_aggregate!
  hidden: Boolean
  id: uuid!

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!
  name: String
  password: String

  """
  A computed field, executes function "team_score"
  """
  score: Int

  """An array relationship"""
  score_timeline(
    """distinct select on columns"""
    distinct_on: [score_timeline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_order_by!]

    """filter the rows returned"""
    where: score_timeline_bool_exp
  ): [score_timeline!]!

  """An aggregate relationship"""
  score_timeline_aggregate(
    """distinct select on columns"""
    distinct_on: [score_timeline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_order_by!]

    """filter the rows returned"""
    where: score_timeline_bool_exp
  ): score_timeline_aggregate!

  """An object relationship"""
  scoreboard: scoreboard
  secret: String

  """An array relationship"""
  solves(
    """distinct select on columns"""
    distinct_on: [solve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solve_order_by!]

    """filter the rows returned"""
    where: solve_bool_exp
  ): [solve!]!

  """An aggregate relationship"""
  solves_aggregate(
    """distinct select on columns"""
    distinct_on: [solve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solve_order_by!]

    """filter the rows returned"""
    where: solve_bool_exp
  ): solve_aggregate!

  """An array relationship"""
  submissions(
    """distinct select on columns"""
    distinct_on: [submission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submission_order_by!]

    """filter the rows returned"""
    where: submission_bool_exp
  ): [submission!]!

  """An aggregate relationship"""
  submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [submission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submission_order_by!]

    """filter the rows returned"""
    where: submission_bool_exp
  ): submission_aggregate!

  """An array relationship"""
  unlocks(
    """distinct select on columns"""
    distinct_on: [unlock_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlock_order_by!]

    """filter the rows returned"""
    where: unlock_bool_exp
  ): [unlock!]!

  """An aggregate relationship"""
  unlocks_aggregate(
    """distinct select on columns"""
    distinct_on: [unlock_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlock_order_by!]

    """filter the rows returned"""
    where: unlock_bool_exp
  ): unlock_aggregate!
  website: String
}

"""
aggregated selection of "team"
"""
type team_aggregate {
  aggregate: team_aggregate_fields
  nodes: [team!]!
}

"""
aggregate fields of "team"
"""
type team_aggregate_fields {
  count(columns: [team_select_column!], distinct: Boolean): Int!
  max: team_max_fields
  min: team_min_fields
}

"""
Boolean expression to filter rows from the table "team". All fields are combined with a logical 'AND'.
"""
input team_bool_exp {
  _and: [team_bool_exp!]
  _not: team_bool_exp
  _or: [team_bool_exp!]
  affiliation: String_comparison_exp
  awards: award_bool_exp
  banned: Boolean_comparison_exp
  bracket: String_comparison_exp
  captain: user_bool_exp
  captain_id: uuid_comparison_exp
  comments: comment_bool_exp
  country: String_comparison_exp
  created: timestamp_comparison_exp
  email: String_comparison_exp
  field_entries: field_entry_bool_exp
  hidden: Boolean_comparison_exp
  id: uuid_comparison_exp
  members: user_bool_exp
  name: String_comparison_exp
  password: String_comparison_exp
  score: Int_comparison_exp
  score_timeline: score_timeline_bool_exp
  scoreboard: scoreboard_bool_exp
  secret: String_comparison_exp
  solves: solve_bool_exp
  submissions: submission_bool_exp
  unlocks: unlock_bool_exp
  website: String_comparison_exp
}

"""
unique or primary key constraints on table "team"
"""
enum team_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  team_pkey
}

"""
input type for inserting data into table "team"
"""
input team_insert_input {
  affiliation: String
  awards: award_arr_rel_insert_input
  banned: Boolean
  bracket: String
  captain: user_obj_rel_insert_input
  captain_id: uuid
  comments: comment_arr_rel_insert_input
  country: String
  created: timestamp
  email: String
  field_entries: field_entry_arr_rel_insert_input
  hidden: Boolean
  id: uuid
  members: user_arr_rel_insert_input
  name: String
  password: String
  score_timeline: score_timeline_arr_rel_insert_input
  scoreboard: scoreboard_obj_rel_insert_input
  secret: String
  solves: solve_arr_rel_insert_input
  submissions: submission_arr_rel_insert_input
  unlocks: unlock_arr_rel_insert_input
  website: String
}

"""aggregate max on columns"""
type team_max_fields {
  affiliation: String
  bracket: String
  captain_id: uuid
  country: String
  created: timestamp
  email: String
  id: uuid
  name: String
  password: String
  secret: String
  website: String
}

"""aggregate min on columns"""
type team_min_fields {
  affiliation: String
  bracket: String
  captain_id: uuid
  country: String
  created: timestamp
  email: String
  id: uuid
  name: String
  password: String
  secret: String
  website: String
}

"""
response of any mutation on the table "team"
"""
type team_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [team!]!
}

"""
input type for inserting object relation for remote table "team"
"""
input team_obj_rel_insert_input {
  data: team_insert_input!

  """upsert condition"""
  on_conflict: team_on_conflict
}

"""
on_conflict condition type for table "team"
"""
input team_on_conflict {
  constraint: team_constraint!
  update_columns: [team_update_column!]! = []
  where: team_bool_exp
}

"""Ordering options when selecting data from "team"."""
input team_order_by {
  affiliation: order_by
  awards_aggregate: award_aggregate_order_by
  banned: order_by
  bracket: order_by
  captain: user_order_by
  captain_id: order_by
  comments_aggregate: comment_aggregate_order_by
  country: order_by
  created: order_by
  email: order_by
  field_entries_aggregate: field_entry_aggregate_order_by
  hidden: order_by
  id: order_by
  members_aggregate: user_aggregate_order_by
  name: order_by
  password: order_by
  score: order_by
  score_timeline_aggregate: score_timeline_aggregate_order_by
  scoreboard: scoreboard_order_by
  secret: order_by
  solves_aggregate: solve_aggregate_order_by
  submissions_aggregate: submission_aggregate_order_by
  unlocks_aggregate: unlock_aggregate_order_by
  website: order_by
}

"""primary key columns input for table: team"""
input team_pk_columns_input {
  id: uuid!
}

"""
select columns of table "team"
"""
enum team_select_column {
  """column name"""
  affiliation

  """column name"""
  banned

  """column name"""
  bracket

  """column name"""
  captain_id

  """column name"""
  country

  """column name"""
  created

  """column name"""
  email

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  name

  """column name"""
  password

  """column name"""
  secret

  """column name"""
  website
}

"""
input type for updating data in table "team"
"""
input team_set_input {
  affiliation: String
  banned: Boolean
  bracket: String
  captain_id: uuid
  country: String
  created: timestamp
  email: String
  hidden: Boolean
  id: uuid
  name: String
  password: String
  secret: String
  website: String
}

"""
update columns of table "team"
"""
enum team_update_column {
  """column name"""
  affiliation

  """column name"""
  banned

  """column name"""
  bracket

  """column name"""
  captain_id

  """column name"""
  country

  """column name"""
  created

  """column name"""
  email

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  name

  """column name"""
  password

  """column name"""
  secret

  """column name"""
  website
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"""
columns and relationships of "token"
"""
type token {
  created: timestamp
  expiration: timestamp
  id: uuid!
  type: String

  """An object relationship"""
  user: user
  user_id: uuid
  value: uuid
}

"""
aggregated selection of "token"
"""
type token_aggregate {
  aggregate: token_aggregate_fields
  nodes: [token!]!
}

"""
aggregate fields of "token"
"""
type token_aggregate_fields {
  count(columns: [token_select_column!], distinct: Boolean): Int!
  max: token_max_fields
  min: token_min_fields
}

"""
order by aggregate values of table "token"
"""
input token_aggregate_order_by {
  count: order_by
  max: token_max_order_by
  min: token_min_order_by
}

"""
input type for inserting array relation for remote table "token"
"""
input token_arr_rel_insert_input {
  data: [token_insert_input!]!

  """upsert condition"""
  on_conflict: token_on_conflict
}

"""
Boolean expression to filter rows from the table "token". All fields are combined with a logical 'AND'.
"""
input token_bool_exp {
  _and: [token_bool_exp!]
  _not: token_bool_exp
  _or: [token_bool_exp!]
  created: timestamp_comparison_exp
  expiration: timestamp_comparison_exp
  id: uuid_comparison_exp
  type: String_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
  value: uuid_comparison_exp
}

"""
unique or primary key constraints on table "token"
"""
enum token_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  token_pkey

  """
  unique or primary key constraint on columns "value"
  """
  token_value_key
}

"""
input type for inserting data into table "token"
"""
input token_insert_input {
  created: timestamp
  expiration: timestamp
  id: uuid
  type: String
  user: user_obj_rel_insert_input
  user_id: uuid
  value: uuid
}

"""aggregate max on columns"""
type token_max_fields {
  created: timestamp
  expiration: timestamp
  id: uuid
  type: String
  user_id: uuid
  value: uuid
}

"""
order by max() on columns of table "token"
"""
input token_max_order_by {
  created: order_by
  expiration: order_by
  id: order_by
  type: order_by
  user_id: order_by
  value: order_by
}

"""aggregate min on columns"""
type token_min_fields {
  created: timestamp
  expiration: timestamp
  id: uuid
  type: String
  user_id: uuid
  value: uuid
}

"""
order by min() on columns of table "token"
"""
input token_min_order_by {
  created: order_by
  expiration: order_by
  id: order_by
  type: order_by
  user_id: order_by
  value: order_by
}

"""
response of any mutation on the table "token"
"""
type token_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [token!]!
}

"""
on_conflict condition type for table "token"
"""
input token_on_conflict {
  constraint: token_constraint!
  update_columns: [token_update_column!]! = []
  where: token_bool_exp
}

"""Ordering options when selecting data from "token"."""
input token_order_by {
  created: order_by
  expiration: order_by
  id: order_by
  type: order_by
  user: user_order_by
  user_id: order_by
  value: order_by
}

"""primary key columns input for table: token"""
input token_pk_columns_input {
  id: uuid!
}

"""
select columns of table "token"
"""
enum token_select_column {
  """column name"""
  created

  """column name"""
  expiration

  """column name"""
  id

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value
}

"""
input type for updating data in table "token"
"""
input token_set_input {
  created: timestamp
  expiration: timestamp
  id: uuid
  type: String
  user_id: uuid
  value: uuid
}

"""
update columns of table "token"
"""
enum token_update_column {
  """column name"""
  created

  """column name"""
  expiration

  """column name"""
  id

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value
}

"""
columns and relationships of "tracking"
"""
type tracking {
  date: timestamp
  id: uuid!
  ip: String
  type: String

  """An object relationship"""
  user: user
  user_id: uuid
}

"""
aggregated selection of "tracking"
"""
type tracking_aggregate {
  aggregate: tracking_aggregate_fields
  nodes: [tracking!]!
}

"""
aggregate fields of "tracking"
"""
type tracking_aggregate_fields {
  count(columns: [tracking_select_column!], distinct: Boolean): Int!
  max: tracking_max_fields
  min: tracking_min_fields
}

"""
order by aggregate values of table "tracking"
"""
input tracking_aggregate_order_by {
  count: order_by
  max: tracking_max_order_by
  min: tracking_min_order_by
}

"""
input type for inserting array relation for remote table "tracking"
"""
input tracking_arr_rel_insert_input {
  data: [tracking_insert_input!]!

  """upsert condition"""
  on_conflict: tracking_on_conflict
}

"""
Boolean expression to filter rows from the table "tracking". All fields are combined with a logical 'AND'.
"""
input tracking_bool_exp {
  _and: [tracking_bool_exp!]
  _not: tracking_bool_exp
  _or: [tracking_bool_exp!]
  date: timestamp_comparison_exp
  id: uuid_comparison_exp
  ip: String_comparison_exp
  type: String_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "tracking"
"""
enum tracking_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tracking_pkey
}

"""
input type for inserting data into table "tracking"
"""
input tracking_insert_input {
  date: timestamp
  id: uuid
  ip: String
  type: String
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type tracking_max_fields {
  date: timestamp
  id: uuid
  ip: String
  type: String
  user_id: uuid
}

"""
order by max() on columns of table "tracking"
"""
input tracking_max_order_by {
  date: order_by
  id: order_by
  ip: order_by
  type: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type tracking_min_fields {
  date: timestamp
  id: uuid
  ip: String
  type: String
  user_id: uuid
}

"""
order by min() on columns of table "tracking"
"""
input tracking_min_order_by {
  date: order_by
  id: order_by
  ip: order_by
  type: order_by
  user_id: order_by
}

"""
response of any mutation on the table "tracking"
"""
type tracking_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tracking!]!
}

"""
on_conflict condition type for table "tracking"
"""
input tracking_on_conflict {
  constraint: tracking_constraint!
  update_columns: [tracking_update_column!]! = []
  where: tracking_bool_exp
}

"""Ordering options when selecting data from "tracking"."""
input tracking_order_by {
  date: order_by
  id: order_by
  ip: order_by
  type: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: tracking"""
input tracking_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tracking"
"""
enum tracking_select_column {
  """column name"""
  date

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  type

  """column name"""
  user_id
}

"""
input type for updating data in table "tracking"
"""
input tracking_set_input {
  date: timestamp
  id: uuid
  ip: String
  type: String
  user_id: uuid
}

"""
update columns of table "tracking"
"""
enum tracking_update_column {
  """column name"""
  date

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  type

  """column name"""
  user_id
}

"""
columns and relationships of "unlock"
"""
type unlock {
  date: timestamp
  id: uuid!
  target: Int

  """An object relationship"""
  target_hint: hint

  """An object relationship"""
  team: team
  team_id: uuid
  type: String

  """An object relationship"""
  user: user
  user_id: uuid
}

"""
aggregated selection of "unlock"
"""
type unlock_aggregate {
  aggregate: unlock_aggregate_fields
  nodes: [unlock!]!
}

"""
aggregate fields of "unlock"
"""
type unlock_aggregate_fields {
  avg: unlock_avg_fields
  count(columns: [unlock_select_column!], distinct: Boolean): Int!
  max: unlock_max_fields
  min: unlock_min_fields
  stddev: unlock_stddev_fields
  stddev_pop: unlock_stddev_pop_fields
  stddev_samp: unlock_stddev_samp_fields
  sum: unlock_sum_fields
  var_pop: unlock_var_pop_fields
  var_samp: unlock_var_samp_fields
  variance: unlock_variance_fields
}

"""
order by aggregate values of table "unlock"
"""
input unlock_aggregate_order_by {
  avg: unlock_avg_order_by
  count: order_by
  max: unlock_max_order_by
  min: unlock_min_order_by
  stddev: unlock_stddev_order_by
  stddev_pop: unlock_stddev_pop_order_by
  stddev_samp: unlock_stddev_samp_order_by
  sum: unlock_sum_order_by
  var_pop: unlock_var_pop_order_by
  var_samp: unlock_var_samp_order_by
  variance: unlock_variance_order_by
}

"""
input type for inserting array relation for remote table "unlock"
"""
input unlock_arr_rel_insert_input {
  data: [unlock_insert_input!]!

  """upsert condition"""
  on_conflict: unlock_on_conflict
}

"""aggregate avg on columns"""
type unlock_avg_fields {
  target: Float
}

"""
order by avg() on columns of table "unlock"
"""
input unlock_avg_order_by {
  target: order_by
}

"""
Boolean expression to filter rows from the table "unlock". All fields are combined with a logical 'AND'.
"""
input unlock_bool_exp {
  _and: [unlock_bool_exp!]
  _not: unlock_bool_exp
  _or: [unlock_bool_exp!]
  date: timestamp_comparison_exp
  id: uuid_comparison_exp
  target: Int_comparison_exp
  target_hint: hint_bool_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
  type: String_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "unlock"
"""
enum unlock_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  unlock_pkey
}

"""
input type for incrementing numeric columns in table "unlock"
"""
input unlock_inc_input {
  target: Int
}

"""
input type for inserting data into table "unlock"
"""
input unlock_insert_input {
  date: timestamp
  id: uuid
  target: Int
  target_hint: hint_obj_rel_insert_input
  team: team_obj_rel_insert_input
  team_id: uuid
  type: String
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type unlock_max_fields {
  date: timestamp
  id: uuid
  target: Int
  team_id: uuid
  type: String
  user_id: uuid
}

"""
order by max() on columns of table "unlock"
"""
input unlock_max_order_by {
  date: order_by
  id: order_by
  target: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type unlock_min_fields {
  date: timestamp
  id: uuid
  target: Int
  team_id: uuid
  type: String
  user_id: uuid
}

"""
order by min() on columns of table "unlock"
"""
input unlock_min_order_by {
  date: order_by
  id: order_by
  target: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""
response of any mutation on the table "unlock"
"""
type unlock_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [unlock!]!
}

"""
on_conflict condition type for table "unlock"
"""
input unlock_on_conflict {
  constraint: unlock_constraint!
  update_columns: [unlock_update_column!]! = []
  where: unlock_bool_exp
}

"""Ordering options when selecting data from "unlock"."""
input unlock_order_by {
  date: order_by
  id: order_by
  target: order_by
  target_hint: hint_order_by
  team: team_order_by
  team_id: order_by
  type: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: unlock"""
input unlock_pk_columns_input {
  id: uuid!
}

"""
select columns of table "unlock"
"""
enum unlock_select_column {
  """column name"""
  date

  """column name"""
  id

  """column name"""
  target

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id
}

"""
input type for updating data in table "unlock"
"""
input unlock_set_input {
  date: timestamp
  id: uuid
  target: Int
  team_id: uuid
  type: String
  user_id: uuid
}

"""aggregate stddev on columns"""
type unlock_stddev_fields {
  target: Float
}

"""
order by stddev() on columns of table "unlock"
"""
input unlock_stddev_order_by {
  target: order_by
}

"""aggregate stddev_pop on columns"""
type unlock_stddev_pop_fields {
  target: Float
}

"""
order by stddev_pop() on columns of table "unlock"
"""
input unlock_stddev_pop_order_by {
  target: order_by
}

"""aggregate stddev_samp on columns"""
type unlock_stddev_samp_fields {
  target: Float
}

"""
order by stddev_samp() on columns of table "unlock"
"""
input unlock_stddev_samp_order_by {
  target: order_by
}

"""aggregate sum on columns"""
type unlock_sum_fields {
  target: Int
}

"""
order by sum() on columns of table "unlock"
"""
input unlock_sum_order_by {
  target: order_by
}

"""
update columns of table "unlock"
"""
enum unlock_update_column {
  """column name"""
  date

  """column name"""
  id

  """column name"""
  target

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type unlock_var_pop_fields {
  target: Float
}

"""
order by var_pop() on columns of table "unlock"
"""
input unlock_var_pop_order_by {
  target: order_by
}

"""aggregate var_samp on columns"""
type unlock_var_samp_fields {
  target: Float
}

"""
order by var_samp() on columns of table "unlock"
"""
input unlock_var_samp_order_by {
  target: order_by
}

"""aggregate variance on columns"""
type unlock_variance_fields {
  target: Float
}

"""
order by variance() on columns of table "unlock"
"""
input unlock_variance_order_by {
  target: order_by
}

"""
columns and relationships of "user"
"""
type user {
  affiliation: String

  """
  A computed field, executes function "user_avatar"
  """
  avatar: String

  """An array relationship"""
  awards(
    """distinct select on columns"""
    distinct_on: [award_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [award_order_by!]

    """filter the rows returned"""
    where: award_bool_exp
  ): [award!]!

  """An aggregate relationship"""
  awards_aggregate(
    """distinct select on columns"""
    distinct_on: [award_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [award_order_by!]

    """filter the rows returned"""
    where: award_bool_exp
  ): award_aggregate!
  banned: Boolean
  bracket: String

  """An object relationship"""
  captain_of: team

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): [comment!]!

  """An array relationship"""
  commentsByUserId(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): [comment!]!

  """An aggregate relationship"""
  commentsByUserId_aggregate(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): comment_aggregate!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comment_order_by!]

    """filter the rows returned"""
    where: comment_bool_exp
  ): comment_aggregate!
  country: String
  created: timestamp
  email: String

  """An array relationship"""
  field_entries(
    """distinct select on columns"""
    distinct_on: [field_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entry_order_by!]

    """filter the rows returned"""
    where: field_entry_bool_exp
  ): [field_entry!]!

  """An aggregate relationship"""
  field_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [field_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entry_order_by!]

    """filter the rows returned"""
    where: field_entry_bool_exp
  ): field_entry_aggregate!
  hidden: Boolean
  id: uuid!
  kratos_id: uuid!
  name: String
  password: String

  """
  A computed field, executes function "user_score"
  """
  score: Int

  """An array relationship"""
  score_timeline(
    """distinct select on columns"""
    distinct_on: [score_timeline_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_user_order_by!]

    """filter the rows returned"""
    where: score_timeline_user_bool_exp
  ): [score_timeline_user!]!

  """An aggregate relationship"""
  score_timeline_aggregate(
    """distinct select on columns"""
    distinct_on: [score_timeline_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_user_order_by!]

    """filter the rows returned"""
    where: score_timeline_user_bool_exp
  ): score_timeline_user_aggregate!
  secret: String

  """An array relationship"""
  solves(
    """distinct select on columns"""
    distinct_on: [solve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solve_order_by!]

    """filter the rows returned"""
    where: solve_bool_exp
  ): [solve!]!

  """An aggregate relationship"""
  solves_aggregate(
    """distinct select on columns"""
    distinct_on: [solve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solve_order_by!]

    """filter the rows returned"""
    where: solve_bool_exp
  ): solve_aggregate!

  """An array relationship"""
  submissions(
    """distinct select on columns"""
    distinct_on: [submission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submission_order_by!]

    """filter the rows returned"""
    where: submission_bool_exp
  ): [submission!]!

  """An aggregate relationship"""
  submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [submission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submission_order_by!]

    """filter the rows returned"""
    where: submission_bool_exp
  ): submission_aggregate!

  """An object relationship"""
  team: team
  team_id: uuid

  """An array relationship"""
  tokens(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """An aggregate relationship"""
  tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """An array relationship"""
  trackings(
    """distinct select on columns"""
    distinct_on: [tracking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tracking_order_by!]

    """filter the rows returned"""
    where: tracking_bool_exp
  ): [tracking!]!

  """An aggregate relationship"""
  trackings_aggregate(
    """distinct select on columns"""
    distinct_on: [tracking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tracking_order_by!]

    """filter the rows returned"""
    where: tracking_bool_exp
  ): tracking_aggregate!
  type: String

  """An array relationship"""
  unlocks(
    """distinct select on columns"""
    distinct_on: [unlock_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlock_order_by!]

    """filter the rows returned"""
    where: unlock_bool_exp
  ): [unlock!]!

  """An aggregate relationship"""
  unlocks_aggregate(
    """distinct select on columns"""
    distinct_on: [unlock_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlock_order_by!]

    """filter the rows returned"""
    where: unlock_bool_exp
  ): unlock_aggregate!
  verified: Boolean
  website: String
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
}

"""
order by aggregate values of table "user"
"""
input user_aggregate_order_by {
  count: order_by
  max: user_max_order_by
  min: user_min_order_by
}

"""
input type for inserting array relation for remote table "user"
"""
input user_arr_rel_insert_input {
  data: [user_insert_input!]!

  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  affiliation: String_comparison_exp
  avatar: String_comparison_exp
  awards: award_bool_exp
  banned: Boolean_comparison_exp
  bracket: String_comparison_exp
  captain_of: team_bool_exp
  comments: comment_bool_exp
  commentsByUserId: comment_bool_exp
  country: String_comparison_exp
  created: timestamp_comparison_exp
  email: String_comparison_exp
  field_entries: field_entry_bool_exp
  hidden: Boolean_comparison_exp
  id: uuid_comparison_exp
  kratos_id: uuid_comparison_exp
  name: String_comparison_exp
  password: String_comparison_exp
  score: Int_comparison_exp
  score_timeline: score_timeline_user_bool_exp
  secret: String_comparison_exp
  solves: solve_bool_exp
  submissions: submission_bool_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
  tokens: token_bool_exp
  trackings: tracking_bool_exp
  type: String_comparison_exp
  unlocks: unlock_bool_exp
  verified: Boolean_comparison_exp
  website: String_comparison_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint on columns "kratos_id"
  """
  user_kratos_id_key

  """
  unique or primary key constraint on columns "id"
  """
  user_pkey
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  affiliation: String
  awards: award_arr_rel_insert_input
  banned: Boolean
  bracket: String
  captain_of: team_obj_rel_insert_input
  comments: comment_arr_rel_insert_input
  commentsByUserId: comment_arr_rel_insert_input
  country: String
  created: timestamp
  email: String
  field_entries: field_entry_arr_rel_insert_input
  hidden: Boolean
  id: uuid
  kratos_id: uuid
  name: String
  password: String
  score_timeline: score_timeline_user_arr_rel_insert_input
  secret: String
  solves: solve_arr_rel_insert_input
  submissions: submission_arr_rel_insert_input
  team: team_obj_rel_insert_input
  team_id: uuid
  tokens: token_arr_rel_insert_input
  trackings: tracking_arr_rel_insert_input
  type: String
  unlocks: unlock_arr_rel_insert_input
  verified: Boolean
  website: String
}

"""aggregate max on columns"""
type user_max_fields {
  affiliation: String
  bracket: String
  country: String
  created: timestamp
  email: String
  id: uuid
  kratos_id: uuid
  name: String
  password: String
  secret: String
  team_id: uuid
  type: String
  website: String
}

"""
order by max() on columns of table "user"
"""
input user_max_order_by {
  affiliation: order_by
  bracket: order_by
  country: order_by
  created: order_by
  email: order_by
  id: order_by
  kratos_id: order_by
  name: order_by
  password: order_by
  secret: order_by
  team_id: order_by
  type: order_by
  website: order_by
}

"""aggregate min on columns"""
type user_min_fields {
  affiliation: String
  bracket: String
  country: String
  created: timestamp
  email: String
  id: uuid
  kratos_id: uuid
  name: String
  password: String
  secret: String
  team_id: uuid
  type: String
  website: String
}

"""
order by min() on columns of table "user"
"""
input user_min_order_by {
  affiliation: order_by
  bracket: order_by
  country: order_by
  created: order_by
  email: order_by
  id: order_by
  kratos_id: order_by
  name: order_by
  password: order_by
  secret: order_by
  team_id: order_by
  type: order_by
  website: order_by
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!

  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
on_conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]! = []
  where: user_bool_exp
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  affiliation: order_by
  avatar: order_by
  awards_aggregate: award_aggregate_order_by
  banned: order_by
  bracket: order_by
  captain_of: team_order_by
  commentsByUserId_aggregate: comment_aggregate_order_by
  comments_aggregate: comment_aggregate_order_by
  country: order_by
  created: order_by
  email: order_by
  field_entries_aggregate: field_entry_aggregate_order_by
  hidden: order_by
  id: order_by
  kratos_id: order_by
  name: order_by
  password: order_by
  score: order_by
  score_timeline_aggregate: score_timeline_user_aggregate_order_by
  secret: order_by
  solves_aggregate: solve_aggregate_order_by
  submissions_aggregate: submission_aggregate_order_by
  team: team_order_by
  team_id: order_by
  tokens_aggregate: token_aggregate_order_by
  trackings_aggregate: tracking_aggregate_order_by
  type: order_by
  unlocks_aggregate: unlock_aggregate_order_by
  verified: order_by
  website: order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  affiliation

  """column name"""
  banned

  """column name"""
  bracket

  """column name"""
  country

  """column name"""
  created

  """column name"""
  email

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  kratos_id

  """column name"""
  name

  """column name"""
  password

  """column name"""
  secret

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  verified

  """column name"""
  website
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  affiliation: String
  banned: Boolean
  bracket: String
  country: String
  created: timestamp
  email: String
  hidden: Boolean
  id: uuid
  kratos_id: uuid
  name: String
  password: String
  secret: String
  team_id: uuid
  type: String
  verified: Boolean
  website: String
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  affiliation

  """column name"""
  banned

  """column name"""
  bracket

  """column name"""
  country

  """column name"""
  created

  """column name"""
  email

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  kratos_id

  """column name"""
  name

  """column name"""
  password

  """column name"""
  secret

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  verified

  """column name"""
  website
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
