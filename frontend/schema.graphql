schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "awards"
"""
type awards {
  category: String
  date: timestamp
  description: String
  icon: String
  id: Int!
  name: String
  requirements(
    """JSON select path"""
    path: String
  ): json

  """An object relationship"""
  team: teams
  team_id: Int
  type: String

  """An object relationship"""
  user: users
  user_id: Int
  value: Int
}

"""
aggregated selection of "awards"
"""
type awards_aggregate {
  aggregate: awards_aggregate_fields
  nodes: [awards!]!
}

"""
aggregate fields of "awards"
"""
type awards_aggregate_fields {
  avg: awards_avg_fields
  count(columns: [awards_select_column!], distinct: Boolean): Int!
  max: awards_max_fields
  min: awards_min_fields
  stddev: awards_stddev_fields
  stddev_pop: awards_stddev_pop_fields
  stddev_samp: awards_stddev_samp_fields
  sum: awards_sum_fields
  var_pop: awards_var_pop_fields
  var_samp: awards_var_samp_fields
  variance: awards_variance_fields
}

"""
order by aggregate values of table "awards"
"""
input awards_aggregate_order_by {
  avg: awards_avg_order_by
  count: order_by
  max: awards_max_order_by
  min: awards_min_order_by
  stddev: awards_stddev_order_by
  stddev_pop: awards_stddev_pop_order_by
  stddev_samp: awards_stddev_samp_order_by
  sum: awards_sum_order_by
  var_pop: awards_var_pop_order_by
  var_samp: awards_var_samp_order_by
  variance: awards_variance_order_by
}

"""
input type for inserting array relation for remote table "awards"
"""
input awards_arr_rel_insert_input {
  data: [awards_insert_input!]!

  """upsert condition"""
  on_conflict: awards_on_conflict
}

"""aggregate avg on columns"""
type awards_avg_fields {
  id: Float
  team_id: Float
  user_id: Float
  value: Float
}

"""
order by avg() on columns of table "awards"
"""
input awards_avg_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
  value: order_by
}

"""
Boolean expression to filter rows from the table "awards". All fields are combined with a logical 'AND'.
"""
input awards_bool_exp {
  _and: [awards_bool_exp!]
  _not: awards_bool_exp
  _or: [awards_bool_exp!]
  category: String_comparison_exp
  date: timestamp_comparison_exp
  description: String_comparison_exp
  icon: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  requirements: json_comparison_exp
  team: teams_bool_exp
  team_id: Int_comparison_exp
  type: String_comparison_exp
  user: users_bool_exp
  user_id: Int_comparison_exp
  value: Int_comparison_exp
}

"""
unique or primary key constraints on table "awards"
"""
enum awards_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  awards_pkey
}

"""
input type for incrementing numeric columns in table "awards"
"""
input awards_inc_input {
  id: Int
  team_id: Int
  user_id: Int
  value: Int
}

"""
input type for inserting data into table "awards"
"""
input awards_insert_input {
  category: String
  date: timestamp
  description: String
  icon: String
  id: Int
  name: String
  requirements: json
  team: teams_obj_rel_insert_input
  team_id: Int
  type: String
  user: users_obj_rel_insert_input
  user_id: Int
  value: Int
}

"""aggregate max on columns"""
type awards_max_fields {
  category: String
  date: timestamp
  description: String
  icon: String
  id: Int
  name: String
  team_id: Int
  type: String
  user_id: Int
  value: Int
}

"""
order by max() on columns of table "awards"
"""
input awards_max_order_by {
  category: order_by
  date: order_by
  description: order_by
  icon: order_by
  id: order_by
  name: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
  value: order_by
}

"""aggregate min on columns"""
type awards_min_fields {
  category: String
  date: timestamp
  description: String
  icon: String
  id: Int
  name: String
  team_id: Int
  type: String
  user_id: Int
  value: Int
}

"""
order by min() on columns of table "awards"
"""
input awards_min_order_by {
  category: order_by
  date: order_by
  description: order_by
  icon: order_by
  id: order_by
  name: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
  value: order_by
}

"""
response of any mutation on the table "awards"
"""
type awards_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [awards!]!
}

"""
on_conflict condition type for table "awards"
"""
input awards_on_conflict {
  constraint: awards_constraint!
  update_columns: [awards_update_column!]! = []
  where: awards_bool_exp
}

"""Ordering options when selecting data from "awards"."""
input awards_order_by {
  category: order_by
  date: order_by
  description: order_by
  icon: order_by
  id: order_by
  name: order_by
  requirements: order_by
  team: teams_order_by
  team_id: order_by
  type: order_by
  user: users_order_by
  user_id: order_by
  value: order_by
}

"""primary key columns input for table: awards"""
input awards_pk_columns_input {
  id: Int!
}

"""
select columns of table "awards"
"""
enum awards_select_column {
  """column name"""
  category

  """column name"""
  date

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  requirements

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value
}

"""
input type for updating data in table "awards"
"""
input awards_set_input {
  category: String
  date: timestamp
  description: String
  icon: String
  id: Int
  name: String
  requirements: json
  team_id: Int
  type: String
  user_id: Int
  value: Int
}

"""aggregate stddev on columns"""
type awards_stddev_fields {
  id: Float
  team_id: Float
  user_id: Float
  value: Float
}

"""
order by stddev() on columns of table "awards"
"""
input awards_stddev_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
  value: order_by
}

"""aggregate stddev_pop on columns"""
type awards_stddev_pop_fields {
  id: Float
  team_id: Float
  user_id: Float
  value: Float
}

"""
order by stddev_pop() on columns of table "awards"
"""
input awards_stddev_pop_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
  value: order_by
}

"""aggregate stddev_samp on columns"""
type awards_stddev_samp_fields {
  id: Float
  team_id: Float
  user_id: Float
  value: Float
}

"""
order by stddev_samp() on columns of table "awards"
"""
input awards_stddev_samp_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
  value: order_by
}

"""aggregate sum on columns"""
type awards_sum_fields {
  id: Int
  team_id: Int
  user_id: Int
  value: Int
}

"""
order by sum() on columns of table "awards"
"""
input awards_sum_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
  value: order_by
}

"""
update columns of table "awards"
"""
enum awards_update_column {
  """column name"""
  category

  """column name"""
  date

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  requirements

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type awards_var_pop_fields {
  id: Float
  team_id: Float
  user_id: Float
  value: Float
}

"""
order by var_pop() on columns of table "awards"
"""
input awards_var_pop_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
  value: order_by
}

"""aggregate var_samp on columns"""
type awards_var_samp_fields {
  id: Float
  team_id: Float
  user_id: Float
  value: Float
}

"""
order by var_samp() on columns of table "awards"
"""
input awards_var_samp_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
  value: order_by
}

"""aggregate variance on columns"""
type awards_variance_fields {
  id: Float
  team_id: Float
  user_id: Float
  value: Float
}

"""
order by variance() on columns of table "awards"
"""
input awards_variance_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
  value: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "challenges"
"""
type challenges {
  category: String

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): [comments!]!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): comments_aggregate!
  connection_info: String
  description: String

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """An array relationship"""
  flags(
    """distinct select on columns"""
    distinct_on: [flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [flags_order_by!]

    """filter the rows returned"""
    where: flags_bool_exp
  ): [flags!]!

  """An aggregate relationship"""
  flags_aggregate(
    """distinct select on columns"""
    distinct_on: [flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [flags_order_by!]

    """filter the rows returned"""
    where: flags_bool_exp
  ): flags_aggregate!

  """An array relationship"""
  hints(
    """distinct select on columns"""
    distinct_on: [hints_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_order_by!]

    """filter the rows returned"""
    where: hints_bool_exp
  ): [hints!]!

  """An aggregate relationship"""
  hints_aggregate(
    """distinct select on columns"""
    distinct_on: [hints_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_order_by!]

    """filter the rows returned"""
    where: hints_bool_exp
  ): hints_aggregate!
  id: Int!
  max_attempts: Int
  name: String
  next_id: Int
  requirements(
    """JSON select path"""
    path: String
  ): json

  """
  A computed field, executes function "challenges_solved"
  """
  solved: Boolean

  """An array relationship"""
  solves(
    """distinct select on columns"""
    distinct_on: [solves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solves_order_by!]

    """filter the rows returned"""
    where: solves_bool_exp
  ): [solves!]!

  """An aggregate relationship"""
  solves_aggregate(
    """distinct select on columns"""
    distinct_on: [solves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solves_order_by!]

    """filter the rows returned"""
    where: solves_bool_exp
  ): solves_aggregate!
  state: String!

  """An array relationship"""
  submissions(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): [submissions!]!

  """An aggregate relationship"""
  submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): submissions_aggregate!

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): [tags!]!

  """An aggregate relationship"""
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): tags_aggregate!
  type: String
  value: Int
}

"""
aggregated selection of "challenges"
"""
type challenges_aggregate {
  aggregate: challenges_aggregate_fields
  nodes: [challenges!]!
}

"""
aggregate fields of "challenges"
"""
type challenges_aggregate_fields {
  avg: challenges_avg_fields
  count(columns: [challenges_select_column!], distinct: Boolean): Int!
  max: challenges_max_fields
  min: challenges_min_fields
  stddev: challenges_stddev_fields
  stddev_pop: challenges_stddev_pop_fields
  stddev_samp: challenges_stddev_samp_fields
  sum: challenges_sum_fields
  var_pop: challenges_var_pop_fields
  var_samp: challenges_var_samp_fields
  variance: challenges_variance_fields
}

"""aggregate avg on columns"""
type challenges_avg_fields {
  id: Float
  max_attempts: Float
  next_id: Float
  value: Float
}

"""
Boolean expression to filter rows from the table "challenges". All fields are combined with a logical 'AND'.
"""
input challenges_bool_exp {
  _and: [challenges_bool_exp!]
  _not: challenges_bool_exp
  _or: [challenges_bool_exp!]
  category: String_comparison_exp
  comments: comments_bool_exp
  connection_info: String_comparison_exp
  description: String_comparison_exp
  files: files_bool_exp
  flags: flags_bool_exp
  hints: hints_bool_exp
  id: Int_comparison_exp
  max_attempts: Int_comparison_exp
  name: String_comparison_exp
  next_id: Int_comparison_exp
  requirements: json_comparison_exp
  solved: Boolean_comparison_exp
  solves: solves_bool_exp
  state: String_comparison_exp
  submissions: submissions_bool_exp
  tags: tags_bool_exp
  type: String_comparison_exp
  value: Int_comparison_exp
}

"""
unique or primary key constraints on table "challenges"
"""
enum challenges_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  challenges_pkey
}

"""
input type for incrementing numeric columns in table "challenges"
"""
input challenges_inc_input {
  id: Int
  max_attempts: Int
  next_id: Int
  value: Int
}

"""
input type for inserting data into table "challenges"
"""
input challenges_insert_input {
  category: String
  comments: comments_arr_rel_insert_input
  connection_info: String
  description: String
  files: files_arr_rel_insert_input
  flags: flags_arr_rel_insert_input
  hints: hints_arr_rel_insert_input
  id: Int
  max_attempts: Int
  name: String
  next_id: Int
  requirements: json
  solves: solves_arr_rel_insert_input
  state: String
  submissions: submissions_arr_rel_insert_input
  tags: tags_arr_rel_insert_input
  type: String
  value: Int
}

"""aggregate max on columns"""
type challenges_max_fields {
  category: String
  connection_info: String
  description: String
  id: Int
  max_attempts: Int
  name: String
  next_id: Int
  state: String
  type: String
  value: Int
}

"""aggregate min on columns"""
type challenges_min_fields {
  category: String
  connection_info: String
  description: String
  id: Int
  max_attempts: Int
  name: String
  next_id: Int
  state: String
  type: String
  value: Int
}

"""
response of any mutation on the table "challenges"
"""
type challenges_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [challenges!]!
}

"""
input type for inserting object relation for remote table "challenges"
"""
input challenges_obj_rel_insert_input {
  data: challenges_insert_input!

  """upsert condition"""
  on_conflict: challenges_on_conflict
}

"""
on_conflict condition type for table "challenges"
"""
input challenges_on_conflict {
  constraint: challenges_constraint!
  update_columns: [challenges_update_column!]! = []
  where: challenges_bool_exp
}

"""Ordering options when selecting data from "challenges"."""
input challenges_order_by {
  category: order_by
  comments_aggregate: comments_aggregate_order_by
  connection_info: order_by
  description: order_by
  files_aggregate: files_aggregate_order_by
  flags_aggregate: flags_aggregate_order_by
  hints_aggregate: hints_aggregate_order_by
  id: order_by
  max_attempts: order_by
  name: order_by
  next_id: order_by
  requirements: order_by
  solved: order_by
  solves_aggregate: solves_aggregate_order_by
  state: order_by
  submissions_aggregate: submissions_aggregate_order_by
  tags_aggregate: tags_aggregate_order_by
  type: order_by
  value: order_by
}

"""primary key columns input for table: challenges"""
input challenges_pk_columns_input {
  id: Int!
}

"""
select columns of table "challenges"
"""
enum challenges_select_column {
  """column name"""
  category

  """column name"""
  connection_info

  """column name"""
  description

  """column name"""
  id

  """column name"""
  max_attempts

  """column name"""
  name

  """column name"""
  next_id

  """column name"""
  requirements

  """column name"""
  state

  """column name"""
  type

  """column name"""
  value
}

"""
input type for updating data in table "challenges"
"""
input challenges_set_input {
  category: String
  connection_info: String
  description: String
  id: Int
  max_attempts: Int
  name: String
  next_id: Int
  requirements: json
  state: String
  type: String
  value: Int
}

"""aggregate stddev on columns"""
type challenges_stddev_fields {
  id: Float
  max_attempts: Float
  next_id: Float
  value: Float
}

"""aggregate stddev_pop on columns"""
type challenges_stddev_pop_fields {
  id: Float
  max_attempts: Float
  next_id: Float
  value: Float
}

"""aggregate stddev_samp on columns"""
type challenges_stddev_samp_fields {
  id: Float
  max_attempts: Float
  next_id: Float
  value: Float
}

"""aggregate sum on columns"""
type challenges_sum_fields {
  id: Int
  max_attempts: Int
  next_id: Int
  value: Int
}

"""
update columns of table "challenges"
"""
enum challenges_update_column {
  """column name"""
  category

  """column name"""
  connection_info

  """column name"""
  description

  """column name"""
  id

  """column name"""
  max_attempts

  """column name"""
  name

  """column name"""
  next_id

  """column name"""
  requirements

  """column name"""
  state

  """column name"""
  type

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type challenges_var_pop_fields {
  id: Float
  max_attempts: Float
  next_id: Float
  value: Float
}

"""aggregate var_samp on columns"""
type challenges_var_samp_fields {
  id: Float
  max_attempts: Float
  next_id: Float
  value: Float
}

"""aggregate variance on columns"""
type challenges_variance_fields {
  id: Float
  max_attempts: Float
  next_id: Float
  value: Float
}

"""
columns and relationships of "comments"
"""
type comments {
  author_id: Int

  """An object relationship"""
  challenge: challenges
  challenge_id: Int
  content: String
  date: timestamp
  id: Int!

  """An object relationship"""
  page: pages
  page_id: Int

  """An object relationship"""
  team: teams
  team_id: Int
  type: String

  """An object relationship"""
  user: users

  """An object relationship"""
  userByUserId: users
  user_id: Int
}

"""
aggregated selection of "comments"
"""
type comments_aggregate {
  aggregate: comments_aggregate_fields
  nodes: [comments!]!
}

"""
aggregate fields of "comments"
"""
type comments_aggregate_fields {
  avg: comments_avg_fields
  count(columns: [comments_select_column!], distinct: Boolean): Int!
  max: comments_max_fields
  min: comments_min_fields
  stddev: comments_stddev_fields
  stddev_pop: comments_stddev_pop_fields
  stddev_samp: comments_stddev_samp_fields
  sum: comments_sum_fields
  var_pop: comments_var_pop_fields
  var_samp: comments_var_samp_fields
  variance: comments_variance_fields
}

"""
order by aggregate values of table "comments"
"""
input comments_aggregate_order_by {
  avg: comments_avg_order_by
  count: order_by
  max: comments_max_order_by
  min: comments_min_order_by
  stddev: comments_stddev_order_by
  stddev_pop: comments_stddev_pop_order_by
  stddev_samp: comments_stddev_samp_order_by
  sum: comments_sum_order_by
  var_pop: comments_var_pop_order_by
  var_samp: comments_var_samp_order_by
  variance: comments_variance_order_by
}

"""
input type for inserting array relation for remote table "comments"
"""
input comments_arr_rel_insert_input {
  data: [comments_insert_input!]!

  """upsert condition"""
  on_conflict: comments_on_conflict
}

"""aggregate avg on columns"""
type comments_avg_fields {
  author_id: Float
  challenge_id: Float
  id: Float
  page_id: Float
  team_id: Float
  user_id: Float
}

"""
order by avg() on columns of table "comments"
"""
input comments_avg_order_by {
  author_id: order_by
  challenge_id: order_by
  id: order_by
  page_id: order_by
  team_id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "comments". All fields are combined with a logical 'AND'.
"""
input comments_bool_exp {
  _and: [comments_bool_exp!]
  _not: comments_bool_exp
  _or: [comments_bool_exp!]
  author_id: Int_comparison_exp
  challenge: challenges_bool_exp
  challenge_id: Int_comparison_exp
  content: String_comparison_exp
  date: timestamp_comparison_exp
  id: Int_comparison_exp
  page: pages_bool_exp
  page_id: Int_comparison_exp
  team: teams_bool_exp
  team_id: Int_comparison_exp
  type: String_comparison_exp
  user: users_bool_exp
  userByUserId: users_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "comments"
"""
enum comments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  comments_pkey
}

"""
input type for incrementing numeric columns in table "comments"
"""
input comments_inc_input {
  author_id: Int
  challenge_id: Int
  id: Int
  page_id: Int
  team_id: Int
  user_id: Int
}

"""
input type for inserting data into table "comments"
"""
input comments_insert_input {
  author_id: Int
  challenge: challenges_obj_rel_insert_input
  challenge_id: Int
  content: String
  date: timestamp
  id: Int
  page: pages_obj_rel_insert_input
  page_id: Int
  team: teams_obj_rel_insert_input
  team_id: Int
  type: String
  user: users_obj_rel_insert_input
  userByUserId: users_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type comments_max_fields {
  author_id: Int
  challenge_id: Int
  content: String
  date: timestamp
  id: Int
  page_id: Int
  team_id: Int
  type: String
  user_id: Int
}

"""
order by max() on columns of table "comments"
"""
input comments_max_order_by {
  author_id: order_by
  challenge_id: order_by
  content: order_by
  date: order_by
  id: order_by
  page_id: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type comments_min_fields {
  author_id: Int
  challenge_id: Int
  content: String
  date: timestamp
  id: Int
  page_id: Int
  team_id: Int
  type: String
  user_id: Int
}

"""
order by min() on columns of table "comments"
"""
input comments_min_order_by {
  author_id: order_by
  challenge_id: order_by
  content: order_by
  date: order_by
  id: order_by
  page_id: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""
response of any mutation on the table "comments"
"""
type comments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [comments!]!
}

"""
on_conflict condition type for table "comments"
"""
input comments_on_conflict {
  constraint: comments_constraint!
  update_columns: [comments_update_column!]! = []
  where: comments_bool_exp
}

"""Ordering options when selecting data from "comments"."""
input comments_order_by {
  author_id: order_by
  challenge: challenges_order_by
  challenge_id: order_by
  content: order_by
  date: order_by
  id: order_by
  page: pages_order_by
  page_id: order_by
  team: teams_order_by
  team_id: order_by
  type: order_by
  user: users_order_by
  userByUserId: users_order_by
  user_id: order_by
}

"""primary key columns input for table: comments"""
input comments_pk_columns_input {
  id: Int!
}

"""
select columns of table "comments"
"""
enum comments_select_column {
  """column name"""
  author_id

  """column name"""
  challenge_id

  """column name"""
  content

  """column name"""
  date

  """column name"""
  id

  """column name"""
  page_id

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id
}

"""
input type for updating data in table "comments"
"""
input comments_set_input {
  author_id: Int
  challenge_id: Int
  content: String
  date: timestamp
  id: Int
  page_id: Int
  team_id: Int
  type: String
  user_id: Int
}

"""aggregate stddev on columns"""
type comments_stddev_fields {
  author_id: Float
  challenge_id: Float
  id: Float
  page_id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "comments"
"""
input comments_stddev_order_by {
  author_id: order_by
  challenge_id: order_by
  id: order_by
  page_id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type comments_stddev_pop_fields {
  author_id: Float
  challenge_id: Float
  id: Float
  page_id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "comments"
"""
input comments_stddev_pop_order_by {
  author_id: order_by
  challenge_id: order_by
  id: order_by
  page_id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type comments_stddev_samp_fields {
  author_id: Float
  challenge_id: Float
  id: Float
  page_id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "comments"
"""
input comments_stddev_samp_order_by {
  author_id: order_by
  challenge_id: order_by
  id: order_by
  page_id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate sum on columns"""
type comments_sum_fields {
  author_id: Int
  challenge_id: Int
  id: Int
  page_id: Int
  team_id: Int
  user_id: Int
}

"""
order by sum() on columns of table "comments"
"""
input comments_sum_order_by {
  author_id: order_by
  challenge_id: order_by
  id: order_by
  page_id: order_by
  team_id: order_by
  user_id: order_by
}

"""
update columns of table "comments"
"""
enum comments_update_column {
  """column name"""
  author_id

  """column name"""
  challenge_id

  """column name"""
  content

  """column name"""
  date

  """column name"""
  id

  """column name"""
  page_id

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type comments_var_pop_fields {
  author_id: Float
  challenge_id: Float
  id: Float
  page_id: Float
  team_id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "comments"
"""
input comments_var_pop_order_by {
  author_id: order_by
  challenge_id: order_by
  id: order_by
  page_id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type comments_var_samp_fields {
  author_id: Float
  challenge_id: Float
  id: Float
  page_id: Float
  team_id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "comments"
"""
input comments_var_samp_order_by {
  author_id: order_by
  challenge_id: order_by
  id: order_by
  page_id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type comments_variance_fields {
  author_id: Float
  challenge_id: Float
  id: Float
  page_id: Float
  team_id: Float
  user_id: Float
}

"""
order by variance() on columns of table "comments"
"""
input comments_variance_order_by {
  author_id: order_by
  challenge_id: order_by
  id: order_by
  page_id: order_by
  team_id: order_by
  user_id: order_by
}

"""
columns and relationships of "config"
"""
type config {
  id: Int!
  key: String
  value: String
}

"""
aggregated selection of "config"
"""
type config_aggregate {
  aggregate: config_aggregate_fields
  nodes: [config!]!
}

"""
aggregate fields of "config"
"""
type config_aggregate_fields {
  avg: config_avg_fields
  count(columns: [config_select_column!], distinct: Boolean): Int!
  max: config_max_fields
  min: config_min_fields
  stddev: config_stddev_fields
  stddev_pop: config_stddev_pop_fields
  stddev_samp: config_stddev_samp_fields
  sum: config_sum_fields
  var_pop: config_var_pop_fields
  var_samp: config_var_samp_fields
  variance: config_variance_fields
}

"""aggregate avg on columns"""
type config_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "config". All fields are combined with a logical 'AND'.
"""
input config_bool_exp {
  _and: [config_bool_exp!]
  _not: config_bool_exp
  _or: [config_bool_exp!]
  id: Int_comparison_exp
  key: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "config"
"""
enum config_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  config_pkey
}

"""
input type for incrementing numeric columns in table "config"
"""
input config_inc_input {
  id: Int
}

"""
input type for inserting data into table "config"
"""
input config_insert_input {
  id: Int
  key: String
  value: String
}

"""aggregate max on columns"""
type config_max_fields {
  id: Int
  key: String
  value: String
}

"""aggregate min on columns"""
type config_min_fields {
  id: Int
  key: String
  value: String
}

"""
response of any mutation on the table "config"
"""
type config_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [config!]!
}

"""
on_conflict condition type for table "config"
"""
input config_on_conflict {
  constraint: config_constraint!
  update_columns: [config_update_column!]! = []
  where: config_bool_exp
}

"""Ordering options when selecting data from "config"."""
input config_order_by {
  id: order_by
  key: order_by
  value: order_by
}

"""primary key columns input for table: config"""
input config_pk_columns_input {
  id: Int!
}

"""
select columns of table "config"
"""
enum config_select_column {
  """column name"""
  id

  """column name"""
  key

  """column name"""
  value
}

"""
input type for updating data in table "config"
"""
input config_set_input {
  id: Int
  key: String
  value: String
}

"""aggregate stddev on columns"""
type config_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type config_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type config_stddev_samp_fields {
  id: Float
}

"""aggregate sum on columns"""
type config_sum_fields {
  id: Int
}

"""
update columns of table "config"
"""
enum config_update_column {
  """column name"""
  id

  """column name"""
  key

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type config_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type config_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type config_variance_fields {
  id: Float
}

"""
columns and relationships of "dynamic_challenge"
"""
type dynamic_challenge {
  """An object relationship"""
  challenge: challenges!
  decay: Int
  id: Int!
  initial: Int
  minimum: Int
}

"""
aggregated selection of "dynamic_challenge"
"""
type dynamic_challenge_aggregate {
  aggregate: dynamic_challenge_aggregate_fields
  nodes: [dynamic_challenge!]!
}

"""
aggregate fields of "dynamic_challenge"
"""
type dynamic_challenge_aggregate_fields {
  avg: dynamic_challenge_avg_fields
  count(columns: [dynamic_challenge_select_column!], distinct: Boolean): Int!
  max: dynamic_challenge_max_fields
  min: dynamic_challenge_min_fields
  stddev: dynamic_challenge_stddev_fields
  stddev_pop: dynamic_challenge_stddev_pop_fields
  stddev_samp: dynamic_challenge_stddev_samp_fields
  sum: dynamic_challenge_sum_fields
  var_pop: dynamic_challenge_var_pop_fields
  var_samp: dynamic_challenge_var_samp_fields
  variance: dynamic_challenge_variance_fields
}

"""aggregate avg on columns"""
type dynamic_challenge_avg_fields {
  decay: Float
  id: Float
  initial: Float
  minimum: Float
}

"""
Boolean expression to filter rows from the table "dynamic_challenge". All fields are combined with a logical 'AND'.
"""
input dynamic_challenge_bool_exp {
  _and: [dynamic_challenge_bool_exp!]
  _not: dynamic_challenge_bool_exp
  _or: [dynamic_challenge_bool_exp!]
  challenge: challenges_bool_exp
  decay: Int_comparison_exp
  id: Int_comparison_exp
  initial: Int_comparison_exp
  minimum: Int_comparison_exp
}

"""
unique or primary key constraints on table "dynamic_challenge"
"""
enum dynamic_challenge_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  dynamic_challenge_pkey
}

"""
input type for incrementing numeric columns in table "dynamic_challenge"
"""
input dynamic_challenge_inc_input {
  decay: Int
  id: Int
  initial: Int
  minimum: Int
}

"""
input type for inserting data into table "dynamic_challenge"
"""
input dynamic_challenge_insert_input {
  challenge: challenges_obj_rel_insert_input
  decay: Int
  id: Int
  initial: Int
  minimum: Int
}

"""aggregate max on columns"""
type dynamic_challenge_max_fields {
  decay: Int
  id: Int
  initial: Int
  minimum: Int
}

"""aggregate min on columns"""
type dynamic_challenge_min_fields {
  decay: Int
  id: Int
  initial: Int
  minimum: Int
}

"""
response of any mutation on the table "dynamic_challenge"
"""
type dynamic_challenge_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [dynamic_challenge!]!
}

"""
on_conflict condition type for table "dynamic_challenge"
"""
input dynamic_challenge_on_conflict {
  constraint: dynamic_challenge_constraint!
  update_columns: [dynamic_challenge_update_column!]! = []
  where: dynamic_challenge_bool_exp
}

"""Ordering options when selecting data from "dynamic_challenge"."""
input dynamic_challenge_order_by {
  challenge: challenges_order_by
  decay: order_by
  id: order_by
  initial: order_by
  minimum: order_by
}

"""primary key columns input for table: dynamic_challenge"""
input dynamic_challenge_pk_columns_input {
  id: Int!
}

"""
select columns of table "dynamic_challenge"
"""
enum dynamic_challenge_select_column {
  """column name"""
  decay

  """column name"""
  id

  """column name"""
  initial

  """column name"""
  minimum
}

"""
input type for updating data in table "dynamic_challenge"
"""
input dynamic_challenge_set_input {
  decay: Int
  id: Int
  initial: Int
  minimum: Int
}

"""aggregate stddev on columns"""
type dynamic_challenge_stddev_fields {
  decay: Float
  id: Float
  initial: Float
  minimum: Float
}

"""aggregate stddev_pop on columns"""
type dynamic_challenge_stddev_pop_fields {
  decay: Float
  id: Float
  initial: Float
  minimum: Float
}

"""aggregate stddev_samp on columns"""
type dynamic_challenge_stddev_samp_fields {
  decay: Float
  id: Float
  initial: Float
  minimum: Float
}

"""aggregate sum on columns"""
type dynamic_challenge_sum_fields {
  decay: Int
  id: Int
  initial: Int
  minimum: Int
}

"""
update columns of table "dynamic_challenge"
"""
enum dynamic_challenge_update_column {
  """column name"""
  decay

  """column name"""
  id

  """column name"""
  initial

  """column name"""
  minimum
}

"""aggregate var_pop on columns"""
type dynamic_challenge_var_pop_fields {
  decay: Float
  id: Float
  initial: Float
  minimum: Float
}

"""aggregate var_samp on columns"""
type dynamic_challenge_var_samp_fields {
  decay: Float
  id: Float
  initial: Float
  minimum: Float
}

"""aggregate variance on columns"""
type dynamic_challenge_variance_fields {
  decay: Float
  id: Float
  initial: Float
  minimum: Float
}

"""
columns and relationships of "field_entries"
"""
type field_entries {
  """An object relationship"""
  field: fields
  field_id: Int
  id: Int!

  """An object relationship"""
  team: teams
  team_id: Int
  type: String

  """An object relationship"""
  user: users
  user_id: Int
  value(
    """JSON select path"""
    path: String
  ): json
}

"""
aggregated selection of "field_entries"
"""
type field_entries_aggregate {
  aggregate: field_entries_aggregate_fields
  nodes: [field_entries!]!
}

"""
aggregate fields of "field_entries"
"""
type field_entries_aggregate_fields {
  avg: field_entries_avg_fields
  count(columns: [field_entries_select_column!], distinct: Boolean): Int!
  max: field_entries_max_fields
  min: field_entries_min_fields
  stddev: field_entries_stddev_fields
  stddev_pop: field_entries_stddev_pop_fields
  stddev_samp: field_entries_stddev_samp_fields
  sum: field_entries_sum_fields
  var_pop: field_entries_var_pop_fields
  var_samp: field_entries_var_samp_fields
  variance: field_entries_variance_fields
}

"""
order by aggregate values of table "field_entries"
"""
input field_entries_aggregate_order_by {
  avg: field_entries_avg_order_by
  count: order_by
  max: field_entries_max_order_by
  min: field_entries_min_order_by
  stddev: field_entries_stddev_order_by
  stddev_pop: field_entries_stddev_pop_order_by
  stddev_samp: field_entries_stddev_samp_order_by
  sum: field_entries_sum_order_by
  var_pop: field_entries_var_pop_order_by
  var_samp: field_entries_var_samp_order_by
  variance: field_entries_variance_order_by
}

"""
input type for inserting array relation for remote table "field_entries"
"""
input field_entries_arr_rel_insert_input {
  data: [field_entries_insert_input!]!

  """upsert condition"""
  on_conflict: field_entries_on_conflict
}

"""aggregate avg on columns"""
type field_entries_avg_fields {
  field_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by avg() on columns of table "field_entries"
"""
input field_entries_avg_order_by {
  field_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "field_entries". All fields are combined with a logical 'AND'.
"""
input field_entries_bool_exp {
  _and: [field_entries_bool_exp!]
  _not: field_entries_bool_exp
  _or: [field_entries_bool_exp!]
  field: fields_bool_exp
  field_id: Int_comparison_exp
  id: Int_comparison_exp
  team: teams_bool_exp
  team_id: Int_comparison_exp
  type: String_comparison_exp
  user: users_bool_exp
  user_id: Int_comparison_exp
  value: json_comparison_exp
}

"""
unique or primary key constraints on table "field_entries"
"""
enum field_entries_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  field_entries_pkey
}

"""
input type for incrementing numeric columns in table "field_entries"
"""
input field_entries_inc_input {
  field_id: Int
  id: Int
  team_id: Int
  user_id: Int
}

"""
input type for inserting data into table "field_entries"
"""
input field_entries_insert_input {
  field: fields_obj_rel_insert_input
  field_id: Int
  id: Int
  team: teams_obj_rel_insert_input
  team_id: Int
  type: String
  user: users_obj_rel_insert_input
  user_id: Int
  value: json
}

"""aggregate max on columns"""
type field_entries_max_fields {
  field_id: Int
  id: Int
  team_id: Int
  type: String
  user_id: Int
}

"""
order by max() on columns of table "field_entries"
"""
input field_entries_max_order_by {
  field_id: order_by
  id: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type field_entries_min_fields {
  field_id: Int
  id: Int
  team_id: Int
  type: String
  user_id: Int
}

"""
order by min() on columns of table "field_entries"
"""
input field_entries_min_order_by {
  field_id: order_by
  id: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""
response of any mutation on the table "field_entries"
"""
type field_entries_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [field_entries!]!
}

"""
on_conflict condition type for table "field_entries"
"""
input field_entries_on_conflict {
  constraint: field_entries_constraint!
  update_columns: [field_entries_update_column!]! = []
  where: field_entries_bool_exp
}

"""Ordering options when selecting data from "field_entries"."""
input field_entries_order_by {
  field: fields_order_by
  field_id: order_by
  id: order_by
  team: teams_order_by
  team_id: order_by
  type: order_by
  user: users_order_by
  user_id: order_by
  value: order_by
}

"""primary key columns input for table: field_entries"""
input field_entries_pk_columns_input {
  id: Int!
}

"""
select columns of table "field_entries"
"""
enum field_entries_select_column {
  """column name"""
  field_id

  """column name"""
  id

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value
}

"""
input type for updating data in table "field_entries"
"""
input field_entries_set_input {
  field_id: Int
  id: Int
  team_id: Int
  type: String
  user_id: Int
  value: json
}

"""aggregate stddev on columns"""
type field_entries_stddev_fields {
  field_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "field_entries"
"""
input field_entries_stddev_order_by {
  field_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type field_entries_stddev_pop_fields {
  field_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "field_entries"
"""
input field_entries_stddev_pop_order_by {
  field_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type field_entries_stddev_samp_fields {
  field_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "field_entries"
"""
input field_entries_stddev_samp_order_by {
  field_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate sum on columns"""
type field_entries_sum_fields {
  field_id: Int
  id: Int
  team_id: Int
  user_id: Int
}

"""
order by sum() on columns of table "field_entries"
"""
input field_entries_sum_order_by {
  field_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""
update columns of table "field_entries"
"""
enum field_entries_update_column {
  """column name"""
  field_id

  """column name"""
  id

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type field_entries_var_pop_fields {
  field_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "field_entries"
"""
input field_entries_var_pop_order_by {
  field_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type field_entries_var_samp_fields {
  field_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "field_entries"
"""
input field_entries_var_samp_order_by {
  field_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type field_entries_variance_fields {
  field_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by variance() on columns of table "field_entries"
"""
input field_entries_variance_order_by {
  field_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""
columns and relationships of "fields"
"""
type fields {
  description: String
  editable: Boolean

  """An array relationship"""
  field_entries(
    """distinct select on columns"""
    distinct_on: [field_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entries_order_by!]

    """filter the rows returned"""
    where: field_entries_bool_exp
  ): [field_entries!]!

  """An aggregate relationship"""
  field_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [field_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entries_order_by!]

    """filter the rows returned"""
    where: field_entries_bool_exp
  ): field_entries_aggregate!
  field_type: String
  id: Int!
  name: String
  public: Boolean
  required: Boolean
  type: String
}

"""
aggregated selection of "fields"
"""
type fields_aggregate {
  aggregate: fields_aggregate_fields
  nodes: [fields!]!
}

"""
aggregate fields of "fields"
"""
type fields_aggregate_fields {
  avg: fields_avg_fields
  count(columns: [fields_select_column!], distinct: Boolean): Int!
  max: fields_max_fields
  min: fields_min_fields
  stddev: fields_stddev_fields
  stddev_pop: fields_stddev_pop_fields
  stddev_samp: fields_stddev_samp_fields
  sum: fields_sum_fields
  var_pop: fields_var_pop_fields
  var_samp: fields_var_samp_fields
  variance: fields_variance_fields
}

"""aggregate avg on columns"""
type fields_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "fields". All fields are combined with a logical 'AND'.
"""
input fields_bool_exp {
  _and: [fields_bool_exp!]
  _not: fields_bool_exp
  _or: [fields_bool_exp!]
  description: String_comparison_exp
  editable: Boolean_comparison_exp
  field_entries: field_entries_bool_exp
  field_type: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  public: Boolean_comparison_exp
  required: Boolean_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "fields"
"""
enum fields_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  fields_pkey
}

"""
input type for incrementing numeric columns in table "fields"
"""
input fields_inc_input {
  id: Int
}

"""
input type for inserting data into table "fields"
"""
input fields_insert_input {
  description: String
  editable: Boolean
  field_entries: field_entries_arr_rel_insert_input
  field_type: String
  id: Int
  name: String
  public: Boolean
  required: Boolean
  type: String
}

"""aggregate max on columns"""
type fields_max_fields {
  description: String
  field_type: String
  id: Int
  name: String
  type: String
}

"""aggregate min on columns"""
type fields_min_fields {
  description: String
  field_type: String
  id: Int
  name: String
  type: String
}

"""
response of any mutation on the table "fields"
"""
type fields_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [fields!]!
}

"""
input type for inserting object relation for remote table "fields"
"""
input fields_obj_rel_insert_input {
  data: fields_insert_input!

  """upsert condition"""
  on_conflict: fields_on_conflict
}

"""
on_conflict condition type for table "fields"
"""
input fields_on_conflict {
  constraint: fields_constraint!
  update_columns: [fields_update_column!]! = []
  where: fields_bool_exp
}

"""Ordering options when selecting data from "fields"."""
input fields_order_by {
  description: order_by
  editable: order_by
  field_entries_aggregate: field_entries_aggregate_order_by
  field_type: order_by
  id: order_by
  name: order_by
  public: order_by
  required: order_by
  type: order_by
}

"""primary key columns input for table: fields"""
input fields_pk_columns_input {
  id: Int!
}

"""
select columns of table "fields"
"""
enum fields_select_column {
  """column name"""
  description

  """column name"""
  editable

  """column name"""
  field_type

  """column name"""
  id

  """column name"""
  name

  """column name"""
  public

  """column name"""
  required

  """column name"""
  type
}

"""
input type for updating data in table "fields"
"""
input fields_set_input {
  description: String
  editable: Boolean
  field_type: String
  id: Int
  name: String
  public: Boolean
  required: Boolean
  type: String
}

"""aggregate stddev on columns"""
type fields_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type fields_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type fields_stddev_samp_fields {
  id: Float
}

"""aggregate sum on columns"""
type fields_sum_fields {
  id: Int
}

"""
update columns of table "fields"
"""
enum fields_update_column {
  """column name"""
  description

  """column name"""
  editable

  """column name"""
  field_type

  """column name"""
  id

  """column name"""
  name

  """column name"""
  public

  """column name"""
  required

  """column name"""
  type
}

"""aggregate var_pop on columns"""
type fields_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type fields_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type fields_variance_fields {
  id: Float
}

"""
columns and relationships of "files"
"""
type files {
  """An object relationship"""
  challenge: challenges
  challenge_id: Int
  id: Int!
  location: String

  """An object relationship"""
  page: pages
  page_id: Int
  type: String
}

"""
aggregated selection of "files"
"""
type files_aggregate {
  aggregate: files_aggregate_fields
  nodes: [files!]!
}

"""
aggregate fields of "files"
"""
type files_aggregate_fields {
  avg: files_avg_fields
  count(columns: [files_select_column!], distinct: Boolean): Int!
  max: files_max_fields
  min: files_min_fields
  stddev: files_stddev_fields
  stddev_pop: files_stddev_pop_fields
  stddev_samp: files_stddev_samp_fields
  sum: files_sum_fields
  var_pop: files_var_pop_fields
  var_samp: files_var_samp_fields
  variance: files_variance_fields
}

"""
order by aggregate values of table "files"
"""
input files_aggregate_order_by {
  avg: files_avg_order_by
  count: order_by
  max: files_max_order_by
  min: files_min_order_by
  stddev: files_stddev_order_by
  stddev_pop: files_stddev_pop_order_by
  stddev_samp: files_stddev_samp_order_by
  sum: files_sum_order_by
  var_pop: files_var_pop_order_by
  var_samp: files_var_samp_order_by
  variance: files_variance_order_by
}

"""
input type for inserting array relation for remote table "files"
"""
input files_arr_rel_insert_input {
  data: [files_insert_input!]!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""aggregate avg on columns"""
type files_avg_fields {
  challenge_id: Float
  id: Float
  page_id: Float
}

"""
order by avg() on columns of table "files"
"""
input files_avg_order_by {
  challenge_id: order_by
  id: order_by
  page_id: order_by
}

"""
Boolean expression to filter rows from the table "files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
  _and: [files_bool_exp!]
  _not: files_bool_exp
  _or: [files_bool_exp!]
  challenge: challenges_bool_exp
  challenge_id: Int_comparison_exp
  id: Int_comparison_exp
  location: String_comparison_exp
  page: pages_bool_exp
  page_id: Int_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "files"
"""
enum files_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  files_pkey
}

"""
input type for incrementing numeric columns in table "files"
"""
input files_inc_input {
  challenge_id: Int
  id: Int
  page_id: Int
}

"""
input type for inserting data into table "files"
"""
input files_insert_input {
  challenge: challenges_obj_rel_insert_input
  challenge_id: Int
  id: Int
  location: String
  page: pages_obj_rel_insert_input
  page_id: Int
  type: String
}

"""aggregate max on columns"""
type files_max_fields {
  challenge_id: Int
  id: Int
  location: String
  page_id: Int
  type: String
}

"""
order by max() on columns of table "files"
"""
input files_max_order_by {
  challenge_id: order_by
  id: order_by
  location: order_by
  page_id: order_by
  type: order_by
}

"""aggregate min on columns"""
type files_min_fields {
  challenge_id: Int
  id: Int
  location: String
  page_id: Int
  type: String
}

"""
order by min() on columns of table "files"
"""
input files_min_order_by {
  challenge_id: order_by
  id: order_by
  location: order_by
  page_id: order_by
  type: order_by
}

"""
response of any mutation on the table "files"
"""
type files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [files!]!
}

"""
on_conflict condition type for table "files"
"""
input files_on_conflict {
  constraint: files_constraint!
  update_columns: [files_update_column!]! = []
  where: files_bool_exp
}

"""Ordering options when selecting data from "files"."""
input files_order_by {
  challenge: challenges_order_by
  challenge_id: order_by
  id: order_by
  location: order_by
  page: pages_order_by
  page_id: order_by
  type: order_by
}

"""primary key columns input for table: files"""
input files_pk_columns_input {
  id: Int!
}

"""
select columns of table "files"
"""
enum files_select_column {
  """column name"""
  challenge_id

  """column name"""
  id

  """column name"""
  location

  """column name"""
  page_id

  """column name"""
  type
}

"""
input type for updating data in table "files"
"""
input files_set_input {
  challenge_id: Int
  id: Int
  location: String
  page_id: Int
  type: String
}

"""aggregate stddev on columns"""
type files_stddev_fields {
  challenge_id: Float
  id: Float
  page_id: Float
}

"""
order by stddev() on columns of table "files"
"""
input files_stddev_order_by {
  challenge_id: order_by
  id: order_by
  page_id: order_by
}

"""aggregate stddev_pop on columns"""
type files_stddev_pop_fields {
  challenge_id: Float
  id: Float
  page_id: Float
}

"""
order by stddev_pop() on columns of table "files"
"""
input files_stddev_pop_order_by {
  challenge_id: order_by
  id: order_by
  page_id: order_by
}

"""aggregate stddev_samp on columns"""
type files_stddev_samp_fields {
  challenge_id: Float
  id: Float
  page_id: Float
}

"""
order by stddev_samp() on columns of table "files"
"""
input files_stddev_samp_order_by {
  challenge_id: order_by
  id: order_by
  page_id: order_by
}

"""aggregate sum on columns"""
type files_sum_fields {
  challenge_id: Int
  id: Int
  page_id: Int
}

"""
order by sum() on columns of table "files"
"""
input files_sum_order_by {
  challenge_id: order_by
  id: order_by
  page_id: order_by
}

"""
update columns of table "files"
"""
enum files_update_column {
  """column name"""
  challenge_id

  """column name"""
  id

  """column name"""
  location

  """column name"""
  page_id

  """column name"""
  type
}

"""aggregate var_pop on columns"""
type files_var_pop_fields {
  challenge_id: Float
  id: Float
  page_id: Float
}

"""
order by var_pop() on columns of table "files"
"""
input files_var_pop_order_by {
  challenge_id: order_by
  id: order_by
  page_id: order_by
}

"""aggregate var_samp on columns"""
type files_var_samp_fields {
  challenge_id: Float
  id: Float
  page_id: Float
}

"""
order by var_samp() on columns of table "files"
"""
input files_var_samp_order_by {
  challenge_id: order_by
  id: order_by
  page_id: order_by
}

"""aggregate variance on columns"""
type files_variance_fields {
  challenge_id: Float
  id: Float
  page_id: Float
}

"""
order by variance() on columns of table "files"
"""
input files_variance_order_by {
  challenge_id: order_by
  id: order_by
  page_id: order_by
}

"""
columns and relationships of "flags"
"""
type flags {
  """An object relationship"""
  challenge: challenges
  challenge_id: Int
  content: String
  data: String
  id: Int!
  type: String
}

"""
aggregated selection of "flags"
"""
type flags_aggregate {
  aggregate: flags_aggregate_fields
  nodes: [flags!]!
}

"""
aggregate fields of "flags"
"""
type flags_aggregate_fields {
  avg: flags_avg_fields
  count(columns: [flags_select_column!], distinct: Boolean): Int!
  max: flags_max_fields
  min: flags_min_fields
  stddev: flags_stddev_fields
  stddev_pop: flags_stddev_pop_fields
  stddev_samp: flags_stddev_samp_fields
  sum: flags_sum_fields
  var_pop: flags_var_pop_fields
  var_samp: flags_var_samp_fields
  variance: flags_variance_fields
}

"""
order by aggregate values of table "flags"
"""
input flags_aggregate_order_by {
  avg: flags_avg_order_by
  count: order_by
  max: flags_max_order_by
  min: flags_min_order_by
  stddev: flags_stddev_order_by
  stddev_pop: flags_stddev_pop_order_by
  stddev_samp: flags_stddev_samp_order_by
  sum: flags_sum_order_by
  var_pop: flags_var_pop_order_by
  var_samp: flags_var_samp_order_by
  variance: flags_variance_order_by
}

"""
input type for inserting array relation for remote table "flags"
"""
input flags_arr_rel_insert_input {
  data: [flags_insert_input!]!

  """upsert condition"""
  on_conflict: flags_on_conflict
}

"""aggregate avg on columns"""
type flags_avg_fields {
  challenge_id: Float
  id: Float
}

"""
order by avg() on columns of table "flags"
"""
input flags_avg_order_by {
  challenge_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "flags". All fields are combined with a logical 'AND'.
"""
input flags_bool_exp {
  _and: [flags_bool_exp!]
  _not: flags_bool_exp
  _or: [flags_bool_exp!]
  challenge: challenges_bool_exp
  challenge_id: Int_comparison_exp
  content: String_comparison_exp
  data: String_comparison_exp
  id: Int_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "flags"
"""
enum flags_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  flags_pkey
}

"""
input type for incrementing numeric columns in table "flags"
"""
input flags_inc_input {
  challenge_id: Int
  id: Int
}

"""
input type for inserting data into table "flags"
"""
input flags_insert_input {
  challenge: challenges_obj_rel_insert_input
  challenge_id: Int
  content: String
  data: String
  id: Int
  type: String
}

"""aggregate max on columns"""
type flags_max_fields {
  challenge_id: Int
  content: String
  data: String
  id: Int
  type: String
}

"""
order by max() on columns of table "flags"
"""
input flags_max_order_by {
  challenge_id: order_by
  content: order_by
  data: order_by
  id: order_by
  type: order_by
}

"""aggregate min on columns"""
type flags_min_fields {
  challenge_id: Int
  content: String
  data: String
  id: Int
  type: String
}

"""
order by min() on columns of table "flags"
"""
input flags_min_order_by {
  challenge_id: order_by
  content: order_by
  data: order_by
  id: order_by
  type: order_by
}

"""
response of any mutation on the table "flags"
"""
type flags_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [flags!]!
}

"""
on_conflict condition type for table "flags"
"""
input flags_on_conflict {
  constraint: flags_constraint!
  update_columns: [flags_update_column!]! = []
  where: flags_bool_exp
}

"""Ordering options when selecting data from "flags"."""
input flags_order_by {
  challenge: challenges_order_by
  challenge_id: order_by
  content: order_by
  data: order_by
  id: order_by
  type: order_by
}

"""primary key columns input for table: flags"""
input flags_pk_columns_input {
  id: Int!
}

"""
select columns of table "flags"
"""
enum flags_select_column {
  """column name"""
  challenge_id

  """column name"""
  content

  """column name"""
  data

  """column name"""
  id

  """column name"""
  type
}

"""
input type for updating data in table "flags"
"""
input flags_set_input {
  challenge_id: Int
  content: String
  data: String
  id: Int
  type: String
}

"""aggregate stddev on columns"""
type flags_stddev_fields {
  challenge_id: Float
  id: Float
}

"""
order by stddev() on columns of table "flags"
"""
input flags_stddev_order_by {
  challenge_id: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type flags_stddev_pop_fields {
  challenge_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "flags"
"""
input flags_stddev_pop_order_by {
  challenge_id: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type flags_stddev_samp_fields {
  challenge_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "flags"
"""
input flags_stddev_samp_order_by {
  challenge_id: order_by
  id: order_by
}

"""aggregate sum on columns"""
type flags_sum_fields {
  challenge_id: Int
  id: Int
}

"""
order by sum() on columns of table "flags"
"""
input flags_sum_order_by {
  challenge_id: order_by
  id: order_by
}

"""
update columns of table "flags"
"""
enum flags_update_column {
  """column name"""
  challenge_id

  """column name"""
  content

  """column name"""
  data

  """column name"""
  id

  """column name"""
  type
}

"""aggregate var_pop on columns"""
type flags_var_pop_fields {
  challenge_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "flags"
"""
input flags_var_pop_order_by {
  challenge_id: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type flags_var_samp_fields {
  challenge_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "flags"
"""
input flags_var_samp_order_by {
  challenge_id: order_by
  id: order_by
}

"""aggregate variance on columns"""
type flags_variance_fields {
  challenge_id: Float
  id: Float
}

"""
order by variance() on columns of table "flags"
"""
input flags_variance_order_by {
  challenge_id: order_by
  id: order_by
}

"""
columns and relationships of "hints"
"""
type hints {
  """An object relationship"""
  challenge: challenges
  challenge_id: Int
  content: String
  cost: Int
  id: Int!
  requirements(
    """JSON select path"""
    path: String
  ): json
  type: String

  """An object relationship"""
  unlocked_content: hints_content

  """An array relationship"""
  unlocks(
    """distinct select on columns"""
    distinct_on: [unlocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlocks_order_by!]

    """filter the rows returned"""
    where: unlocks_bool_exp
  ): [unlocks!]!

  """An aggregate relationship"""
  unlocks_aggregate(
    """distinct select on columns"""
    distinct_on: [unlocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlocks_order_by!]

    """filter the rows returned"""
    where: unlocks_bool_exp
  ): unlocks_aggregate!
}

"""
aggregated selection of "hints"
"""
type hints_aggregate {
  aggregate: hints_aggregate_fields
  nodes: [hints!]!
}

"""
aggregate fields of "hints"
"""
type hints_aggregate_fields {
  avg: hints_avg_fields
  count(columns: [hints_select_column!], distinct: Boolean): Int!
  max: hints_max_fields
  min: hints_min_fields
  stddev: hints_stddev_fields
  stddev_pop: hints_stddev_pop_fields
  stddev_samp: hints_stddev_samp_fields
  sum: hints_sum_fields
  var_pop: hints_var_pop_fields
  var_samp: hints_var_samp_fields
  variance: hints_variance_fields
}

"""
order by aggregate values of table "hints"
"""
input hints_aggregate_order_by {
  avg: hints_avg_order_by
  count: order_by
  max: hints_max_order_by
  min: hints_min_order_by
  stddev: hints_stddev_order_by
  stddev_pop: hints_stddev_pop_order_by
  stddev_samp: hints_stddev_samp_order_by
  sum: hints_sum_order_by
  var_pop: hints_var_pop_order_by
  var_samp: hints_var_samp_order_by
  variance: hints_variance_order_by
}

"""
input type for inserting array relation for remote table "hints"
"""
input hints_arr_rel_insert_input {
  data: [hints_insert_input!]!

  """upsert condition"""
  on_conflict: hints_on_conflict
}

"""aggregate avg on columns"""
type hints_avg_fields {
  challenge_id: Float
  cost: Float
  id: Float
}

"""
order by avg() on columns of table "hints"
"""
input hints_avg_order_by {
  challenge_id: order_by
  cost: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "hints". All fields are combined with a logical 'AND'.
"""
input hints_bool_exp {
  _and: [hints_bool_exp!]
  _not: hints_bool_exp
  _or: [hints_bool_exp!]
  challenge: challenges_bool_exp
  challenge_id: Int_comparison_exp
  content: String_comparison_exp
  cost: Int_comparison_exp
  id: Int_comparison_exp
  requirements: json_comparison_exp
  type: String_comparison_exp
  unlocked_content: hints_content_bool_exp
  unlocks: unlocks_bool_exp
}

"""
unique or primary key constraints on table "hints"
"""
enum hints_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  hints_pkey
}

"""
columns and relationships of "hints_content"
"""
type hints_content {
  content: String

  """An object relationship"""
  hint: hints
  id: Int
}

"""
aggregated selection of "hints_content"
"""
type hints_content_aggregate {
  aggregate: hints_content_aggregate_fields
  nodes: [hints_content!]!
}

"""
aggregate fields of "hints_content"
"""
type hints_content_aggregate_fields {
  avg: hints_content_avg_fields
  count(columns: [hints_content_select_column!], distinct: Boolean): Int!
  max: hints_content_max_fields
  min: hints_content_min_fields
  stddev: hints_content_stddev_fields
  stddev_pop: hints_content_stddev_pop_fields
  stddev_samp: hints_content_stddev_samp_fields
  sum: hints_content_sum_fields
  var_pop: hints_content_var_pop_fields
  var_samp: hints_content_var_samp_fields
  variance: hints_content_variance_fields
}

"""aggregate avg on columns"""
type hints_content_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "hints_content". All fields are combined with a logical 'AND'.
"""
input hints_content_bool_exp {
  _and: [hints_content_bool_exp!]
  _not: hints_content_bool_exp
  _or: [hints_content_bool_exp!]
  content: String_comparison_exp
  hint: hints_bool_exp
  id: Int_comparison_exp
}

"""
input type for incrementing numeric columns in table "hints_content"
"""
input hints_content_inc_input {
  id: Int
}

"""
input type for inserting data into table "hints_content"
"""
input hints_content_insert_input {
  content: String
  hint: hints_obj_rel_insert_input
  id: Int
}

"""aggregate max on columns"""
type hints_content_max_fields {
  content: String
  id: Int
}

"""aggregate min on columns"""
type hints_content_min_fields {
  content: String
  id: Int
}

"""
response of any mutation on the table "hints_content"
"""
type hints_content_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [hints_content!]!
}

"""
input type for inserting object relation for remote table "hints_content"
"""
input hints_content_obj_rel_insert_input {
  data: hints_content_insert_input!
}

"""Ordering options when selecting data from "hints_content"."""
input hints_content_order_by {
  content: order_by
  hint: hints_order_by
  id: order_by
}

"""
select columns of table "hints_content"
"""
enum hints_content_select_column {
  """column name"""
  content

  """column name"""
  id
}

"""
input type for updating data in table "hints_content"
"""
input hints_content_set_input {
  content: String
  id: Int
}

"""aggregate stddev on columns"""
type hints_content_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type hints_content_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type hints_content_stddev_samp_fields {
  id: Float
}

"""aggregate sum on columns"""
type hints_content_sum_fields {
  id: Int
}

"""aggregate var_pop on columns"""
type hints_content_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type hints_content_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type hints_content_variance_fields {
  id: Float
}

"""
input type for incrementing numeric columns in table "hints"
"""
input hints_inc_input {
  challenge_id: Int
  cost: Int
  id: Int
}

"""
input type for inserting data into table "hints"
"""
input hints_insert_input {
  challenge: challenges_obj_rel_insert_input
  challenge_id: Int
  content: String
  cost: Int
  id: Int
  requirements: json
  type: String
  unlocked_content: hints_content_obj_rel_insert_input
  unlocks: unlocks_arr_rel_insert_input
}

"""aggregate max on columns"""
type hints_max_fields {
  challenge_id: Int
  content: String
  cost: Int
  id: Int
  type: String
}

"""
order by max() on columns of table "hints"
"""
input hints_max_order_by {
  challenge_id: order_by
  content: order_by
  cost: order_by
  id: order_by
  type: order_by
}

"""aggregate min on columns"""
type hints_min_fields {
  challenge_id: Int
  content: String
  cost: Int
  id: Int
  type: String
}

"""
order by min() on columns of table "hints"
"""
input hints_min_order_by {
  challenge_id: order_by
  content: order_by
  cost: order_by
  id: order_by
  type: order_by
}

"""
response of any mutation on the table "hints"
"""
type hints_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [hints!]!
}

"""
input type for inserting object relation for remote table "hints"
"""
input hints_obj_rel_insert_input {
  data: hints_insert_input!

  """upsert condition"""
  on_conflict: hints_on_conflict
}

"""
on_conflict condition type for table "hints"
"""
input hints_on_conflict {
  constraint: hints_constraint!
  update_columns: [hints_update_column!]! = []
  where: hints_bool_exp
}

"""Ordering options when selecting data from "hints"."""
input hints_order_by {
  challenge: challenges_order_by
  challenge_id: order_by
  content: order_by
  cost: order_by
  id: order_by
  requirements: order_by
  type: order_by
  unlocked_content: hints_content_order_by
  unlocks_aggregate: unlocks_aggregate_order_by
}

"""primary key columns input for table: hints"""
input hints_pk_columns_input {
  id: Int!
}

"""
select columns of table "hints"
"""
enum hints_select_column {
  """column name"""
  challenge_id

  """column name"""
  content

  """column name"""
  cost

  """column name"""
  id

  """column name"""
  requirements

  """column name"""
  type
}

"""
input type for updating data in table "hints"
"""
input hints_set_input {
  challenge_id: Int
  content: String
  cost: Int
  id: Int
  requirements: json
  type: String
}

"""aggregate stddev on columns"""
type hints_stddev_fields {
  challenge_id: Float
  cost: Float
  id: Float
}

"""
order by stddev() on columns of table "hints"
"""
input hints_stddev_order_by {
  challenge_id: order_by
  cost: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type hints_stddev_pop_fields {
  challenge_id: Float
  cost: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "hints"
"""
input hints_stddev_pop_order_by {
  challenge_id: order_by
  cost: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type hints_stddev_samp_fields {
  challenge_id: Float
  cost: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "hints"
"""
input hints_stddev_samp_order_by {
  challenge_id: order_by
  cost: order_by
  id: order_by
}

"""aggregate sum on columns"""
type hints_sum_fields {
  challenge_id: Int
  cost: Int
  id: Int
}

"""
order by sum() on columns of table "hints"
"""
input hints_sum_order_by {
  challenge_id: order_by
  cost: order_by
  id: order_by
}

"""
update columns of table "hints"
"""
enum hints_update_column {
  """column name"""
  challenge_id

  """column name"""
  content

  """column name"""
  cost

  """column name"""
  id

  """column name"""
  requirements

  """column name"""
  type
}

"""aggregate var_pop on columns"""
type hints_var_pop_fields {
  challenge_id: Float
  cost: Float
  id: Float
}

"""
order by var_pop() on columns of table "hints"
"""
input hints_var_pop_order_by {
  challenge_id: order_by
  cost: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type hints_var_samp_fields {
  challenge_id: Float
  cost: Float
  id: Float
}

"""
order by var_samp() on columns of table "hints"
"""
input hints_var_samp_order_by {
  challenge_id: order_by
  cost: order_by
  id: order_by
}

"""aggregate variance on columns"""
type hints_variance_fields {
  challenge_id: Float
  cost: Float
  id: Float
}

"""
order by variance() on columns of table "hints"
"""
input hints_variance_order_by {
  challenge_id: order_by
  cost: order_by
  id: order_by
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "awards"
  """
  delete_awards(
    """filter the rows which have to be deleted"""
    where: awards_bool_exp!
  ): awards_mutation_response

  """
  delete single row from the table: "awards"
  """
  delete_awards_by_pk(id: Int!): awards

  """
  delete data from the table: "challenges"
  """
  delete_challenges(
    """filter the rows which have to be deleted"""
    where: challenges_bool_exp!
  ): challenges_mutation_response

  """
  delete single row from the table: "challenges"
  """
  delete_challenges_by_pk(id: Int!): challenges

  """
  delete data from the table: "comments"
  """
  delete_comments(
    """filter the rows which have to be deleted"""
    where: comments_bool_exp!
  ): comments_mutation_response

  """
  delete single row from the table: "comments"
  """
  delete_comments_by_pk(id: Int!): comments

  """
  delete data from the table: "config"
  """
  delete_config(
    """filter the rows which have to be deleted"""
    where: config_bool_exp!
  ): config_mutation_response

  """
  delete single row from the table: "config"
  """
  delete_config_by_pk(id: Int!): config

  """
  delete data from the table: "dynamic_challenge"
  """
  delete_dynamic_challenge(
    """filter the rows which have to be deleted"""
    where: dynamic_challenge_bool_exp!
  ): dynamic_challenge_mutation_response

  """
  delete single row from the table: "dynamic_challenge"
  """
  delete_dynamic_challenge_by_pk(id: Int!): dynamic_challenge

  """
  delete data from the table: "field_entries"
  """
  delete_field_entries(
    """filter the rows which have to be deleted"""
    where: field_entries_bool_exp!
  ): field_entries_mutation_response

  """
  delete single row from the table: "field_entries"
  """
  delete_field_entries_by_pk(id: Int!): field_entries

  """
  delete data from the table: "fields"
  """
  delete_fields(
    """filter the rows which have to be deleted"""
    where: fields_bool_exp!
  ): fields_mutation_response

  """
  delete single row from the table: "fields"
  """
  delete_fields_by_pk(id: Int!): fields

  """
  delete data from the table: "files"
  """
  delete_files(
    """filter the rows which have to be deleted"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  delete single row from the table: "files"
  """
  delete_files_by_pk(id: Int!): files

  """
  delete data from the table: "flags"
  """
  delete_flags(
    """filter the rows which have to be deleted"""
    where: flags_bool_exp!
  ): flags_mutation_response

  """
  delete single row from the table: "flags"
  """
  delete_flags_by_pk(id: Int!): flags

  """
  delete data from the table: "hints"
  """
  delete_hints(
    """filter the rows which have to be deleted"""
    where: hints_bool_exp!
  ): hints_mutation_response

  """
  delete single row from the table: "hints"
  """
  delete_hints_by_pk(id: Int!): hints

  """
  delete data from the table: "hints_content"
  """
  delete_hints_content(
    """filter the rows which have to be deleted"""
    where: hints_content_bool_exp!
  ): hints_content_mutation_response

  """
  delete data from the table: "notifications"
  """
  delete_notifications(
    """filter the rows which have to be deleted"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  delete single row from the table: "notifications"
  """
  delete_notifications_by_pk(id: Int!): notifications

  """
  delete data from the table: "pages"
  """
  delete_pages(
    """filter the rows which have to be deleted"""
    where: pages_bool_exp!
  ): pages_mutation_response

  """
  delete single row from the table: "pages"
  """
  delete_pages_by_pk(id: Int!): pages

  """
  delete data from the table: "solves"
  """
  delete_solves(
    """filter the rows which have to be deleted"""
    where: solves_bool_exp!
  ): solves_mutation_response

  """
  delete single row from the table: "solves"
  """
  delete_solves_by_pk(id: Int!): solves

  """
  delete data from the table: "submissions"
  """
  delete_submissions(
    """filter the rows which have to be deleted"""
    where: submissions_bool_exp!
  ): submissions_mutation_response

  """
  delete single row from the table: "submissions"
  """
  delete_submissions_by_pk(id: Int!): submissions

  """
  delete data from the table: "tags"
  """
  delete_tags(
    """filter the rows which have to be deleted"""
    where: tags_bool_exp!
  ): tags_mutation_response

  """
  delete single row from the table: "tags"
  """
  delete_tags_by_pk(id: Int!): tags

  """
  delete data from the table: "teams"
  """
  delete_teams(
    """filter the rows which have to be deleted"""
    where: teams_bool_exp!
  ): teams_mutation_response

  """
  delete single row from the table: "teams"
  """
  delete_teams_by_pk(id: Int!): teams

  """
  delete data from the table: "tokens"
  """
  delete_tokens(
    """filter the rows which have to be deleted"""
    where: tokens_bool_exp!
  ): tokens_mutation_response

  """
  delete single row from the table: "tokens"
  """
  delete_tokens_by_pk(id: Int!): tokens

  """
  delete data from the table: "tracking"
  """
  delete_tracking(
    """filter the rows which have to be deleted"""
    where: tracking_bool_exp!
  ): tracking_mutation_response

  """
  delete single row from the table: "tracking"
  """
  delete_tracking_by_pk(id: Int!): tracking

  """
  delete data from the table: "unlocks"
  """
  delete_unlocks(
    """filter the rows which have to be deleted"""
    where: unlocks_bool_exp!
  ): unlocks_mutation_response

  """
  delete single row from the table: "unlocks"
  """
  delete_unlocks_by_pk(id: Int!): unlocks

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: Int!): users

  """
  insert data into the table: "awards"
  """
  insert_awards(
    """the rows to be inserted"""
    objects: [awards_insert_input!]!

    """upsert condition"""
    on_conflict: awards_on_conflict
  ): awards_mutation_response

  """
  insert a single row into the table: "awards"
  """
  insert_awards_one(
    """the row to be inserted"""
    object: awards_insert_input!

    """upsert condition"""
    on_conflict: awards_on_conflict
  ): awards

  """
  insert data into the table: "challenges"
  """
  insert_challenges(
    """the rows to be inserted"""
    objects: [challenges_insert_input!]!

    """upsert condition"""
    on_conflict: challenges_on_conflict
  ): challenges_mutation_response

  """
  insert a single row into the table: "challenges"
  """
  insert_challenges_one(
    """the row to be inserted"""
    object: challenges_insert_input!

    """upsert condition"""
    on_conflict: challenges_on_conflict
  ): challenges

  """
  insert data into the table: "comments"
  """
  insert_comments(
    """the rows to be inserted"""
    objects: [comments_insert_input!]!

    """upsert condition"""
    on_conflict: comments_on_conflict
  ): comments_mutation_response

  """
  insert a single row into the table: "comments"
  """
  insert_comments_one(
    """the row to be inserted"""
    object: comments_insert_input!

    """upsert condition"""
    on_conflict: comments_on_conflict
  ): comments

  """
  insert data into the table: "config"
  """
  insert_config(
    """the rows to be inserted"""
    objects: [config_insert_input!]!

    """upsert condition"""
    on_conflict: config_on_conflict
  ): config_mutation_response

  """
  insert a single row into the table: "config"
  """
  insert_config_one(
    """the row to be inserted"""
    object: config_insert_input!

    """upsert condition"""
    on_conflict: config_on_conflict
  ): config

  """
  insert data into the table: "dynamic_challenge"
  """
  insert_dynamic_challenge(
    """the rows to be inserted"""
    objects: [dynamic_challenge_insert_input!]!

    """upsert condition"""
    on_conflict: dynamic_challenge_on_conflict
  ): dynamic_challenge_mutation_response

  """
  insert a single row into the table: "dynamic_challenge"
  """
  insert_dynamic_challenge_one(
    """the row to be inserted"""
    object: dynamic_challenge_insert_input!

    """upsert condition"""
    on_conflict: dynamic_challenge_on_conflict
  ): dynamic_challenge

  """
  insert data into the table: "field_entries"
  """
  insert_field_entries(
    """the rows to be inserted"""
    objects: [field_entries_insert_input!]!

    """upsert condition"""
    on_conflict: field_entries_on_conflict
  ): field_entries_mutation_response

  """
  insert a single row into the table: "field_entries"
  """
  insert_field_entries_one(
    """the row to be inserted"""
    object: field_entries_insert_input!

    """upsert condition"""
    on_conflict: field_entries_on_conflict
  ): field_entries

  """
  insert data into the table: "fields"
  """
  insert_fields(
    """the rows to be inserted"""
    objects: [fields_insert_input!]!

    """upsert condition"""
    on_conflict: fields_on_conflict
  ): fields_mutation_response

  """
  insert a single row into the table: "fields"
  """
  insert_fields_one(
    """the row to be inserted"""
    object: fields_insert_input!

    """upsert condition"""
    on_conflict: fields_on_conflict
  ): fields

  """
  insert data into the table: "files"
  """
  insert_files(
    """the rows to be inserted"""
    objects: [files_insert_input!]!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files_mutation_response

  """
  insert a single row into the table: "files"
  """
  insert_files_one(
    """the row to be inserted"""
    object: files_insert_input!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files

  """
  insert data into the table: "flags"
  """
  insert_flags(
    """the rows to be inserted"""
    objects: [flags_insert_input!]!

    """upsert condition"""
    on_conflict: flags_on_conflict
  ): flags_mutation_response

  """
  insert a single row into the table: "flags"
  """
  insert_flags_one(
    """the row to be inserted"""
    object: flags_insert_input!

    """upsert condition"""
    on_conflict: flags_on_conflict
  ): flags

  """
  insert data into the table: "hints"
  """
  insert_hints(
    """the rows to be inserted"""
    objects: [hints_insert_input!]!

    """upsert condition"""
    on_conflict: hints_on_conflict
  ): hints_mutation_response

  """
  insert data into the table: "hints_content"
  """
  insert_hints_content(
    """the rows to be inserted"""
    objects: [hints_content_insert_input!]!
  ): hints_content_mutation_response

  """
  insert a single row into the table: "hints_content"
  """
  insert_hints_content_one(
    """the row to be inserted"""
    object: hints_content_insert_input!
  ): hints_content

  """
  insert a single row into the table: "hints"
  """
  insert_hints_one(
    """the row to be inserted"""
    object: hints_insert_input!

    """upsert condition"""
    on_conflict: hints_on_conflict
  ): hints

  """
  insert data into the table: "notifications"
  """
  insert_notifications(
    """the rows to be inserted"""
    objects: [notifications_insert_input!]!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications_mutation_response

  """
  insert a single row into the table: "notifications"
  """
  insert_notifications_one(
    """the row to be inserted"""
    object: notifications_insert_input!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications

  """
  insert data into the table: "pages"
  """
  insert_pages(
    """the rows to be inserted"""
    objects: [pages_insert_input!]!

    """upsert condition"""
    on_conflict: pages_on_conflict
  ): pages_mutation_response

  """
  insert a single row into the table: "pages"
  """
  insert_pages_one(
    """the row to be inserted"""
    object: pages_insert_input!

    """upsert condition"""
    on_conflict: pages_on_conflict
  ): pages

  """
  insert data into the table: "solves"
  """
  insert_solves(
    """the rows to be inserted"""
    objects: [solves_insert_input!]!

    """upsert condition"""
    on_conflict: solves_on_conflict
  ): solves_mutation_response

  """
  insert a single row into the table: "solves"
  """
  insert_solves_one(
    """the row to be inserted"""
    object: solves_insert_input!

    """upsert condition"""
    on_conflict: solves_on_conflict
  ): solves

  """
  insert data into the table: "submissions"
  """
  insert_submissions(
    """the rows to be inserted"""
    objects: [submissions_insert_input!]!

    """upsert condition"""
    on_conflict: submissions_on_conflict
  ): submissions_mutation_response

  """
  insert a single row into the table: "submissions"
  """
  insert_submissions_one(
    """the row to be inserted"""
    object: submissions_insert_input!

    """upsert condition"""
    on_conflict: submissions_on_conflict
  ): submissions

  """
  insert data into the table: "tags"
  """
  insert_tags(
    """the rows to be inserted"""
    objects: [tags_insert_input!]!

    """upsert condition"""
    on_conflict: tags_on_conflict
  ): tags_mutation_response

  """
  insert a single row into the table: "tags"
  """
  insert_tags_one(
    """the row to be inserted"""
    object: tags_insert_input!

    """upsert condition"""
    on_conflict: tags_on_conflict
  ): tags

  """
  insert data into the table: "teams"
  """
  insert_teams(
    """the rows to be inserted"""
    objects: [teams_insert_input!]!

    """upsert condition"""
    on_conflict: teams_on_conflict
  ): teams_mutation_response

  """
  insert a single row into the table: "teams"
  """
  insert_teams_one(
    """the row to be inserted"""
    object: teams_insert_input!

    """upsert condition"""
    on_conflict: teams_on_conflict
  ): teams

  """
  insert data into the table: "tokens"
  """
  insert_tokens(
    """the rows to be inserted"""
    objects: [tokens_insert_input!]!

    """upsert condition"""
    on_conflict: tokens_on_conflict
  ): tokens_mutation_response

  """
  insert a single row into the table: "tokens"
  """
  insert_tokens_one(
    """the row to be inserted"""
    object: tokens_insert_input!

    """upsert condition"""
    on_conflict: tokens_on_conflict
  ): tokens

  """
  insert data into the table: "tracking"
  """
  insert_tracking(
    """the rows to be inserted"""
    objects: [tracking_insert_input!]!

    """upsert condition"""
    on_conflict: tracking_on_conflict
  ): tracking_mutation_response

  """
  insert a single row into the table: "tracking"
  """
  insert_tracking_one(
    """the row to be inserted"""
    object: tracking_insert_input!

    """upsert condition"""
    on_conflict: tracking_on_conflict
  ): tracking

  """
  insert data into the table: "unlocks"
  """
  insert_unlocks(
    """the rows to be inserted"""
    objects: [unlocks_insert_input!]!

    """upsert condition"""
    on_conflict: unlocks_on_conflict
  ): unlocks_mutation_response

  """
  insert a single row into the table: "unlocks"
  """
  insert_unlocks_one(
    """the row to be inserted"""
    object: unlocks_insert_input!

    """upsert condition"""
    on_conflict: unlocks_on_conflict
  ): unlocks

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  update data of the table: "awards"
  """
  update_awards(
    """increments the numeric columns with given value of the filtered values"""
    _inc: awards_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: awards_set_input

    """filter the rows which have to be updated"""
    where: awards_bool_exp!
  ): awards_mutation_response

  """
  update single row of the table: "awards"
  """
  update_awards_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: awards_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: awards_set_input
    pk_columns: awards_pk_columns_input!
  ): awards

  """
  update data of the table: "challenges"
  """
  update_challenges(
    """increments the numeric columns with given value of the filtered values"""
    _inc: challenges_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: challenges_set_input

    """filter the rows which have to be updated"""
    where: challenges_bool_exp!
  ): challenges_mutation_response

  """
  update single row of the table: "challenges"
  """
  update_challenges_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: challenges_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: challenges_set_input
    pk_columns: challenges_pk_columns_input!
  ): challenges

  """
  update data of the table: "comments"
  """
  update_comments(
    """increments the numeric columns with given value of the filtered values"""
    _inc: comments_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: comments_set_input

    """filter the rows which have to be updated"""
    where: comments_bool_exp!
  ): comments_mutation_response

  """
  update single row of the table: "comments"
  """
  update_comments_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: comments_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: comments_set_input
    pk_columns: comments_pk_columns_input!
  ): comments

  """
  update data of the table: "config"
  """
  update_config(
    """increments the numeric columns with given value of the filtered values"""
    _inc: config_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: config_set_input

    """filter the rows which have to be updated"""
    where: config_bool_exp!
  ): config_mutation_response

  """
  update single row of the table: "config"
  """
  update_config_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: config_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: config_set_input
    pk_columns: config_pk_columns_input!
  ): config

  """
  update data of the table: "dynamic_challenge"
  """
  update_dynamic_challenge(
    """increments the numeric columns with given value of the filtered values"""
    _inc: dynamic_challenge_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: dynamic_challenge_set_input

    """filter the rows which have to be updated"""
    where: dynamic_challenge_bool_exp!
  ): dynamic_challenge_mutation_response

  """
  update single row of the table: "dynamic_challenge"
  """
  update_dynamic_challenge_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: dynamic_challenge_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: dynamic_challenge_set_input
    pk_columns: dynamic_challenge_pk_columns_input!
  ): dynamic_challenge

  """
  update data of the table: "field_entries"
  """
  update_field_entries(
    """increments the numeric columns with given value of the filtered values"""
    _inc: field_entries_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: field_entries_set_input

    """filter the rows which have to be updated"""
    where: field_entries_bool_exp!
  ): field_entries_mutation_response

  """
  update single row of the table: "field_entries"
  """
  update_field_entries_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: field_entries_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: field_entries_set_input
    pk_columns: field_entries_pk_columns_input!
  ): field_entries

  """
  update data of the table: "fields"
  """
  update_fields(
    """increments the numeric columns with given value of the filtered values"""
    _inc: fields_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: fields_set_input

    """filter the rows which have to be updated"""
    where: fields_bool_exp!
  ): fields_mutation_response

  """
  update single row of the table: "fields"
  """
  update_fields_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: fields_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: fields_set_input
    pk_columns: fields_pk_columns_input!
  ): fields

  """
  update data of the table: "files"
  """
  update_files(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input

    """filter the rows which have to be updated"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  update single row of the table: "files"
  """
  update_files_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input
    pk_columns: files_pk_columns_input!
  ): files

  """
  update data of the table: "flags"
  """
  update_flags(
    """increments the numeric columns with given value of the filtered values"""
    _inc: flags_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: flags_set_input

    """filter the rows which have to be updated"""
    where: flags_bool_exp!
  ): flags_mutation_response

  """
  update single row of the table: "flags"
  """
  update_flags_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: flags_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: flags_set_input
    pk_columns: flags_pk_columns_input!
  ): flags

  """
  update data of the table: "hints"
  """
  update_hints(
    """increments the numeric columns with given value of the filtered values"""
    _inc: hints_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: hints_set_input

    """filter the rows which have to be updated"""
    where: hints_bool_exp!
  ): hints_mutation_response

  """
  update single row of the table: "hints"
  """
  update_hints_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: hints_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: hints_set_input
    pk_columns: hints_pk_columns_input!
  ): hints

  """
  update data of the table: "hints_content"
  """
  update_hints_content(
    """increments the numeric columns with given value of the filtered values"""
    _inc: hints_content_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: hints_content_set_input

    """filter the rows which have to be updated"""
    where: hints_content_bool_exp!
  ): hints_content_mutation_response

  """
  update data of the table: "notifications"
  """
  update_notifications(
    """increments the numeric columns with given value of the filtered values"""
    _inc: notifications_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input

    """filter the rows which have to be updated"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  update single row of the table: "notifications"
  """
  update_notifications_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: notifications_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input
    pk_columns: notifications_pk_columns_input!
  ): notifications

  """
  update data of the table: "pages"
  """
  update_pages(
    """increments the numeric columns with given value of the filtered values"""
    _inc: pages_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: pages_set_input

    """filter the rows which have to be updated"""
    where: pages_bool_exp!
  ): pages_mutation_response

  """
  update single row of the table: "pages"
  """
  update_pages_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: pages_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: pages_set_input
    pk_columns: pages_pk_columns_input!
  ): pages

  """
  update data of the table: "solves"
  """
  update_solves(
    """increments the numeric columns with given value of the filtered values"""
    _inc: solves_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: solves_set_input

    """filter the rows which have to be updated"""
    where: solves_bool_exp!
  ): solves_mutation_response

  """
  update single row of the table: "solves"
  """
  update_solves_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: solves_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: solves_set_input
    pk_columns: solves_pk_columns_input!
  ): solves

  """
  update data of the table: "submissions"
  """
  update_submissions(
    """increments the numeric columns with given value of the filtered values"""
    _inc: submissions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: submissions_set_input

    """filter the rows which have to be updated"""
    where: submissions_bool_exp!
  ): submissions_mutation_response

  """
  update single row of the table: "submissions"
  """
  update_submissions_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: submissions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: submissions_set_input
    pk_columns: submissions_pk_columns_input!
  ): submissions

  """
  update data of the table: "tags"
  """
  update_tags(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tags_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tags_set_input

    """filter the rows which have to be updated"""
    where: tags_bool_exp!
  ): tags_mutation_response

  """
  update single row of the table: "tags"
  """
  update_tags_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tags_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tags_set_input
    pk_columns: tags_pk_columns_input!
  ): tags

  """
  update data of the table: "teams"
  """
  update_teams(
    """increments the numeric columns with given value of the filtered values"""
    _inc: teams_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: teams_set_input

    """filter the rows which have to be updated"""
    where: teams_bool_exp!
  ): teams_mutation_response

  """
  update single row of the table: "teams"
  """
  update_teams_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: teams_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: teams_set_input
    pk_columns: teams_pk_columns_input!
  ): teams

  """
  update data of the table: "tokens"
  """
  update_tokens(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tokens_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tokens_set_input

    """filter the rows which have to be updated"""
    where: tokens_bool_exp!
  ): tokens_mutation_response

  """
  update single row of the table: "tokens"
  """
  update_tokens_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tokens_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tokens_set_input
    pk_columns: tokens_pk_columns_input!
  ): tokens

  """
  update data of the table: "tracking"
  """
  update_tracking(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tracking_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tracking_set_input

    """filter the rows which have to be updated"""
    where: tracking_bool_exp!
  ): tracking_mutation_response

  """
  update single row of the table: "tracking"
  """
  update_tracking_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tracking_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tracking_set_input
    pk_columns: tracking_pk_columns_input!
  ): tracking

  """
  update data of the table: "unlocks"
  """
  update_unlocks(
    """increments the numeric columns with given value of the filtered values"""
    _inc: unlocks_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: unlocks_set_input

    """filter the rows which have to be updated"""
    where: unlocks_bool_exp!
  ): unlocks_mutation_response

  """
  update single row of the table: "unlocks"
  """
  update_unlocks_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: unlocks_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: unlocks_set_input
    pk_columns: unlocks_pk_columns_input!
  ): unlocks

  """
  update data of the table: "users"
  """
  update_users(
    """increments the numeric columns with given value of the filtered values"""
    _inc: users_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: users_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users
}

"""
columns and relationships of "notifications"
"""
type notifications {
  content: String
  date: timestamp
  id: Int!

  """An object relationship"""
  team: teams
  team_id: Int
  title: String

  """An object relationship"""
  user: users
  user_id: Int
}

"""
aggregated selection of "notifications"
"""
type notifications_aggregate {
  aggregate: notifications_aggregate_fields
  nodes: [notifications!]!
}

"""
aggregate fields of "notifications"
"""
type notifications_aggregate_fields {
  avg: notifications_avg_fields
  count(columns: [notifications_select_column!], distinct: Boolean): Int!
  max: notifications_max_fields
  min: notifications_min_fields
  stddev: notifications_stddev_fields
  stddev_pop: notifications_stddev_pop_fields
  stddev_samp: notifications_stddev_samp_fields
  sum: notifications_sum_fields
  var_pop: notifications_var_pop_fields
  var_samp: notifications_var_samp_fields
  variance: notifications_variance_fields
}

"""
order by aggregate values of table "notifications"
"""
input notifications_aggregate_order_by {
  avg: notifications_avg_order_by
  count: order_by
  max: notifications_max_order_by
  min: notifications_min_order_by
  stddev: notifications_stddev_order_by
  stddev_pop: notifications_stddev_pop_order_by
  stddev_samp: notifications_stddev_samp_order_by
  sum: notifications_sum_order_by
  var_pop: notifications_var_pop_order_by
  var_samp: notifications_var_samp_order_by
  variance: notifications_variance_order_by
}

"""
input type for inserting array relation for remote table "notifications"
"""
input notifications_arr_rel_insert_input {
  data: [notifications_insert_input!]!

  """upsert condition"""
  on_conflict: notifications_on_conflict
}

"""aggregate avg on columns"""
type notifications_avg_fields {
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by avg() on columns of table "notifications"
"""
input notifications_avg_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "notifications". All fields are combined with a logical 'AND'.
"""
input notifications_bool_exp {
  _and: [notifications_bool_exp!]
  _not: notifications_bool_exp
  _or: [notifications_bool_exp!]
  content: String_comparison_exp
  date: timestamp_comparison_exp
  id: Int_comparison_exp
  team: teams_bool_exp
  team_id: Int_comparison_exp
  title: String_comparison_exp
  user: users_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "notifications"
"""
enum notifications_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notifications_pkey
}

"""
input type for incrementing numeric columns in table "notifications"
"""
input notifications_inc_input {
  id: Int
  team_id: Int
  user_id: Int
}

"""
input type for inserting data into table "notifications"
"""
input notifications_insert_input {
  content: String
  date: timestamp
  id: Int
  team: teams_obj_rel_insert_input
  team_id: Int
  title: String
  user: users_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type notifications_max_fields {
  content: String
  date: timestamp
  id: Int
  team_id: Int
  title: String
  user_id: Int
}

"""
order by max() on columns of table "notifications"
"""
input notifications_max_order_by {
  content: order_by
  date: order_by
  id: order_by
  team_id: order_by
  title: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type notifications_min_fields {
  content: String
  date: timestamp
  id: Int
  team_id: Int
  title: String
  user_id: Int
}

"""
order by min() on columns of table "notifications"
"""
input notifications_min_order_by {
  content: order_by
  date: order_by
  id: order_by
  team_id: order_by
  title: order_by
  user_id: order_by
}

"""
response of any mutation on the table "notifications"
"""
type notifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notifications!]!
}

"""
on_conflict condition type for table "notifications"
"""
input notifications_on_conflict {
  constraint: notifications_constraint!
  update_columns: [notifications_update_column!]! = []
  where: notifications_bool_exp
}

"""Ordering options when selecting data from "notifications"."""
input notifications_order_by {
  content: order_by
  date: order_by
  id: order_by
  team: teams_order_by
  team_id: order_by
  title: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: notifications"""
input notifications_pk_columns_input {
  id: Int!
}

"""
select columns of table "notifications"
"""
enum notifications_select_column {
  """column name"""
  content

  """column name"""
  date

  """column name"""
  id

  """column name"""
  team_id

  """column name"""
  title

  """column name"""
  user_id
}

"""
input type for updating data in table "notifications"
"""
input notifications_set_input {
  content: String
  date: timestamp
  id: Int
  team_id: Int
  title: String
  user_id: Int
}

"""aggregate stddev on columns"""
type notifications_stddev_fields {
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "notifications"
"""
input notifications_stddev_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type notifications_stddev_pop_fields {
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "notifications"
"""
input notifications_stddev_pop_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type notifications_stddev_samp_fields {
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "notifications"
"""
input notifications_stddev_samp_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate sum on columns"""
type notifications_sum_fields {
  id: Int
  team_id: Int
  user_id: Int
}

"""
order by sum() on columns of table "notifications"
"""
input notifications_sum_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""
update columns of table "notifications"
"""
enum notifications_update_column {
  """column name"""
  content

  """column name"""
  date

  """column name"""
  id

  """column name"""
  team_id

  """column name"""
  title

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type notifications_var_pop_fields {
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "notifications"
"""
input notifications_var_pop_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type notifications_var_samp_fields {
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "notifications"
"""
input notifications_var_samp_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type notifications_variance_fields {
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by variance() on columns of table "notifications"
"""
input notifications_variance_order_by {
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "pages"
"""
type pages {
  auth_required: Boolean

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): [comments!]!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): comments_aggregate!
  content: String
  draft: Boolean
  format: String
  hidden: Boolean
  id: Int!
  route: String
  title: String
}

"""
aggregated selection of "pages"
"""
type pages_aggregate {
  aggregate: pages_aggregate_fields
  nodes: [pages!]!
}

"""
aggregate fields of "pages"
"""
type pages_aggregate_fields {
  avg: pages_avg_fields
  count(columns: [pages_select_column!], distinct: Boolean): Int!
  max: pages_max_fields
  min: pages_min_fields
  stddev: pages_stddev_fields
  stddev_pop: pages_stddev_pop_fields
  stddev_samp: pages_stddev_samp_fields
  sum: pages_sum_fields
  var_pop: pages_var_pop_fields
  var_samp: pages_var_samp_fields
  variance: pages_variance_fields
}

"""aggregate avg on columns"""
type pages_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "pages". All fields are combined with a logical 'AND'.
"""
input pages_bool_exp {
  _and: [pages_bool_exp!]
  _not: pages_bool_exp
  _or: [pages_bool_exp!]
  auth_required: Boolean_comparison_exp
  comments: comments_bool_exp
  content: String_comparison_exp
  draft: Boolean_comparison_exp
  format: String_comparison_exp
  hidden: Boolean_comparison_exp
  id: Int_comparison_exp
  route: String_comparison_exp
  title: String_comparison_exp
}

"""
unique or primary key constraints on table "pages"
"""
enum pages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  pages_pkey

  """
  unique or primary key constraint on columns "route"
  """
  pages_route_key
}

"""
input type for incrementing numeric columns in table "pages"
"""
input pages_inc_input {
  id: Int
}

"""
input type for inserting data into table "pages"
"""
input pages_insert_input {
  auth_required: Boolean
  comments: comments_arr_rel_insert_input
  content: String
  draft: Boolean
  format: String
  hidden: Boolean
  id: Int
  route: String
  title: String
}

"""aggregate max on columns"""
type pages_max_fields {
  content: String
  format: String
  id: Int
  route: String
  title: String
}

"""aggregate min on columns"""
type pages_min_fields {
  content: String
  format: String
  id: Int
  route: String
  title: String
}

"""
response of any mutation on the table "pages"
"""
type pages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [pages!]!
}

"""
input type for inserting object relation for remote table "pages"
"""
input pages_obj_rel_insert_input {
  data: pages_insert_input!

  """upsert condition"""
  on_conflict: pages_on_conflict
}

"""
on_conflict condition type for table "pages"
"""
input pages_on_conflict {
  constraint: pages_constraint!
  update_columns: [pages_update_column!]! = []
  where: pages_bool_exp
}

"""Ordering options when selecting data from "pages"."""
input pages_order_by {
  auth_required: order_by
  comments_aggregate: comments_aggregate_order_by
  content: order_by
  draft: order_by
  format: order_by
  hidden: order_by
  id: order_by
  route: order_by
  title: order_by
}

"""primary key columns input for table: pages"""
input pages_pk_columns_input {
  id: Int!
}

"""
select columns of table "pages"
"""
enum pages_select_column {
  """column name"""
  auth_required

  """column name"""
  content

  """column name"""
  draft

  """column name"""
  format

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  route

  """column name"""
  title
}

"""
input type for updating data in table "pages"
"""
input pages_set_input {
  auth_required: Boolean
  content: String
  draft: Boolean
  format: String
  hidden: Boolean
  id: Int
  route: String
  title: String
}

"""aggregate stddev on columns"""
type pages_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type pages_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type pages_stddev_samp_fields {
  id: Float
}

"""aggregate sum on columns"""
type pages_sum_fields {
  id: Int
}

"""
update columns of table "pages"
"""
enum pages_update_column {
  """column name"""
  auth_required

  """column name"""
  content

  """column name"""
  draft

  """column name"""
  format

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  route

  """column name"""
  title
}

"""aggregate var_pop on columns"""
type pages_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type pages_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type pages_variance_fields {
  id: Float
}

type query_root {
  """An array relationship"""
  awards(
    """distinct select on columns"""
    distinct_on: [awards_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [awards_order_by!]

    """filter the rows returned"""
    where: awards_bool_exp
  ): [awards!]!

  """An aggregate relationship"""
  awards_aggregate(
    """distinct select on columns"""
    distinct_on: [awards_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [awards_order_by!]

    """filter the rows returned"""
    where: awards_bool_exp
  ): awards_aggregate!

  """fetch data from the table: "awards" using primary key columns"""
  awards_by_pk(id: Int!): awards

  """
  fetch data from the table: "challenges"
  """
  challenges(
    """distinct select on columns"""
    distinct_on: [challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenges_order_by!]

    """filter the rows returned"""
    where: challenges_bool_exp
  ): [challenges!]!

  """
  fetch aggregated fields from the table: "challenges"
  """
  challenges_aggregate(
    """distinct select on columns"""
    distinct_on: [challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenges_order_by!]

    """filter the rows returned"""
    where: challenges_bool_exp
  ): challenges_aggregate!

  """fetch data from the table: "challenges" using primary key columns"""
  challenges_by_pk(id: Int!): challenges

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): [comments!]!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): comments_aggregate!

  """fetch data from the table: "comments" using primary key columns"""
  comments_by_pk(id: Int!): comments

  """
  fetch data from the table: "config"
  """
  config(
    """distinct select on columns"""
    distinct_on: [config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [config_order_by!]

    """filter the rows returned"""
    where: config_bool_exp
  ): [config!]!

  """
  fetch aggregated fields from the table: "config"
  """
  config_aggregate(
    """distinct select on columns"""
    distinct_on: [config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [config_order_by!]

    """filter the rows returned"""
    where: config_bool_exp
  ): config_aggregate!

  """fetch data from the table: "config" using primary key columns"""
  config_by_pk(id: Int!): config

  """
  execute function "current_user" which returns "users"
  """
  current_user(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  execute function "current_user" and query aggregates on result of table type "users"
  """
  current_user_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table: "dynamic_challenge"
  """
  dynamic_challenge(
    """distinct select on columns"""
    distinct_on: [dynamic_challenge_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_challenge_order_by!]

    """filter the rows returned"""
    where: dynamic_challenge_bool_exp
  ): [dynamic_challenge!]!

  """
  fetch aggregated fields from the table: "dynamic_challenge"
  """
  dynamic_challenge_aggregate(
    """distinct select on columns"""
    distinct_on: [dynamic_challenge_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_challenge_order_by!]

    """filter the rows returned"""
    where: dynamic_challenge_bool_exp
  ): dynamic_challenge_aggregate!

  """
  fetch data from the table: "dynamic_challenge" using primary key columns
  """
  dynamic_challenge_by_pk(id: Int!): dynamic_challenge

  """An array relationship"""
  field_entries(
    """distinct select on columns"""
    distinct_on: [field_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entries_order_by!]

    """filter the rows returned"""
    where: field_entries_bool_exp
  ): [field_entries!]!

  """An aggregate relationship"""
  field_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [field_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entries_order_by!]

    """filter the rows returned"""
    where: field_entries_bool_exp
  ): field_entries_aggregate!

  """fetch data from the table: "field_entries" using primary key columns"""
  field_entries_by_pk(id: Int!): field_entries

  """
  fetch data from the table: "fields"
  """
  fields(
    """distinct select on columns"""
    distinct_on: [fields_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fields_order_by!]

    """filter the rows returned"""
    where: fields_bool_exp
  ): [fields!]!

  """
  fetch aggregated fields from the table: "fields"
  """
  fields_aggregate(
    """distinct select on columns"""
    distinct_on: [fields_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fields_order_by!]

    """filter the rows returned"""
    where: fields_bool_exp
  ): fields_aggregate!

  """fetch data from the table: "fields" using primary key columns"""
  fields_by_pk(id: Int!): fields

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """fetch data from the table: "files" using primary key columns"""
  files_by_pk(id: Int!): files

  """An array relationship"""
  flags(
    """distinct select on columns"""
    distinct_on: [flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [flags_order_by!]

    """filter the rows returned"""
    where: flags_bool_exp
  ): [flags!]!

  """An aggregate relationship"""
  flags_aggregate(
    """distinct select on columns"""
    distinct_on: [flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [flags_order_by!]

    """filter the rows returned"""
    where: flags_bool_exp
  ): flags_aggregate!

  """fetch data from the table: "flags" using primary key columns"""
  flags_by_pk(id: Int!): flags

  """An array relationship"""
  hints(
    """distinct select on columns"""
    distinct_on: [hints_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_order_by!]

    """filter the rows returned"""
    where: hints_bool_exp
  ): [hints!]!

  """An aggregate relationship"""
  hints_aggregate(
    """distinct select on columns"""
    distinct_on: [hints_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_order_by!]

    """filter the rows returned"""
    where: hints_bool_exp
  ): hints_aggregate!

  """fetch data from the table: "hints" using primary key columns"""
  hints_by_pk(id: Int!): hints

  """
  fetch data from the table: "hints_content"
  """
  hints_content(
    """distinct select on columns"""
    distinct_on: [hints_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_content_order_by!]

    """filter the rows returned"""
    where: hints_content_bool_exp
  ): [hints_content!]!

  """
  fetch aggregated fields from the table: "hints_content"
  """
  hints_content_aggregate(
    """distinct select on columns"""
    distinct_on: [hints_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_content_order_by!]

    """filter the rows returned"""
    where: hints_content_bool_exp
  ): hints_content_aggregate!

  """
  fetch data from the table: "notifications"
  """
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """
  fetch aggregated fields from the table: "notifications"
  """
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: Int!): notifications

  """
  fetch data from the table: "pages"
  """
  pages(
    """distinct select on columns"""
    distinct_on: [pages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pages_order_by!]

    """filter the rows returned"""
    where: pages_bool_exp
  ): [pages!]!

  """
  fetch aggregated fields from the table: "pages"
  """
  pages_aggregate(
    """distinct select on columns"""
    distinct_on: [pages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pages_order_by!]

    """filter the rows returned"""
    where: pages_bool_exp
  ): pages_aggregate!

  """fetch data from the table: "pages" using primary key columns"""
  pages_by_pk(id: Int!): pages

  """
  fetch data from the table: "score_events"
  """
  score_events(
    """distinct select on columns"""
    distinct_on: [score_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_events_order_by!]

    """filter the rows returned"""
    where: score_events_bool_exp
  ): [score_events!]!

  """
  fetch aggregated fields from the table: "score_events"
  """
  score_events_aggregate(
    """distinct select on columns"""
    distinct_on: [score_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_events_order_by!]

    """filter the rows returned"""
    where: score_events_bool_exp
  ): score_events_aggregate!

  """An array relationship"""
  score_timeline(
    """distinct select on columns"""
    distinct_on: [score_timeline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_order_by!]

    """filter the rows returned"""
    where: score_timeline_bool_exp
  ): [score_timeline!]!

  """An aggregate relationship"""
  score_timeline_aggregate(
    """distinct select on columns"""
    distinct_on: [score_timeline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_order_by!]

    """filter the rows returned"""
    where: score_timeline_bool_exp
  ): score_timeline_aggregate!

  """
  fetch data from the table: "score_timeline_user"
  """
  score_timeline_user(
    """distinct select on columns"""
    distinct_on: [score_timeline_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_user_order_by!]

    """filter the rows returned"""
    where: score_timeline_user_bool_exp
  ): [score_timeline_user!]!

  """
  fetch aggregated fields from the table: "score_timeline_user"
  """
  score_timeline_user_aggregate(
    """distinct select on columns"""
    distinct_on: [score_timeline_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_user_order_by!]

    """filter the rows returned"""
    where: score_timeline_user_bool_exp
  ): score_timeline_user_aggregate!

  """
  fetch data from the table: "scoreboard"
  """
  scoreboard(
    """distinct select on columns"""
    distinct_on: [scoreboard_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_order_by!]

    """filter the rows returned"""
    where: scoreboard_bool_exp
  ): [scoreboard!]!

  """
  fetch aggregated fields from the table: "scoreboard"
  """
  scoreboard_aggregate(
    """distinct select on columns"""
    distinct_on: [scoreboard_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_order_by!]

    """filter the rows returned"""
    where: scoreboard_bool_exp
  ): scoreboard_aggregate!

  """
  fetch data from the table: "scoreboard_user"
  """
  scoreboard_user(
    """distinct select on columns"""
    distinct_on: [scoreboard_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_user_order_by!]

    """filter the rows returned"""
    where: scoreboard_user_bool_exp
  ): [scoreboard_user!]!

  """
  fetch aggregated fields from the table: "scoreboard_user"
  """
  scoreboard_user_aggregate(
    """distinct select on columns"""
    distinct_on: [scoreboard_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_user_order_by!]

    """filter the rows returned"""
    where: scoreboard_user_bool_exp
  ): scoreboard_user_aggregate!

  """An array relationship"""
  solves(
    """distinct select on columns"""
    distinct_on: [solves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solves_order_by!]

    """filter the rows returned"""
    where: solves_bool_exp
  ): [solves!]!

  """An aggregate relationship"""
  solves_aggregate(
    """distinct select on columns"""
    distinct_on: [solves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solves_order_by!]

    """filter the rows returned"""
    where: solves_bool_exp
  ): solves_aggregate!

  """fetch data from the table: "solves" using primary key columns"""
  solves_by_pk(id: Int!): solves

  """An array relationship"""
  submissions(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): [submissions!]!

  """An aggregate relationship"""
  submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): submissions_aggregate!

  """fetch data from the table: "submissions" using primary key columns"""
  submissions_by_pk(id: Int!): submissions

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): [tags!]!

  """An aggregate relationship"""
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): tags_aggregate!

  """fetch data from the table: "tags" using primary key columns"""
  tags_by_pk(id: Int!): tags

  """
  fetch data from the table: "teams"
  """
  teams(
    """distinct select on columns"""
    distinct_on: [teams_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teams_order_by!]

    """filter the rows returned"""
    where: teams_bool_exp
  ): [teams!]!

  """
  fetch aggregated fields from the table: "teams"
  """
  teams_aggregate(
    """distinct select on columns"""
    distinct_on: [teams_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teams_order_by!]

    """filter the rows returned"""
    where: teams_bool_exp
  ): teams_aggregate!

  """fetch data from the table: "teams" using primary key columns"""
  teams_by_pk(id: Int!): teams

  """An array relationship"""
  tokens(
    """distinct select on columns"""
    distinct_on: [tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_order_by!]

    """filter the rows returned"""
    where: tokens_bool_exp
  ): [tokens!]!

  """An aggregate relationship"""
  tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_order_by!]

    """filter the rows returned"""
    where: tokens_bool_exp
  ): tokens_aggregate!

  """fetch data from the table: "tokens" using primary key columns"""
  tokens_by_pk(id: Int!): tokens

  """
  fetch data from the table: "tracking"
  """
  tracking(
    """distinct select on columns"""
    distinct_on: [tracking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tracking_order_by!]

    """filter the rows returned"""
    where: tracking_bool_exp
  ): [tracking!]!

  """
  fetch aggregated fields from the table: "tracking"
  """
  tracking_aggregate(
    """distinct select on columns"""
    distinct_on: [tracking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tracking_order_by!]

    """filter the rows returned"""
    where: tracking_bool_exp
  ): tracking_aggregate!

  """fetch data from the table: "tracking" using primary key columns"""
  tracking_by_pk(id: Int!): tracking

  """An array relationship"""
  unlocks(
    """distinct select on columns"""
    distinct_on: [unlocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlocks_order_by!]

    """filter the rows returned"""
    where: unlocks_bool_exp
  ): [unlocks!]!

  """An aggregate relationship"""
  unlocks_aggregate(
    """distinct select on columns"""
    distinct_on: [unlocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlocks_order_by!]

    """filter the rows returned"""
    where: unlocks_bool_exp
  ): unlocks_aggregate!

  """fetch data from the table: "unlocks" using primary key columns"""
  unlocks_by_pk(id: Int!): unlocks

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: Int!): users
}

"""
columns and relationships of "score_events"
"""
type score_events {
  event_time: timestamp
  event_value: Int
  team_id: Int
  user_id: Int
}

"""
aggregated selection of "score_events"
"""
type score_events_aggregate {
  aggregate: score_events_aggregate_fields
  nodes: [score_events!]!
}

"""
aggregate fields of "score_events"
"""
type score_events_aggregate_fields {
  avg: score_events_avg_fields
  count(columns: [score_events_select_column!], distinct: Boolean): Int!
  max: score_events_max_fields
  min: score_events_min_fields
  stddev: score_events_stddev_fields
  stddev_pop: score_events_stddev_pop_fields
  stddev_samp: score_events_stddev_samp_fields
  sum: score_events_sum_fields
  var_pop: score_events_var_pop_fields
  var_samp: score_events_var_samp_fields
  variance: score_events_variance_fields
}

"""aggregate avg on columns"""
type score_events_avg_fields {
  event_value: Float
  team_id: Float
  user_id: Float
}

"""
Boolean expression to filter rows from the table "score_events". All fields are combined with a logical 'AND'.
"""
input score_events_bool_exp {
  _and: [score_events_bool_exp!]
  _not: score_events_bool_exp
  _or: [score_events_bool_exp!]
  event_time: timestamp_comparison_exp
  event_value: Int_comparison_exp
  team_id: Int_comparison_exp
  user_id: Int_comparison_exp
}

"""aggregate max on columns"""
type score_events_max_fields {
  event_time: timestamp
  event_value: Int
  team_id: Int
  user_id: Int
}

"""aggregate min on columns"""
type score_events_min_fields {
  event_time: timestamp
  event_value: Int
  team_id: Int
  user_id: Int
}

"""Ordering options when selecting data from "score_events"."""
input score_events_order_by {
  event_time: order_by
  event_value: order_by
  team_id: order_by
  user_id: order_by
}

"""
select columns of table "score_events"
"""
enum score_events_select_column {
  """column name"""
  event_time

  """column name"""
  event_value

  """column name"""
  team_id

  """column name"""
  user_id
}

"""aggregate stddev on columns"""
type score_events_stddev_fields {
  event_value: Float
  team_id: Float
  user_id: Float
}

"""aggregate stddev_pop on columns"""
type score_events_stddev_pop_fields {
  event_value: Float
  team_id: Float
  user_id: Float
}

"""aggregate stddev_samp on columns"""
type score_events_stddev_samp_fields {
  event_value: Float
  team_id: Float
  user_id: Float
}

"""aggregate sum on columns"""
type score_events_sum_fields {
  event_value: Int
  team_id: Int
  user_id: Int
}

"""aggregate var_pop on columns"""
type score_events_var_pop_fields {
  event_value: Float
  team_id: Float
  user_id: Float
}

"""aggregate var_samp on columns"""
type score_events_var_samp_fields {
  event_value: Float
  team_id: Float
  user_id: Float
}

"""aggregate variance on columns"""
type score_events_variance_fields {
  event_value: Float
  team_id: Float
  user_id: Float
}

"""
columns and relationships of "score_timeline"
"""
type score_timeline {
  event_time: timestamp
  score: bigint

  """An object relationship"""
  team: teams
  team_id: Int
}

"""
aggregated selection of "score_timeline"
"""
type score_timeline_aggregate {
  aggregate: score_timeline_aggregate_fields
  nodes: [score_timeline!]!
}

"""
aggregate fields of "score_timeline"
"""
type score_timeline_aggregate_fields {
  avg: score_timeline_avg_fields
  count(columns: [score_timeline_select_column!], distinct: Boolean): Int!
  max: score_timeline_max_fields
  min: score_timeline_min_fields
  stddev: score_timeline_stddev_fields
  stddev_pop: score_timeline_stddev_pop_fields
  stddev_samp: score_timeline_stddev_samp_fields
  sum: score_timeline_sum_fields
  var_pop: score_timeline_var_pop_fields
  var_samp: score_timeline_var_samp_fields
  variance: score_timeline_variance_fields
}

"""
order by aggregate values of table "score_timeline"
"""
input score_timeline_aggregate_order_by {
  avg: score_timeline_avg_order_by
  count: order_by
  max: score_timeline_max_order_by
  min: score_timeline_min_order_by
  stddev: score_timeline_stddev_order_by
  stddev_pop: score_timeline_stddev_pop_order_by
  stddev_samp: score_timeline_stddev_samp_order_by
  sum: score_timeline_sum_order_by
  var_pop: score_timeline_var_pop_order_by
  var_samp: score_timeline_var_samp_order_by
  variance: score_timeline_variance_order_by
}

"""
input type for inserting array relation for remote table "score_timeline"
"""
input score_timeline_arr_rel_insert_input {
  data: [score_timeline_insert_input!]!
}

"""aggregate avg on columns"""
type score_timeline_avg_fields {
  score: Float
  team_id: Float
}

"""
order by avg() on columns of table "score_timeline"
"""
input score_timeline_avg_order_by {
  score: order_by
  team_id: order_by
}

"""
Boolean expression to filter rows from the table "score_timeline". All fields are combined with a logical 'AND'.
"""
input score_timeline_bool_exp {
  _and: [score_timeline_bool_exp!]
  _not: score_timeline_bool_exp
  _or: [score_timeline_bool_exp!]
  event_time: timestamp_comparison_exp
  score: bigint_comparison_exp
  team: teams_bool_exp
  team_id: Int_comparison_exp
}

"""
input type for inserting data into table "score_timeline"
"""
input score_timeline_insert_input {
  event_time: timestamp
  score: bigint
  team: teams_obj_rel_insert_input
  team_id: Int
}

"""aggregate max on columns"""
type score_timeline_max_fields {
  event_time: timestamp
  score: bigint
  team_id: Int
}

"""
order by max() on columns of table "score_timeline"
"""
input score_timeline_max_order_by {
  event_time: order_by
  score: order_by
  team_id: order_by
}

"""aggregate min on columns"""
type score_timeline_min_fields {
  event_time: timestamp
  score: bigint
  team_id: Int
}

"""
order by min() on columns of table "score_timeline"
"""
input score_timeline_min_order_by {
  event_time: order_by
  score: order_by
  team_id: order_by
}

"""Ordering options when selecting data from "score_timeline"."""
input score_timeline_order_by {
  event_time: order_by
  score: order_by
  team: teams_order_by
  team_id: order_by
}

"""
select columns of table "score_timeline"
"""
enum score_timeline_select_column {
  """column name"""
  event_time

  """column name"""
  score

  """column name"""
  team_id
}

"""aggregate stddev on columns"""
type score_timeline_stddev_fields {
  score: Float
  team_id: Float
}

"""
order by stddev() on columns of table "score_timeline"
"""
input score_timeline_stddev_order_by {
  score: order_by
  team_id: order_by
}

"""aggregate stddev_pop on columns"""
type score_timeline_stddev_pop_fields {
  score: Float
  team_id: Float
}

"""
order by stddev_pop() on columns of table "score_timeline"
"""
input score_timeline_stddev_pop_order_by {
  score: order_by
  team_id: order_by
}

"""aggregate stddev_samp on columns"""
type score_timeline_stddev_samp_fields {
  score: Float
  team_id: Float
}

"""
order by stddev_samp() on columns of table "score_timeline"
"""
input score_timeline_stddev_samp_order_by {
  score: order_by
  team_id: order_by
}

"""aggregate sum on columns"""
type score_timeline_sum_fields {
  score: bigint
  team_id: Int
}

"""
order by sum() on columns of table "score_timeline"
"""
input score_timeline_sum_order_by {
  score: order_by
  team_id: order_by
}

"""
columns and relationships of "score_timeline_user"
"""
type score_timeline_user {
  event_time: timestamp
  score: bigint

  """An object relationship"""
  team: teams
  team_id: Int
  user_id: Int
}

"""
aggregated selection of "score_timeline_user"
"""
type score_timeline_user_aggregate {
  aggregate: score_timeline_user_aggregate_fields
  nodes: [score_timeline_user!]!
}

"""
aggregate fields of "score_timeline_user"
"""
type score_timeline_user_aggregate_fields {
  avg: score_timeline_user_avg_fields
  count(columns: [score_timeline_user_select_column!], distinct: Boolean): Int!
  max: score_timeline_user_max_fields
  min: score_timeline_user_min_fields
  stddev: score_timeline_user_stddev_fields
  stddev_pop: score_timeline_user_stddev_pop_fields
  stddev_samp: score_timeline_user_stddev_samp_fields
  sum: score_timeline_user_sum_fields
  var_pop: score_timeline_user_var_pop_fields
  var_samp: score_timeline_user_var_samp_fields
  variance: score_timeline_user_variance_fields
}

"""
order by aggregate values of table "score_timeline_user"
"""
input score_timeline_user_aggregate_order_by {
  avg: score_timeline_user_avg_order_by
  count: order_by
  max: score_timeline_user_max_order_by
  min: score_timeline_user_min_order_by
  stddev: score_timeline_user_stddev_order_by
  stddev_pop: score_timeline_user_stddev_pop_order_by
  stddev_samp: score_timeline_user_stddev_samp_order_by
  sum: score_timeline_user_sum_order_by
  var_pop: score_timeline_user_var_pop_order_by
  var_samp: score_timeline_user_var_samp_order_by
  variance: score_timeline_user_variance_order_by
}

"""
input type for inserting array relation for remote table "score_timeline_user"
"""
input score_timeline_user_arr_rel_insert_input {
  data: [score_timeline_user_insert_input!]!
}

"""aggregate avg on columns"""
type score_timeline_user_avg_fields {
  score: Float
  team_id: Float
  user_id: Float
}

"""
order by avg() on columns of table "score_timeline_user"
"""
input score_timeline_user_avg_order_by {
  score: order_by
  team_id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "score_timeline_user". All fields are combined with a logical 'AND'.
"""
input score_timeline_user_bool_exp {
  _and: [score_timeline_user_bool_exp!]
  _not: score_timeline_user_bool_exp
  _or: [score_timeline_user_bool_exp!]
  event_time: timestamp_comparison_exp
  score: bigint_comparison_exp
  team: teams_bool_exp
  team_id: Int_comparison_exp
  user_id: Int_comparison_exp
}

"""
input type for inserting data into table "score_timeline_user"
"""
input score_timeline_user_insert_input {
  event_time: timestamp
  score: bigint
  team: teams_obj_rel_insert_input
  team_id: Int
  user_id: Int
}

"""aggregate max on columns"""
type score_timeline_user_max_fields {
  event_time: timestamp
  score: bigint
  team_id: Int
  user_id: Int
}

"""
order by max() on columns of table "score_timeline_user"
"""
input score_timeline_user_max_order_by {
  event_time: order_by
  score: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type score_timeline_user_min_fields {
  event_time: timestamp
  score: bigint
  team_id: Int
  user_id: Int
}

"""
order by min() on columns of table "score_timeline_user"
"""
input score_timeline_user_min_order_by {
  event_time: order_by
  score: order_by
  team_id: order_by
  user_id: order_by
}

"""Ordering options when selecting data from "score_timeline_user"."""
input score_timeline_user_order_by {
  event_time: order_by
  score: order_by
  team: teams_order_by
  team_id: order_by
  user_id: order_by
}

"""
select columns of table "score_timeline_user"
"""
enum score_timeline_user_select_column {
  """column name"""
  event_time

  """column name"""
  score

  """column name"""
  team_id

  """column name"""
  user_id
}

"""aggregate stddev on columns"""
type score_timeline_user_stddev_fields {
  score: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "score_timeline_user"
"""
input score_timeline_user_stddev_order_by {
  score: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type score_timeline_user_stddev_pop_fields {
  score: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "score_timeline_user"
"""
input score_timeline_user_stddev_pop_order_by {
  score: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type score_timeline_user_stddev_samp_fields {
  score: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "score_timeline_user"
"""
input score_timeline_user_stddev_samp_order_by {
  score: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate sum on columns"""
type score_timeline_user_sum_fields {
  score: bigint
  team_id: Int
  user_id: Int
}

"""
order by sum() on columns of table "score_timeline_user"
"""
input score_timeline_user_sum_order_by {
  score: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate var_pop on columns"""
type score_timeline_user_var_pop_fields {
  score: Float
  team_id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "score_timeline_user"
"""
input score_timeline_user_var_pop_order_by {
  score: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type score_timeline_user_var_samp_fields {
  score: Float
  team_id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "score_timeline_user"
"""
input score_timeline_user_var_samp_order_by {
  score: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type score_timeline_user_variance_fields {
  score: Float
  team_id: Float
  user_id: Float
}

"""
order by variance() on columns of table "score_timeline_user"
"""
input score_timeline_user_variance_order_by {
  score: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate var_pop on columns"""
type score_timeline_var_pop_fields {
  score: Float
  team_id: Float
}

"""
order by var_pop() on columns of table "score_timeline"
"""
input score_timeline_var_pop_order_by {
  score: order_by
  team_id: order_by
}

"""aggregate var_samp on columns"""
type score_timeline_var_samp_fields {
  score: Float
  team_id: Float
}

"""
order by var_samp() on columns of table "score_timeline"
"""
input score_timeline_var_samp_order_by {
  score: order_by
  team_id: order_by
}

"""aggregate variance on columns"""
type score_timeline_variance_fields {
  score: Float
  team_id: Float
}

"""
order by variance() on columns of table "score_timeline"
"""
input score_timeline_variance_order_by {
  score: order_by
  team_id: order_by
}

"""
columns and relationships of "scoreboard"
"""
type scoreboard {
  max_time: timestamp
  rank: bigint
  score: bigint

  """An object relationship"""
  team: teams
  team_id: Int
}

"""
aggregated selection of "scoreboard"
"""
type scoreboard_aggregate {
  aggregate: scoreboard_aggregate_fields
  nodes: [scoreboard!]!
}

"""
aggregate fields of "scoreboard"
"""
type scoreboard_aggregate_fields {
  avg: scoreboard_avg_fields
  count(columns: [scoreboard_select_column!], distinct: Boolean): Int!
  max: scoreboard_max_fields
  min: scoreboard_min_fields
  stddev: scoreboard_stddev_fields
  stddev_pop: scoreboard_stddev_pop_fields
  stddev_samp: scoreboard_stddev_samp_fields
  sum: scoreboard_sum_fields
  var_pop: scoreboard_var_pop_fields
  var_samp: scoreboard_var_samp_fields
  variance: scoreboard_variance_fields
}

"""aggregate avg on columns"""
type scoreboard_avg_fields {
  rank: Float
  score: Float
  team_id: Float
}

"""
Boolean expression to filter rows from the table "scoreboard". All fields are combined with a logical 'AND'.
"""
input scoreboard_bool_exp {
  _and: [scoreboard_bool_exp!]
  _not: scoreboard_bool_exp
  _or: [scoreboard_bool_exp!]
  max_time: timestamp_comparison_exp
  rank: bigint_comparison_exp
  score: bigint_comparison_exp
  team: teams_bool_exp
  team_id: Int_comparison_exp
}

"""
input type for inserting data into table "scoreboard"
"""
input scoreboard_insert_input {
  max_time: timestamp
  rank: bigint
  score: bigint
  team: teams_obj_rel_insert_input
  team_id: Int
}

"""aggregate max on columns"""
type scoreboard_max_fields {
  max_time: timestamp
  rank: bigint
  score: bigint
  team_id: Int
}

"""aggregate min on columns"""
type scoreboard_min_fields {
  max_time: timestamp
  rank: bigint
  score: bigint
  team_id: Int
}

"""
input type for inserting object relation for remote table "scoreboard"
"""
input scoreboard_obj_rel_insert_input {
  data: scoreboard_insert_input!
}

"""Ordering options when selecting data from "scoreboard"."""
input scoreboard_order_by {
  max_time: order_by
  rank: order_by
  score: order_by
  team: teams_order_by
  team_id: order_by
}

"""
select columns of table "scoreboard"
"""
enum scoreboard_select_column {
  """column name"""
  max_time

  """column name"""
  rank

  """column name"""
  score

  """column name"""
  team_id
}

"""aggregate stddev on columns"""
type scoreboard_stddev_fields {
  rank: Float
  score: Float
  team_id: Float
}

"""aggregate stddev_pop on columns"""
type scoreboard_stddev_pop_fields {
  rank: Float
  score: Float
  team_id: Float
}

"""aggregate stddev_samp on columns"""
type scoreboard_stddev_samp_fields {
  rank: Float
  score: Float
  team_id: Float
}

"""aggregate sum on columns"""
type scoreboard_sum_fields {
  rank: bigint
  score: bigint
  team_id: Int
}

"""
columns and relationships of "scoreboard_user"
"""
type scoreboard_user {
  max_time: timestamp
  rank: bigint
  score: bigint

  """An object relationship"""
  team: teams
  team_id: Int

  """An object relationship"""
  user: users
  user_id: Int
}

"""
aggregated selection of "scoreboard_user"
"""
type scoreboard_user_aggregate {
  aggregate: scoreboard_user_aggregate_fields
  nodes: [scoreboard_user!]!
}

"""
aggregate fields of "scoreboard_user"
"""
type scoreboard_user_aggregate_fields {
  avg: scoreboard_user_avg_fields
  count(columns: [scoreboard_user_select_column!], distinct: Boolean): Int!
  max: scoreboard_user_max_fields
  min: scoreboard_user_min_fields
  stddev: scoreboard_user_stddev_fields
  stddev_pop: scoreboard_user_stddev_pop_fields
  stddev_samp: scoreboard_user_stddev_samp_fields
  sum: scoreboard_user_sum_fields
  var_pop: scoreboard_user_var_pop_fields
  var_samp: scoreboard_user_var_samp_fields
  variance: scoreboard_user_variance_fields
}

"""aggregate avg on columns"""
type scoreboard_user_avg_fields {
  rank: Float
  score: Float
  team_id: Float
  user_id: Float
}

"""
Boolean expression to filter rows from the table "scoreboard_user". All fields are combined with a logical 'AND'.
"""
input scoreboard_user_bool_exp {
  _and: [scoreboard_user_bool_exp!]
  _not: scoreboard_user_bool_exp
  _or: [scoreboard_user_bool_exp!]
  max_time: timestamp_comparison_exp
  rank: bigint_comparison_exp
  score: bigint_comparison_exp
  team: teams_bool_exp
  team_id: Int_comparison_exp
  user: users_bool_exp
  user_id: Int_comparison_exp
}

"""aggregate max on columns"""
type scoreboard_user_max_fields {
  max_time: timestamp
  rank: bigint
  score: bigint
  team_id: Int
  user_id: Int
}

"""aggregate min on columns"""
type scoreboard_user_min_fields {
  max_time: timestamp
  rank: bigint
  score: bigint
  team_id: Int
  user_id: Int
}

"""Ordering options when selecting data from "scoreboard_user"."""
input scoreboard_user_order_by {
  max_time: order_by
  rank: order_by
  score: order_by
  team: teams_order_by
  team_id: order_by
  user: users_order_by
  user_id: order_by
}

"""
select columns of table "scoreboard_user"
"""
enum scoreboard_user_select_column {
  """column name"""
  max_time

  """column name"""
  rank

  """column name"""
  score

  """column name"""
  team_id

  """column name"""
  user_id
}

"""aggregate stddev on columns"""
type scoreboard_user_stddev_fields {
  rank: Float
  score: Float
  team_id: Float
  user_id: Float
}

"""aggregate stddev_pop on columns"""
type scoreboard_user_stddev_pop_fields {
  rank: Float
  score: Float
  team_id: Float
  user_id: Float
}

"""aggregate stddev_samp on columns"""
type scoreboard_user_stddev_samp_fields {
  rank: Float
  score: Float
  team_id: Float
  user_id: Float
}

"""aggregate sum on columns"""
type scoreboard_user_sum_fields {
  rank: bigint
  score: bigint
  team_id: Int
  user_id: Int
}

"""aggregate var_pop on columns"""
type scoreboard_user_var_pop_fields {
  rank: Float
  score: Float
  team_id: Float
  user_id: Float
}

"""aggregate var_samp on columns"""
type scoreboard_user_var_samp_fields {
  rank: Float
  score: Float
  team_id: Float
  user_id: Float
}

"""aggregate variance on columns"""
type scoreboard_user_variance_fields {
  rank: Float
  score: Float
  team_id: Float
  user_id: Float
}

"""aggregate var_pop on columns"""
type scoreboard_var_pop_fields {
  rank: Float
  score: Float
  team_id: Float
}

"""aggregate var_samp on columns"""
type scoreboard_var_samp_fields {
  rank: Float
  score: Float
  team_id: Float
}

"""aggregate variance on columns"""
type scoreboard_variance_fields {
  rank: Float
  score: Float
  team_id: Float
}

"""
columns and relationships of "solves"
"""
type solves {
  """An object relationship"""
  challenge: challenges
  challenge_id: Int
  id: Int!

  """An object relationship"""
  submission: submissions!

  """An object relationship"""
  team: teams
  team_id: Int

  """An object relationship"""
  user: users
  user_id: Int
}

"""
aggregated selection of "solves"
"""
type solves_aggregate {
  aggregate: solves_aggregate_fields
  nodes: [solves!]!
}

"""
aggregate fields of "solves"
"""
type solves_aggregate_fields {
  avg: solves_avg_fields
  count(columns: [solves_select_column!], distinct: Boolean): Int!
  max: solves_max_fields
  min: solves_min_fields
  stddev: solves_stddev_fields
  stddev_pop: solves_stddev_pop_fields
  stddev_samp: solves_stddev_samp_fields
  sum: solves_sum_fields
  var_pop: solves_var_pop_fields
  var_samp: solves_var_samp_fields
  variance: solves_variance_fields
}

"""
order by aggregate values of table "solves"
"""
input solves_aggregate_order_by {
  avg: solves_avg_order_by
  count: order_by
  max: solves_max_order_by
  min: solves_min_order_by
  stddev: solves_stddev_order_by
  stddev_pop: solves_stddev_pop_order_by
  stddev_samp: solves_stddev_samp_order_by
  sum: solves_sum_order_by
  var_pop: solves_var_pop_order_by
  var_samp: solves_var_samp_order_by
  variance: solves_variance_order_by
}

"""
input type for inserting array relation for remote table "solves"
"""
input solves_arr_rel_insert_input {
  data: [solves_insert_input!]!

  """upsert condition"""
  on_conflict: solves_on_conflict
}

"""aggregate avg on columns"""
type solves_avg_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by avg() on columns of table "solves"
"""
input solves_avg_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "solves". All fields are combined with a logical 'AND'.
"""
input solves_bool_exp {
  _and: [solves_bool_exp!]
  _not: solves_bool_exp
  _or: [solves_bool_exp!]
  challenge: challenges_bool_exp
  challenge_id: Int_comparison_exp
  id: Int_comparison_exp
  submission: submissions_bool_exp
  team: teams_bool_exp
  team_id: Int_comparison_exp
  user: users_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "solves"
"""
enum solves_constraint {
  """
  unique or primary key constraint on columns "challenge_id", "team_id"
  """
  solves_challenge_id_team_id_key

  """
  unique or primary key constraint on columns "challenge_id", "user_id"
  """
  solves_challenge_id_user_id_key

  """
  unique or primary key constraint on columns "id"
  """
  solves_pkey
}

"""
input type for incrementing numeric columns in table "solves"
"""
input solves_inc_input {
  challenge_id: Int
  id: Int
  team_id: Int
  user_id: Int
}

"""
input type for inserting data into table "solves"
"""
input solves_insert_input {
  challenge: challenges_obj_rel_insert_input
  challenge_id: Int
  id: Int
  submission: submissions_obj_rel_insert_input
  team: teams_obj_rel_insert_input
  team_id: Int
  user: users_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type solves_max_fields {
  challenge_id: Int
  id: Int
  team_id: Int
  user_id: Int
}

"""
order by max() on columns of table "solves"
"""
input solves_max_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type solves_min_fields {
  challenge_id: Int
  id: Int
  team_id: Int
  user_id: Int
}

"""
order by min() on columns of table "solves"
"""
input solves_min_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "solves"
"""
type solves_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [solves!]!
}

"""
input type for inserting object relation for remote table "solves"
"""
input solves_obj_rel_insert_input {
  data: solves_insert_input!

  """upsert condition"""
  on_conflict: solves_on_conflict
}

"""
on_conflict condition type for table "solves"
"""
input solves_on_conflict {
  constraint: solves_constraint!
  update_columns: [solves_update_column!]! = []
  where: solves_bool_exp
}

"""Ordering options when selecting data from "solves"."""
input solves_order_by {
  challenge: challenges_order_by
  challenge_id: order_by
  id: order_by
  submission: submissions_order_by
  team: teams_order_by
  team_id: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: solves"""
input solves_pk_columns_input {
  id: Int!
}

"""
select columns of table "solves"
"""
enum solves_select_column {
  """column name"""
  challenge_id

  """column name"""
  id

  """column name"""
  team_id

  """column name"""
  user_id
}

"""
input type for updating data in table "solves"
"""
input solves_set_input {
  challenge_id: Int
  id: Int
  team_id: Int
  user_id: Int
}

"""aggregate stddev on columns"""
type solves_stddev_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "solves"
"""
input solves_stddev_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type solves_stddev_pop_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "solves"
"""
input solves_stddev_pop_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type solves_stddev_samp_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "solves"
"""
input solves_stddev_samp_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate sum on columns"""
type solves_sum_fields {
  challenge_id: Int
  id: Int
  team_id: Int
  user_id: Int
}

"""
order by sum() on columns of table "solves"
"""
input solves_sum_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""
update columns of table "solves"
"""
enum solves_update_column {
  """column name"""
  challenge_id

  """column name"""
  id

  """column name"""
  team_id

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type solves_var_pop_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "solves"
"""
input solves_var_pop_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type solves_var_samp_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "solves"
"""
input solves_var_samp_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type solves_variance_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by variance() on columns of table "solves"
"""
input solves_variance_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""
columns and relationships of "submissions"
"""
type submissions {
  """An object relationship"""
  challenge: challenges
  challenge_id: Int
  date: timestamp
  id: Int!
  ip: String
  provided: String

  """An object relationship"""
  solve: solves

  """An object relationship"""
  team: teams
  team_id: Int
  type: String

  """An object relationship"""
  user: users
  user_id: Int
}

"""
aggregated selection of "submissions"
"""
type submissions_aggregate {
  aggregate: submissions_aggregate_fields
  nodes: [submissions!]!
}

"""
aggregate fields of "submissions"
"""
type submissions_aggregate_fields {
  avg: submissions_avg_fields
  count(columns: [submissions_select_column!], distinct: Boolean): Int!
  max: submissions_max_fields
  min: submissions_min_fields
  stddev: submissions_stddev_fields
  stddev_pop: submissions_stddev_pop_fields
  stddev_samp: submissions_stddev_samp_fields
  sum: submissions_sum_fields
  var_pop: submissions_var_pop_fields
  var_samp: submissions_var_samp_fields
  variance: submissions_variance_fields
}

"""
order by aggregate values of table "submissions"
"""
input submissions_aggregate_order_by {
  avg: submissions_avg_order_by
  count: order_by
  max: submissions_max_order_by
  min: submissions_min_order_by
  stddev: submissions_stddev_order_by
  stddev_pop: submissions_stddev_pop_order_by
  stddev_samp: submissions_stddev_samp_order_by
  sum: submissions_sum_order_by
  var_pop: submissions_var_pop_order_by
  var_samp: submissions_var_samp_order_by
  variance: submissions_variance_order_by
}

"""
input type for inserting array relation for remote table "submissions"
"""
input submissions_arr_rel_insert_input {
  data: [submissions_insert_input!]!

  """upsert condition"""
  on_conflict: submissions_on_conflict
}

"""aggregate avg on columns"""
type submissions_avg_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by avg() on columns of table "submissions"
"""
input submissions_avg_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "submissions". All fields are combined with a logical 'AND'.
"""
input submissions_bool_exp {
  _and: [submissions_bool_exp!]
  _not: submissions_bool_exp
  _or: [submissions_bool_exp!]
  challenge: challenges_bool_exp
  challenge_id: Int_comparison_exp
  date: timestamp_comparison_exp
  id: Int_comparison_exp
  ip: String_comparison_exp
  provided: String_comparison_exp
  solve: solves_bool_exp
  team: teams_bool_exp
  team_id: Int_comparison_exp
  type: String_comparison_exp
  user: users_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "submissions"
"""
enum submissions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  submissions_pkey
}

"""
input type for incrementing numeric columns in table "submissions"
"""
input submissions_inc_input {
  challenge_id: Int
  id: Int
  team_id: Int
  user_id: Int
}

"""
input type for inserting data into table "submissions"
"""
input submissions_insert_input {
  challenge: challenges_obj_rel_insert_input
  challenge_id: Int
  date: timestamp
  id: Int
  ip: String
  provided: String
  solve: solves_obj_rel_insert_input
  team: teams_obj_rel_insert_input
  team_id: Int
  type: String
  user: users_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type submissions_max_fields {
  challenge_id: Int
  date: timestamp
  id: Int
  ip: String
  provided: String
  team_id: Int
  type: String
  user_id: Int
}

"""
order by max() on columns of table "submissions"
"""
input submissions_max_order_by {
  challenge_id: order_by
  date: order_by
  id: order_by
  ip: order_by
  provided: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type submissions_min_fields {
  challenge_id: Int
  date: timestamp
  id: Int
  ip: String
  provided: String
  team_id: Int
  type: String
  user_id: Int
}

"""
order by min() on columns of table "submissions"
"""
input submissions_min_order_by {
  challenge_id: order_by
  date: order_by
  id: order_by
  ip: order_by
  provided: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""
response of any mutation on the table "submissions"
"""
type submissions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [submissions!]!
}

"""
input type for inserting object relation for remote table "submissions"
"""
input submissions_obj_rel_insert_input {
  data: submissions_insert_input!

  """upsert condition"""
  on_conflict: submissions_on_conflict
}

"""
on_conflict condition type for table "submissions"
"""
input submissions_on_conflict {
  constraint: submissions_constraint!
  update_columns: [submissions_update_column!]! = []
  where: submissions_bool_exp
}

"""Ordering options when selecting data from "submissions"."""
input submissions_order_by {
  challenge: challenges_order_by
  challenge_id: order_by
  date: order_by
  id: order_by
  ip: order_by
  provided: order_by
  solve: solves_order_by
  team: teams_order_by
  team_id: order_by
  type: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: submissions"""
input submissions_pk_columns_input {
  id: Int!
}

"""
select columns of table "submissions"
"""
enum submissions_select_column {
  """column name"""
  challenge_id

  """column name"""
  date

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  provided

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id
}

"""
input type for updating data in table "submissions"
"""
input submissions_set_input {
  challenge_id: Int
  date: timestamp
  id: Int
  ip: String
  provided: String
  team_id: Int
  type: String
  user_id: Int
}

"""aggregate stddev on columns"""
type submissions_stddev_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "submissions"
"""
input submissions_stddev_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type submissions_stddev_pop_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "submissions"
"""
input submissions_stddev_pop_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type submissions_stddev_samp_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "submissions"
"""
input submissions_stddev_samp_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate sum on columns"""
type submissions_sum_fields {
  challenge_id: Int
  id: Int
  team_id: Int
  user_id: Int
}

"""
order by sum() on columns of table "submissions"
"""
input submissions_sum_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""
update columns of table "submissions"
"""
enum submissions_update_column {
  """column name"""
  challenge_id

  """column name"""
  date

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  provided

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type submissions_var_pop_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "submissions"
"""
input submissions_var_pop_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type submissions_var_samp_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "submissions"
"""
input submissions_var_samp_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type submissions_variance_fields {
  challenge_id: Float
  id: Float
  team_id: Float
  user_id: Float
}

"""
order by variance() on columns of table "submissions"
"""
input submissions_variance_order_by {
  challenge_id: order_by
  id: order_by
  team_id: order_by
  user_id: order_by
}

type subscription_root {
  """An array relationship"""
  awards(
    """distinct select on columns"""
    distinct_on: [awards_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [awards_order_by!]

    """filter the rows returned"""
    where: awards_bool_exp
  ): [awards!]!

  """An aggregate relationship"""
  awards_aggregate(
    """distinct select on columns"""
    distinct_on: [awards_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [awards_order_by!]

    """filter the rows returned"""
    where: awards_bool_exp
  ): awards_aggregate!

  """fetch data from the table: "awards" using primary key columns"""
  awards_by_pk(id: Int!): awards

  """
  fetch data from the table: "challenges"
  """
  challenges(
    """distinct select on columns"""
    distinct_on: [challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenges_order_by!]

    """filter the rows returned"""
    where: challenges_bool_exp
  ): [challenges!]!

  """
  fetch aggregated fields from the table: "challenges"
  """
  challenges_aggregate(
    """distinct select on columns"""
    distinct_on: [challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenges_order_by!]

    """filter the rows returned"""
    where: challenges_bool_exp
  ): challenges_aggregate!

  """fetch data from the table: "challenges" using primary key columns"""
  challenges_by_pk(id: Int!): challenges

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): [comments!]!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): comments_aggregate!

  """fetch data from the table: "comments" using primary key columns"""
  comments_by_pk(id: Int!): comments

  """
  fetch data from the table: "config"
  """
  config(
    """distinct select on columns"""
    distinct_on: [config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [config_order_by!]

    """filter the rows returned"""
    where: config_bool_exp
  ): [config!]!

  """
  fetch aggregated fields from the table: "config"
  """
  config_aggregate(
    """distinct select on columns"""
    distinct_on: [config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [config_order_by!]

    """filter the rows returned"""
    where: config_bool_exp
  ): config_aggregate!

  """fetch data from the table: "config" using primary key columns"""
  config_by_pk(id: Int!): config

  """
  execute function "current_user" which returns "users"
  """
  current_user(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  execute function "current_user" and query aggregates on result of table type "users"
  """
  current_user_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table: "dynamic_challenge"
  """
  dynamic_challenge(
    """distinct select on columns"""
    distinct_on: [dynamic_challenge_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_challenge_order_by!]

    """filter the rows returned"""
    where: dynamic_challenge_bool_exp
  ): [dynamic_challenge!]!

  """
  fetch aggregated fields from the table: "dynamic_challenge"
  """
  dynamic_challenge_aggregate(
    """distinct select on columns"""
    distinct_on: [dynamic_challenge_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dynamic_challenge_order_by!]

    """filter the rows returned"""
    where: dynamic_challenge_bool_exp
  ): dynamic_challenge_aggregate!

  """
  fetch data from the table: "dynamic_challenge" using primary key columns
  """
  dynamic_challenge_by_pk(id: Int!): dynamic_challenge

  """An array relationship"""
  field_entries(
    """distinct select on columns"""
    distinct_on: [field_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entries_order_by!]

    """filter the rows returned"""
    where: field_entries_bool_exp
  ): [field_entries!]!

  """An aggregate relationship"""
  field_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [field_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entries_order_by!]

    """filter the rows returned"""
    where: field_entries_bool_exp
  ): field_entries_aggregate!

  """fetch data from the table: "field_entries" using primary key columns"""
  field_entries_by_pk(id: Int!): field_entries

  """
  fetch data from the table: "fields"
  """
  fields(
    """distinct select on columns"""
    distinct_on: [fields_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fields_order_by!]

    """filter the rows returned"""
    where: fields_bool_exp
  ): [fields!]!

  """
  fetch aggregated fields from the table: "fields"
  """
  fields_aggregate(
    """distinct select on columns"""
    distinct_on: [fields_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fields_order_by!]

    """filter the rows returned"""
    where: fields_bool_exp
  ): fields_aggregate!

  """fetch data from the table: "fields" using primary key columns"""
  fields_by_pk(id: Int!): fields

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """fetch data from the table: "files" using primary key columns"""
  files_by_pk(id: Int!): files

  """An array relationship"""
  flags(
    """distinct select on columns"""
    distinct_on: [flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [flags_order_by!]

    """filter the rows returned"""
    where: flags_bool_exp
  ): [flags!]!

  """An aggregate relationship"""
  flags_aggregate(
    """distinct select on columns"""
    distinct_on: [flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [flags_order_by!]

    """filter the rows returned"""
    where: flags_bool_exp
  ): flags_aggregate!

  """fetch data from the table: "flags" using primary key columns"""
  flags_by_pk(id: Int!): flags

  """An array relationship"""
  hints(
    """distinct select on columns"""
    distinct_on: [hints_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_order_by!]

    """filter the rows returned"""
    where: hints_bool_exp
  ): [hints!]!

  """An aggregate relationship"""
  hints_aggregate(
    """distinct select on columns"""
    distinct_on: [hints_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_order_by!]

    """filter the rows returned"""
    where: hints_bool_exp
  ): hints_aggregate!

  """fetch data from the table: "hints" using primary key columns"""
  hints_by_pk(id: Int!): hints

  """
  fetch data from the table: "hints_content"
  """
  hints_content(
    """distinct select on columns"""
    distinct_on: [hints_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_content_order_by!]

    """filter the rows returned"""
    where: hints_content_bool_exp
  ): [hints_content!]!

  """
  fetch aggregated fields from the table: "hints_content"
  """
  hints_content_aggregate(
    """distinct select on columns"""
    distinct_on: [hints_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hints_content_order_by!]

    """filter the rows returned"""
    where: hints_content_bool_exp
  ): hints_content_aggregate!

  """
  fetch data from the table: "notifications"
  """
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """
  fetch aggregated fields from the table: "notifications"
  """
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: Int!): notifications

  """
  fetch data from the table: "pages"
  """
  pages(
    """distinct select on columns"""
    distinct_on: [pages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pages_order_by!]

    """filter the rows returned"""
    where: pages_bool_exp
  ): [pages!]!

  """
  fetch aggregated fields from the table: "pages"
  """
  pages_aggregate(
    """distinct select on columns"""
    distinct_on: [pages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pages_order_by!]

    """filter the rows returned"""
    where: pages_bool_exp
  ): pages_aggregate!

  """fetch data from the table: "pages" using primary key columns"""
  pages_by_pk(id: Int!): pages

  """
  fetch data from the table: "score_events"
  """
  score_events(
    """distinct select on columns"""
    distinct_on: [score_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_events_order_by!]

    """filter the rows returned"""
    where: score_events_bool_exp
  ): [score_events!]!

  """
  fetch aggregated fields from the table: "score_events"
  """
  score_events_aggregate(
    """distinct select on columns"""
    distinct_on: [score_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_events_order_by!]

    """filter the rows returned"""
    where: score_events_bool_exp
  ): score_events_aggregate!

  """An array relationship"""
  score_timeline(
    """distinct select on columns"""
    distinct_on: [score_timeline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_order_by!]

    """filter the rows returned"""
    where: score_timeline_bool_exp
  ): [score_timeline!]!

  """An aggregate relationship"""
  score_timeline_aggregate(
    """distinct select on columns"""
    distinct_on: [score_timeline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_order_by!]

    """filter the rows returned"""
    where: score_timeline_bool_exp
  ): score_timeline_aggregate!

  """
  fetch data from the table: "score_timeline_user"
  """
  score_timeline_user(
    """distinct select on columns"""
    distinct_on: [score_timeline_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_user_order_by!]

    """filter the rows returned"""
    where: score_timeline_user_bool_exp
  ): [score_timeline_user!]!

  """
  fetch aggregated fields from the table: "score_timeline_user"
  """
  score_timeline_user_aggregate(
    """distinct select on columns"""
    distinct_on: [score_timeline_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_user_order_by!]

    """filter the rows returned"""
    where: score_timeline_user_bool_exp
  ): score_timeline_user_aggregate!

  """
  fetch data from the table: "scoreboard"
  """
  scoreboard(
    """distinct select on columns"""
    distinct_on: [scoreboard_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_order_by!]

    """filter the rows returned"""
    where: scoreboard_bool_exp
  ): [scoreboard!]!

  """
  fetch aggregated fields from the table: "scoreboard"
  """
  scoreboard_aggregate(
    """distinct select on columns"""
    distinct_on: [scoreboard_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_order_by!]

    """filter the rows returned"""
    where: scoreboard_bool_exp
  ): scoreboard_aggregate!

  """
  fetch data from the table: "scoreboard_user"
  """
  scoreboard_user(
    """distinct select on columns"""
    distinct_on: [scoreboard_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_user_order_by!]

    """filter the rows returned"""
    where: scoreboard_user_bool_exp
  ): [scoreboard_user!]!

  """
  fetch aggregated fields from the table: "scoreboard_user"
  """
  scoreboard_user_aggregate(
    """distinct select on columns"""
    distinct_on: [scoreboard_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scoreboard_user_order_by!]

    """filter the rows returned"""
    where: scoreboard_user_bool_exp
  ): scoreboard_user_aggregate!

  """An array relationship"""
  solves(
    """distinct select on columns"""
    distinct_on: [solves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solves_order_by!]

    """filter the rows returned"""
    where: solves_bool_exp
  ): [solves!]!

  """An aggregate relationship"""
  solves_aggregate(
    """distinct select on columns"""
    distinct_on: [solves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solves_order_by!]

    """filter the rows returned"""
    where: solves_bool_exp
  ): solves_aggregate!

  """fetch data from the table: "solves" using primary key columns"""
  solves_by_pk(id: Int!): solves

  """An array relationship"""
  submissions(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): [submissions!]!

  """An aggregate relationship"""
  submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): submissions_aggregate!

  """fetch data from the table: "submissions" using primary key columns"""
  submissions_by_pk(id: Int!): submissions

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): [tags!]!

  """An aggregate relationship"""
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tags_order_by!]

    """filter the rows returned"""
    where: tags_bool_exp
  ): tags_aggregate!

  """fetch data from the table: "tags" using primary key columns"""
  tags_by_pk(id: Int!): tags

  """
  fetch data from the table: "teams"
  """
  teams(
    """distinct select on columns"""
    distinct_on: [teams_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teams_order_by!]

    """filter the rows returned"""
    where: teams_bool_exp
  ): [teams!]!

  """
  fetch aggregated fields from the table: "teams"
  """
  teams_aggregate(
    """distinct select on columns"""
    distinct_on: [teams_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teams_order_by!]

    """filter the rows returned"""
    where: teams_bool_exp
  ): teams_aggregate!

  """fetch data from the table: "teams" using primary key columns"""
  teams_by_pk(id: Int!): teams

  """An array relationship"""
  tokens(
    """distinct select on columns"""
    distinct_on: [tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_order_by!]

    """filter the rows returned"""
    where: tokens_bool_exp
  ): [tokens!]!

  """An aggregate relationship"""
  tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_order_by!]

    """filter the rows returned"""
    where: tokens_bool_exp
  ): tokens_aggregate!

  """fetch data from the table: "tokens" using primary key columns"""
  tokens_by_pk(id: Int!): tokens

  """
  fetch data from the table: "tracking"
  """
  tracking(
    """distinct select on columns"""
    distinct_on: [tracking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tracking_order_by!]

    """filter the rows returned"""
    where: tracking_bool_exp
  ): [tracking!]!

  """
  fetch aggregated fields from the table: "tracking"
  """
  tracking_aggregate(
    """distinct select on columns"""
    distinct_on: [tracking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tracking_order_by!]

    """filter the rows returned"""
    where: tracking_bool_exp
  ): tracking_aggregate!

  """fetch data from the table: "tracking" using primary key columns"""
  tracking_by_pk(id: Int!): tracking

  """An array relationship"""
  unlocks(
    """distinct select on columns"""
    distinct_on: [unlocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlocks_order_by!]

    """filter the rows returned"""
    where: unlocks_bool_exp
  ): [unlocks!]!

  """An aggregate relationship"""
  unlocks_aggregate(
    """distinct select on columns"""
    distinct_on: [unlocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlocks_order_by!]

    """filter the rows returned"""
    where: unlocks_bool_exp
  ): unlocks_aggregate!

  """fetch data from the table: "unlocks" using primary key columns"""
  unlocks_by_pk(id: Int!): unlocks

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: Int!): users
}

"""
columns and relationships of "tags"
"""
type tags {
  """An object relationship"""
  challenge: challenges
  challenge_id: Int
  id: Int!
  value: String
}

"""
aggregated selection of "tags"
"""
type tags_aggregate {
  aggregate: tags_aggregate_fields
  nodes: [tags!]!
}

"""
aggregate fields of "tags"
"""
type tags_aggregate_fields {
  avg: tags_avg_fields
  count(columns: [tags_select_column!], distinct: Boolean): Int!
  max: tags_max_fields
  min: tags_min_fields
  stddev: tags_stddev_fields
  stddev_pop: tags_stddev_pop_fields
  stddev_samp: tags_stddev_samp_fields
  sum: tags_sum_fields
  var_pop: tags_var_pop_fields
  var_samp: tags_var_samp_fields
  variance: tags_variance_fields
}

"""
order by aggregate values of table "tags"
"""
input tags_aggregate_order_by {
  avg: tags_avg_order_by
  count: order_by
  max: tags_max_order_by
  min: tags_min_order_by
  stddev: tags_stddev_order_by
  stddev_pop: tags_stddev_pop_order_by
  stddev_samp: tags_stddev_samp_order_by
  sum: tags_sum_order_by
  var_pop: tags_var_pop_order_by
  var_samp: tags_var_samp_order_by
  variance: tags_variance_order_by
}

"""
input type for inserting array relation for remote table "tags"
"""
input tags_arr_rel_insert_input {
  data: [tags_insert_input!]!

  """upsert condition"""
  on_conflict: tags_on_conflict
}

"""aggregate avg on columns"""
type tags_avg_fields {
  challenge_id: Float
  id: Float
}

"""
order by avg() on columns of table "tags"
"""
input tags_avg_order_by {
  challenge_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "tags". All fields are combined with a logical 'AND'.
"""
input tags_bool_exp {
  _and: [tags_bool_exp!]
  _not: tags_bool_exp
  _or: [tags_bool_exp!]
  challenge: challenges_bool_exp
  challenge_id: Int_comparison_exp
  id: Int_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "tags"
"""
enum tags_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tags_pkey
}

"""
input type for incrementing numeric columns in table "tags"
"""
input tags_inc_input {
  challenge_id: Int
  id: Int
}

"""
input type for inserting data into table "tags"
"""
input tags_insert_input {
  challenge: challenges_obj_rel_insert_input
  challenge_id: Int
  id: Int
  value: String
}

"""aggregate max on columns"""
type tags_max_fields {
  challenge_id: Int
  id: Int
  value: String
}

"""
order by max() on columns of table "tags"
"""
input tags_max_order_by {
  challenge_id: order_by
  id: order_by
  value: order_by
}

"""aggregate min on columns"""
type tags_min_fields {
  challenge_id: Int
  id: Int
  value: String
}

"""
order by min() on columns of table "tags"
"""
input tags_min_order_by {
  challenge_id: order_by
  id: order_by
  value: order_by
}

"""
response of any mutation on the table "tags"
"""
type tags_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tags!]!
}

"""
on_conflict condition type for table "tags"
"""
input tags_on_conflict {
  constraint: tags_constraint!
  update_columns: [tags_update_column!]! = []
  where: tags_bool_exp
}

"""Ordering options when selecting data from "tags"."""
input tags_order_by {
  challenge: challenges_order_by
  challenge_id: order_by
  id: order_by
  value: order_by
}

"""primary key columns input for table: tags"""
input tags_pk_columns_input {
  id: Int!
}

"""
select columns of table "tags"
"""
enum tags_select_column {
  """column name"""
  challenge_id

  """column name"""
  id

  """column name"""
  value
}

"""
input type for updating data in table "tags"
"""
input tags_set_input {
  challenge_id: Int
  id: Int
  value: String
}

"""aggregate stddev on columns"""
type tags_stddev_fields {
  challenge_id: Float
  id: Float
}

"""
order by stddev() on columns of table "tags"
"""
input tags_stddev_order_by {
  challenge_id: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type tags_stddev_pop_fields {
  challenge_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "tags"
"""
input tags_stddev_pop_order_by {
  challenge_id: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type tags_stddev_samp_fields {
  challenge_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "tags"
"""
input tags_stddev_samp_order_by {
  challenge_id: order_by
  id: order_by
}

"""aggregate sum on columns"""
type tags_sum_fields {
  challenge_id: Int
  id: Int
}

"""
order by sum() on columns of table "tags"
"""
input tags_sum_order_by {
  challenge_id: order_by
  id: order_by
}

"""
update columns of table "tags"
"""
enum tags_update_column {
  """column name"""
  challenge_id

  """column name"""
  id

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type tags_var_pop_fields {
  challenge_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "tags"
"""
input tags_var_pop_order_by {
  challenge_id: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type tags_var_samp_fields {
  challenge_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "tags"
"""
input tags_var_samp_order_by {
  challenge_id: order_by
  id: order_by
}

"""aggregate variance on columns"""
type tags_variance_fields {
  challenge_id: Float
  id: Float
}

"""
order by variance() on columns of table "tags"
"""
input tags_variance_order_by {
  challenge_id: order_by
  id: order_by
}

"""
columns and relationships of "teams"
"""
type teams {
  affiliation: String

  """An array relationship"""
  awards(
    """distinct select on columns"""
    distinct_on: [awards_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [awards_order_by!]

    """filter the rows returned"""
    where: awards_bool_exp
  ): [awards!]!

  """An aggregate relationship"""
  awards_aggregate(
    """distinct select on columns"""
    distinct_on: [awards_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [awards_order_by!]

    """filter the rows returned"""
    where: awards_bool_exp
  ): awards_aggregate!
  banned: Boolean
  bracket: String

  """An object relationship"""
  captain: users
  captain_id: Int

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): [comments!]!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): comments_aggregate!
  country: String
  created: timestamp
  email: String

  """An array relationship"""
  field_entries(
    """distinct select on columns"""
    distinct_on: [field_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entries_order_by!]

    """filter the rows returned"""
    where: field_entries_bool_exp
  ): [field_entries!]!

  """An aggregate relationship"""
  field_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [field_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entries_order_by!]

    """filter the rows returned"""
    where: field_entries_bool_exp
  ): field_entries_aggregate!
  hidden: Boolean
  id: Int!

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
  name: String
  oauth_id: Int
  password: String

  """
  A computed field, executes function "team_score"
  """
  score: Int

  """An array relationship"""
  score_timeline(
    """distinct select on columns"""
    distinct_on: [score_timeline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_order_by!]

    """filter the rows returned"""
    where: score_timeline_bool_exp
  ): [score_timeline!]!

  """An aggregate relationship"""
  score_timeline_aggregate(
    """distinct select on columns"""
    distinct_on: [score_timeline_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_order_by!]

    """filter the rows returned"""
    where: score_timeline_bool_exp
  ): score_timeline_aggregate!

  """An object relationship"""
  scoreboard: scoreboard
  secret: String

  """An array relationship"""
  solves(
    """distinct select on columns"""
    distinct_on: [solves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solves_order_by!]

    """filter the rows returned"""
    where: solves_bool_exp
  ): [solves!]!

  """An aggregate relationship"""
  solves_aggregate(
    """distinct select on columns"""
    distinct_on: [solves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solves_order_by!]

    """filter the rows returned"""
    where: solves_bool_exp
  ): solves_aggregate!

  """An array relationship"""
  submissions(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): [submissions!]!

  """An aggregate relationship"""
  submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): submissions_aggregate!

  """An array relationship"""
  teams(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An aggregate relationship"""
  teams_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """An array relationship"""
  unlocks(
    """distinct select on columns"""
    distinct_on: [unlocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlocks_order_by!]

    """filter the rows returned"""
    where: unlocks_bool_exp
  ): [unlocks!]!

  """An aggregate relationship"""
  unlocks_aggregate(
    """distinct select on columns"""
    distinct_on: [unlocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlocks_order_by!]

    """filter the rows returned"""
    where: unlocks_bool_exp
  ): unlocks_aggregate!
  website: String
}

"""
aggregated selection of "teams"
"""
type teams_aggregate {
  aggregate: teams_aggregate_fields
  nodes: [teams!]!
}

"""
aggregate fields of "teams"
"""
type teams_aggregate_fields {
  avg: teams_avg_fields
  count(columns: [teams_select_column!], distinct: Boolean): Int!
  max: teams_max_fields
  min: teams_min_fields
  stddev: teams_stddev_fields
  stddev_pop: teams_stddev_pop_fields
  stddev_samp: teams_stddev_samp_fields
  sum: teams_sum_fields
  var_pop: teams_var_pop_fields
  var_samp: teams_var_samp_fields
  variance: teams_variance_fields
}

"""aggregate avg on columns"""
type teams_avg_fields {
  captain_id: Float
  id: Float
  oauth_id: Float
}

"""
Boolean expression to filter rows from the table "teams". All fields are combined with a logical 'AND'.
"""
input teams_bool_exp {
  _and: [teams_bool_exp!]
  _not: teams_bool_exp
  _or: [teams_bool_exp!]
  affiliation: String_comparison_exp
  awards: awards_bool_exp
  banned: Boolean_comparison_exp
  bracket: String_comparison_exp
  captain: users_bool_exp
  captain_id: Int_comparison_exp
  comments: comments_bool_exp
  country: String_comparison_exp
  created: timestamp_comparison_exp
  email: String_comparison_exp
  field_entries: field_entries_bool_exp
  hidden: Boolean_comparison_exp
  id: Int_comparison_exp
  members: users_bool_exp
  name: String_comparison_exp
  oauth_id: Int_comparison_exp
  password: String_comparison_exp
  score: Int_comparison_exp
  score_timeline: score_timeline_bool_exp
  scoreboard: scoreboard_bool_exp
  secret: String_comparison_exp
  solves: solves_bool_exp
  submissions: submissions_bool_exp
  teams: notifications_bool_exp
  unlocks: unlocks_bool_exp
  website: String_comparison_exp
}

"""
unique or primary key constraints on table "teams"
"""
enum teams_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  teams_email_key

  """
  unique or primary key constraint on columns "oauth_id", "id"
  """
  teams_id_oauth_id_key

  """
  unique or primary key constraint on columns "oauth_id"
  """
  teams_oauth_id_key

  """
  unique or primary key constraint on columns "id"
  """
  teams_pkey
}

"""
input type for incrementing numeric columns in table "teams"
"""
input teams_inc_input {
  captain_id: Int
  id: Int
  oauth_id: Int
}

"""
input type for inserting data into table "teams"
"""
input teams_insert_input {
  affiliation: String
  awards: awards_arr_rel_insert_input
  banned: Boolean
  bracket: String
  captain: users_obj_rel_insert_input
  captain_id: Int
  comments: comments_arr_rel_insert_input
  country: String
  created: timestamp
  email: String
  field_entries: field_entries_arr_rel_insert_input
  hidden: Boolean
  id: Int
  members: users_arr_rel_insert_input
  name: String
  oauth_id: Int
  password: String
  score_timeline: score_timeline_arr_rel_insert_input
  scoreboard: scoreboard_obj_rel_insert_input
  secret: String
  solves: solves_arr_rel_insert_input
  submissions: submissions_arr_rel_insert_input
  teams: notifications_arr_rel_insert_input
  unlocks: unlocks_arr_rel_insert_input
  website: String
}

"""aggregate max on columns"""
type teams_max_fields {
  affiliation: String
  bracket: String
  captain_id: Int
  country: String
  created: timestamp
  email: String
  id: Int
  name: String
  oauth_id: Int
  password: String
  secret: String
  website: String
}

"""aggregate min on columns"""
type teams_min_fields {
  affiliation: String
  bracket: String
  captain_id: Int
  country: String
  created: timestamp
  email: String
  id: Int
  name: String
  oauth_id: Int
  password: String
  secret: String
  website: String
}

"""
response of any mutation on the table "teams"
"""
type teams_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [teams!]!
}

"""
input type for inserting object relation for remote table "teams"
"""
input teams_obj_rel_insert_input {
  data: teams_insert_input!

  """upsert condition"""
  on_conflict: teams_on_conflict
}

"""
on_conflict condition type for table "teams"
"""
input teams_on_conflict {
  constraint: teams_constraint!
  update_columns: [teams_update_column!]! = []
  where: teams_bool_exp
}

"""Ordering options when selecting data from "teams"."""
input teams_order_by {
  affiliation: order_by
  awards_aggregate: awards_aggregate_order_by
  banned: order_by
  bracket: order_by
  captain: users_order_by
  captain_id: order_by
  comments_aggregate: comments_aggregate_order_by
  country: order_by
  created: order_by
  email: order_by
  field_entries_aggregate: field_entries_aggregate_order_by
  hidden: order_by
  id: order_by
  members_aggregate: users_aggregate_order_by
  name: order_by
  oauth_id: order_by
  password: order_by
  score: order_by
  score_timeline_aggregate: score_timeline_aggregate_order_by
  scoreboard: scoreboard_order_by
  secret: order_by
  solves_aggregate: solves_aggregate_order_by
  submissions_aggregate: submissions_aggregate_order_by
  teams_aggregate: notifications_aggregate_order_by
  unlocks_aggregate: unlocks_aggregate_order_by
  website: order_by
}

"""primary key columns input for table: teams"""
input teams_pk_columns_input {
  id: Int!
}

"""
select columns of table "teams"
"""
enum teams_select_column {
  """column name"""
  affiliation

  """column name"""
  banned

  """column name"""
  bracket

  """column name"""
  captain_id

  """column name"""
  country

  """column name"""
  created

  """column name"""
  email

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  name

  """column name"""
  oauth_id

  """column name"""
  password

  """column name"""
  secret

  """column name"""
  website
}

"""
input type for updating data in table "teams"
"""
input teams_set_input {
  affiliation: String
  banned: Boolean
  bracket: String
  captain_id: Int
  country: String
  created: timestamp
  email: String
  hidden: Boolean
  id: Int
  name: String
  oauth_id: Int
  password: String
  secret: String
  website: String
}

"""aggregate stddev on columns"""
type teams_stddev_fields {
  captain_id: Float
  id: Float
  oauth_id: Float
}

"""aggregate stddev_pop on columns"""
type teams_stddev_pop_fields {
  captain_id: Float
  id: Float
  oauth_id: Float
}

"""aggregate stddev_samp on columns"""
type teams_stddev_samp_fields {
  captain_id: Float
  id: Float
  oauth_id: Float
}

"""aggregate sum on columns"""
type teams_sum_fields {
  captain_id: Int
  id: Int
  oauth_id: Int
}

"""
update columns of table "teams"
"""
enum teams_update_column {
  """column name"""
  affiliation

  """column name"""
  banned

  """column name"""
  bracket

  """column name"""
  captain_id

  """column name"""
  country

  """column name"""
  created

  """column name"""
  email

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  name

  """column name"""
  oauth_id

  """column name"""
  password

  """column name"""
  secret

  """column name"""
  website
}

"""aggregate var_pop on columns"""
type teams_var_pop_fields {
  captain_id: Float
  id: Float
  oauth_id: Float
}

"""aggregate var_samp on columns"""
type teams_var_samp_fields {
  captain_id: Float
  id: Float
  oauth_id: Float
}

"""aggregate variance on columns"""
type teams_variance_fields {
  captain_id: Float
  id: Float
  oauth_id: Float
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"""
columns and relationships of "tokens"
"""
type tokens {
  created: timestamp
  expiration: timestamp
  id: Int!
  type: String

  """An object relationship"""
  user: users
  user_id: Int
  value: String
}

"""
aggregated selection of "tokens"
"""
type tokens_aggregate {
  aggregate: tokens_aggregate_fields
  nodes: [tokens!]!
}

"""
aggregate fields of "tokens"
"""
type tokens_aggregate_fields {
  avg: tokens_avg_fields
  count(columns: [tokens_select_column!], distinct: Boolean): Int!
  max: tokens_max_fields
  min: tokens_min_fields
  stddev: tokens_stddev_fields
  stddev_pop: tokens_stddev_pop_fields
  stddev_samp: tokens_stddev_samp_fields
  sum: tokens_sum_fields
  var_pop: tokens_var_pop_fields
  var_samp: tokens_var_samp_fields
  variance: tokens_variance_fields
}

"""
order by aggregate values of table "tokens"
"""
input tokens_aggregate_order_by {
  avg: tokens_avg_order_by
  count: order_by
  max: tokens_max_order_by
  min: tokens_min_order_by
  stddev: tokens_stddev_order_by
  stddev_pop: tokens_stddev_pop_order_by
  stddev_samp: tokens_stddev_samp_order_by
  sum: tokens_sum_order_by
  var_pop: tokens_var_pop_order_by
  var_samp: tokens_var_samp_order_by
  variance: tokens_variance_order_by
}

"""
input type for inserting array relation for remote table "tokens"
"""
input tokens_arr_rel_insert_input {
  data: [tokens_insert_input!]!

  """upsert condition"""
  on_conflict: tokens_on_conflict
}

"""aggregate avg on columns"""
type tokens_avg_fields {
  id: Float
  user_id: Float
}

"""
order by avg() on columns of table "tokens"
"""
input tokens_avg_order_by {
  id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "tokens". All fields are combined with a logical 'AND'.
"""
input tokens_bool_exp {
  _and: [tokens_bool_exp!]
  _not: tokens_bool_exp
  _or: [tokens_bool_exp!]
  created: timestamp_comparison_exp
  expiration: timestamp_comparison_exp
  id: Int_comparison_exp
  type: String_comparison_exp
  user: users_bool_exp
  user_id: Int_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "tokens"
"""
enum tokens_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tokens_pkey

  """
  unique or primary key constraint on columns "value"
  """
  tokens_value_key
}

"""
input type for incrementing numeric columns in table "tokens"
"""
input tokens_inc_input {
  id: Int
  user_id: Int
}

"""
input type for inserting data into table "tokens"
"""
input tokens_insert_input {
  created: timestamp
  expiration: timestamp
  id: Int
  type: String
  user: users_obj_rel_insert_input
  user_id: Int
  value: String
}

"""aggregate max on columns"""
type tokens_max_fields {
  created: timestamp
  expiration: timestamp
  id: Int
  type: String
  user_id: Int
  value: String
}

"""
order by max() on columns of table "tokens"
"""
input tokens_max_order_by {
  created: order_by
  expiration: order_by
  id: order_by
  type: order_by
  user_id: order_by
  value: order_by
}

"""aggregate min on columns"""
type tokens_min_fields {
  created: timestamp
  expiration: timestamp
  id: Int
  type: String
  user_id: Int
  value: String
}

"""
order by min() on columns of table "tokens"
"""
input tokens_min_order_by {
  created: order_by
  expiration: order_by
  id: order_by
  type: order_by
  user_id: order_by
  value: order_by
}

"""
response of any mutation on the table "tokens"
"""
type tokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tokens!]!
}

"""
on_conflict condition type for table "tokens"
"""
input tokens_on_conflict {
  constraint: tokens_constraint!
  update_columns: [tokens_update_column!]! = []
  where: tokens_bool_exp
}

"""Ordering options when selecting data from "tokens"."""
input tokens_order_by {
  created: order_by
  expiration: order_by
  id: order_by
  type: order_by
  user: users_order_by
  user_id: order_by
  value: order_by
}

"""primary key columns input for table: tokens"""
input tokens_pk_columns_input {
  id: Int!
}

"""
select columns of table "tokens"
"""
enum tokens_select_column {
  """column name"""
  created

  """column name"""
  expiration

  """column name"""
  id

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value
}

"""
input type for updating data in table "tokens"
"""
input tokens_set_input {
  created: timestamp
  expiration: timestamp
  id: Int
  type: String
  user_id: Int
  value: String
}

"""aggregate stddev on columns"""
type tokens_stddev_fields {
  id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "tokens"
"""
input tokens_stddev_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type tokens_stddev_pop_fields {
  id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "tokens"
"""
input tokens_stddev_pop_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type tokens_stddev_samp_fields {
  id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "tokens"
"""
input tokens_stddev_samp_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate sum on columns"""
type tokens_sum_fields {
  id: Int
  user_id: Int
}

"""
order by sum() on columns of table "tokens"
"""
input tokens_sum_order_by {
  id: order_by
  user_id: order_by
}

"""
update columns of table "tokens"
"""
enum tokens_update_column {
  """column name"""
  created

  """column name"""
  expiration

  """column name"""
  id

  """column name"""
  type

  """column name"""
  user_id

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type tokens_var_pop_fields {
  id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "tokens"
"""
input tokens_var_pop_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type tokens_var_samp_fields {
  id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "tokens"
"""
input tokens_var_samp_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type tokens_variance_fields {
  id: Float
  user_id: Float
}

"""
order by variance() on columns of table "tokens"
"""
input tokens_variance_order_by {
  id: order_by
  user_id: order_by
}

"""
columns and relationships of "tracking"
"""
type tracking {
  date: timestamp
  id: Int!
  ip: String
  type: String

  """An object relationship"""
  user: users
  user_id: Int
}

"""
aggregated selection of "tracking"
"""
type tracking_aggregate {
  aggregate: tracking_aggregate_fields
  nodes: [tracking!]!
}

"""
aggregate fields of "tracking"
"""
type tracking_aggregate_fields {
  avg: tracking_avg_fields
  count(columns: [tracking_select_column!], distinct: Boolean): Int!
  max: tracking_max_fields
  min: tracking_min_fields
  stddev: tracking_stddev_fields
  stddev_pop: tracking_stddev_pop_fields
  stddev_samp: tracking_stddev_samp_fields
  sum: tracking_sum_fields
  var_pop: tracking_var_pop_fields
  var_samp: tracking_var_samp_fields
  variance: tracking_variance_fields
}

"""
order by aggregate values of table "tracking"
"""
input tracking_aggregate_order_by {
  avg: tracking_avg_order_by
  count: order_by
  max: tracking_max_order_by
  min: tracking_min_order_by
  stddev: tracking_stddev_order_by
  stddev_pop: tracking_stddev_pop_order_by
  stddev_samp: tracking_stddev_samp_order_by
  sum: tracking_sum_order_by
  var_pop: tracking_var_pop_order_by
  var_samp: tracking_var_samp_order_by
  variance: tracking_variance_order_by
}

"""
input type for inserting array relation for remote table "tracking"
"""
input tracking_arr_rel_insert_input {
  data: [tracking_insert_input!]!

  """upsert condition"""
  on_conflict: tracking_on_conflict
}

"""aggregate avg on columns"""
type tracking_avg_fields {
  id: Float
  user_id: Float
}

"""
order by avg() on columns of table "tracking"
"""
input tracking_avg_order_by {
  id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "tracking". All fields are combined with a logical 'AND'.
"""
input tracking_bool_exp {
  _and: [tracking_bool_exp!]
  _not: tracking_bool_exp
  _or: [tracking_bool_exp!]
  date: timestamp_comparison_exp
  id: Int_comparison_exp
  ip: String_comparison_exp
  type: String_comparison_exp
  user: users_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "tracking"
"""
enum tracking_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tracking_pkey
}

"""
input type for incrementing numeric columns in table "tracking"
"""
input tracking_inc_input {
  id: Int
  user_id: Int
}

"""
input type for inserting data into table "tracking"
"""
input tracking_insert_input {
  date: timestamp
  id: Int
  ip: String
  type: String
  user: users_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type tracking_max_fields {
  date: timestamp
  id: Int
  ip: String
  type: String
  user_id: Int
}

"""
order by max() on columns of table "tracking"
"""
input tracking_max_order_by {
  date: order_by
  id: order_by
  ip: order_by
  type: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type tracking_min_fields {
  date: timestamp
  id: Int
  ip: String
  type: String
  user_id: Int
}

"""
order by min() on columns of table "tracking"
"""
input tracking_min_order_by {
  date: order_by
  id: order_by
  ip: order_by
  type: order_by
  user_id: order_by
}

"""
response of any mutation on the table "tracking"
"""
type tracking_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tracking!]!
}

"""
on_conflict condition type for table "tracking"
"""
input tracking_on_conflict {
  constraint: tracking_constraint!
  update_columns: [tracking_update_column!]! = []
  where: tracking_bool_exp
}

"""Ordering options when selecting data from "tracking"."""
input tracking_order_by {
  date: order_by
  id: order_by
  ip: order_by
  type: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: tracking"""
input tracking_pk_columns_input {
  id: Int!
}

"""
select columns of table "tracking"
"""
enum tracking_select_column {
  """column name"""
  date

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  type

  """column name"""
  user_id
}

"""
input type for updating data in table "tracking"
"""
input tracking_set_input {
  date: timestamp
  id: Int
  ip: String
  type: String
  user_id: Int
}

"""aggregate stddev on columns"""
type tracking_stddev_fields {
  id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "tracking"
"""
input tracking_stddev_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type tracking_stddev_pop_fields {
  id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "tracking"
"""
input tracking_stddev_pop_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type tracking_stddev_samp_fields {
  id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "tracking"
"""
input tracking_stddev_samp_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate sum on columns"""
type tracking_sum_fields {
  id: Int
  user_id: Int
}

"""
order by sum() on columns of table "tracking"
"""
input tracking_sum_order_by {
  id: order_by
  user_id: order_by
}

"""
update columns of table "tracking"
"""
enum tracking_update_column {
  """column name"""
  date

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  type

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type tracking_var_pop_fields {
  id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "tracking"
"""
input tracking_var_pop_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type tracking_var_samp_fields {
  id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "tracking"
"""
input tracking_var_samp_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type tracking_variance_fields {
  id: Float
  user_id: Float
}

"""
order by variance() on columns of table "tracking"
"""
input tracking_variance_order_by {
  id: order_by
  user_id: order_by
}

"""
columns and relationships of "unlocks"
"""
type unlocks {
  date: timestamp
  id: Int!
  target: Int

  """An object relationship"""
  target_hint: hints

  """An object relationship"""
  team: teams
  team_id: Int
  type: String

  """An object relationship"""
  user: users
  user_id: Int
}

"""
aggregated selection of "unlocks"
"""
type unlocks_aggregate {
  aggregate: unlocks_aggregate_fields
  nodes: [unlocks!]!
}

"""
aggregate fields of "unlocks"
"""
type unlocks_aggregate_fields {
  avg: unlocks_avg_fields
  count(columns: [unlocks_select_column!], distinct: Boolean): Int!
  max: unlocks_max_fields
  min: unlocks_min_fields
  stddev: unlocks_stddev_fields
  stddev_pop: unlocks_stddev_pop_fields
  stddev_samp: unlocks_stddev_samp_fields
  sum: unlocks_sum_fields
  var_pop: unlocks_var_pop_fields
  var_samp: unlocks_var_samp_fields
  variance: unlocks_variance_fields
}

"""
order by aggregate values of table "unlocks"
"""
input unlocks_aggregate_order_by {
  avg: unlocks_avg_order_by
  count: order_by
  max: unlocks_max_order_by
  min: unlocks_min_order_by
  stddev: unlocks_stddev_order_by
  stddev_pop: unlocks_stddev_pop_order_by
  stddev_samp: unlocks_stddev_samp_order_by
  sum: unlocks_sum_order_by
  var_pop: unlocks_var_pop_order_by
  var_samp: unlocks_var_samp_order_by
  variance: unlocks_variance_order_by
}

"""
input type for inserting array relation for remote table "unlocks"
"""
input unlocks_arr_rel_insert_input {
  data: [unlocks_insert_input!]!

  """upsert condition"""
  on_conflict: unlocks_on_conflict
}

"""aggregate avg on columns"""
type unlocks_avg_fields {
  id: Float
  target: Float
  team_id: Float
  user_id: Float
}

"""
order by avg() on columns of table "unlocks"
"""
input unlocks_avg_order_by {
  id: order_by
  target: order_by
  team_id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "unlocks". All fields are combined with a logical 'AND'.
"""
input unlocks_bool_exp {
  _and: [unlocks_bool_exp!]
  _not: unlocks_bool_exp
  _or: [unlocks_bool_exp!]
  date: timestamp_comparison_exp
  id: Int_comparison_exp
  target: Int_comparison_exp
  target_hint: hints_bool_exp
  team: teams_bool_exp
  team_id: Int_comparison_exp
  type: String_comparison_exp
  user: users_bool_exp
  user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "unlocks"
"""
enum unlocks_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  unlocks_pkey
}

"""
input type for incrementing numeric columns in table "unlocks"
"""
input unlocks_inc_input {
  id: Int
  target: Int
  team_id: Int
  user_id: Int
}

"""
input type for inserting data into table "unlocks"
"""
input unlocks_insert_input {
  date: timestamp
  id: Int
  target: Int
  target_hint: hints_obj_rel_insert_input
  team: teams_obj_rel_insert_input
  team_id: Int
  type: String
  user: users_obj_rel_insert_input
  user_id: Int
}

"""aggregate max on columns"""
type unlocks_max_fields {
  date: timestamp
  id: Int
  target: Int
  team_id: Int
  type: String
  user_id: Int
}

"""
order by max() on columns of table "unlocks"
"""
input unlocks_max_order_by {
  date: order_by
  id: order_by
  target: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type unlocks_min_fields {
  date: timestamp
  id: Int
  target: Int
  team_id: Int
  type: String
  user_id: Int
}

"""
order by min() on columns of table "unlocks"
"""
input unlocks_min_order_by {
  date: order_by
  id: order_by
  target: order_by
  team_id: order_by
  type: order_by
  user_id: order_by
}

"""
response of any mutation on the table "unlocks"
"""
type unlocks_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [unlocks!]!
}

"""
on_conflict condition type for table "unlocks"
"""
input unlocks_on_conflict {
  constraint: unlocks_constraint!
  update_columns: [unlocks_update_column!]! = []
  where: unlocks_bool_exp
}

"""Ordering options when selecting data from "unlocks"."""
input unlocks_order_by {
  date: order_by
  id: order_by
  target: order_by
  target_hint: hints_order_by
  team: teams_order_by
  team_id: order_by
  type: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: unlocks"""
input unlocks_pk_columns_input {
  id: Int!
}

"""
select columns of table "unlocks"
"""
enum unlocks_select_column {
  """column name"""
  date

  """column name"""
  id

  """column name"""
  target

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id
}

"""
input type for updating data in table "unlocks"
"""
input unlocks_set_input {
  date: timestamp
  id: Int
  target: Int
  team_id: Int
  type: String
  user_id: Int
}

"""aggregate stddev on columns"""
type unlocks_stddev_fields {
  id: Float
  target: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "unlocks"
"""
input unlocks_stddev_order_by {
  id: order_by
  target: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type unlocks_stddev_pop_fields {
  id: Float
  target: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "unlocks"
"""
input unlocks_stddev_pop_order_by {
  id: order_by
  target: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type unlocks_stddev_samp_fields {
  id: Float
  target: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "unlocks"
"""
input unlocks_stddev_samp_order_by {
  id: order_by
  target: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate sum on columns"""
type unlocks_sum_fields {
  id: Int
  target: Int
  team_id: Int
  user_id: Int
}

"""
order by sum() on columns of table "unlocks"
"""
input unlocks_sum_order_by {
  id: order_by
  target: order_by
  team_id: order_by
  user_id: order_by
}

"""
update columns of table "unlocks"
"""
enum unlocks_update_column {
  """column name"""
  date

  """column name"""
  id

  """column name"""
  target

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type unlocks_var_pop_fields {
  id: Float
  target: Float
  team_id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "unlocks"
"""
input unlocks_var_pop_order_by {
  id: order_by
  target: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type unlocks_var_samp_fields {
  id: Float
  target: Float
  team_id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "unlocks"
"""
input unlocks_var_samp_order_by {
  id: order_by
  target: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type unlocks_variance_fields {
  id: Float
  target: Float
  team_id: Float
  user_id: Float
}

"""
order by variance() on columns of table "unlocks"
"""
input unlocks_variance_order_by {
  id: order_by
  target: order_by
  team_id: order_by
  user_id: order_by
}

"""
columns and relationships of "users"
"""
type users {
  affiliation: String

  """
  A computed field, executes function "user_avatar"
  """
  avatar: String

  """An array relationship"""
  awards(
    """distinct select on columns"""
    distinct_on: [awards_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [awards_order_by!]

    """filter the rows returned"""
    where: awards_bool_exp
  ): [awards!]!

  """An aggregate relationship"""
  awards_aggregate(
    """distinct select on columns"""
    distinct_on: [awards_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [awards_order_by!]

    """filter the rows returned"""
    where: awards_bool_exp
  ): awards_aggregate!
  banned: Boolean
  bracket: String

  """An object relationship"""
  captain_of: teams

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): [comments!]!

  """An array relationship"""
  commentsByUserId(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): [comments!]!

  """An aggregate relationship"""
  commentsByUserId_aggregate(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): comments_aggregate!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [comments_order_by!]

    """filter the rows returned"""
    where: comments_bool_exp
  ): comments_aggregate!
  country: String
  created: timestamp
  email: String

  """An array relationship"""
  field_entries(
    """distinct select on columns"""
    distinct_on: [field_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entries_order_by!]

    """filter the rows returned"""
    where: field_entries_bool_exp
  ): [field_entries!]!

  """An aggregate relationship"""
  field_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [field_entries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [field_entries_order_by!]

    """filter the rows returned"""
    where: field_entries_bool_exp
  ): field_entries_aggregate!
  hidden: Boolean
  id: Int!
  name: String
  oauth_id: Int
  password: String

  """
  A computed field, executes function "user_score"
  """
  score: Int

  """An array relationship"""
  score_timeline(
    """distinct select on columns"""
    distinct_on: [score_timeline_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_user_order_by!]

    """filter the rows returned"""
    where: score_timeline_user_bool_exp
  ): [score_timeline_user!]!

  """An aggregate relationship"""
  score_timeline_aggregate(
    """distinct select on columns"""
    distinct_on: [score_timeline_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [score_timeline_user_order_by!]

    """filter the rows returned"""
    where: score_timeline_user_bool_exp
  ): score_timeline_user_aggregate!
  secret: String

  """An array relationship"""
  solves(
    """distinct select on columns"""
    distinct_on: [solves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solves_order_by!]

    """filter the rows returned"""
    where: solves_bool_exp
  ): [solves!]!

  """An aggregate relationship"""
  solves_aggregate(
    """distinct select on columns"""
    distinct_on: [solves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [solves_order_by!]

    """filter the rows returned"""
    where: solves_bool_exp
  ): solves_aggregate!

  """An array relationship"""
  submissions(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): [submissions!]!

  """An aggregate relationship"""
  submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): submissions_aggregate!

  """An object relationship"""
  team: teams
  team_id: Int

  """An array relationship"""
  tokens(
    """distinct select on columns"""
    distinct_on: [tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_order_by!]

    """filter the rows returned"""
    where: tokens_bool_exp
  ): [tokens!]!

  """An aggregate relationship"""
  tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_order_by!]

    """filter the rows returned"""
    where: tokens_bool_exp
  ): tokens_aggregate!

  """An array relationship"""
  trackings(
    """distinct select on columns"""
    distinct_on: [tracking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tracking_order_by!]

    """filter the rows returned"""
    where: tracking_bool_exp
  ): [tracking!]!

  """An aggregate relationship"""
  trackings_aggregate(
    """distinct select on columns"""
    distinct_on: [tracking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tracking_order_by!]

    """filter the rows returned"""
    where: tracking_bool_exp
  ): tracking_aggregate!
  type: String

  """An array relationship"""
  unlocks(
    """distinct select on columns"""
    distinct_on: [unlocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlocks_order_by!]

    """filter the rows returned"""
    where: unlocks_bool_exp
  ): [unlocks!]!

  """An aggregate relationship"""
  unlocks_aggregate(
    """distinct select on columns"""
    distinct_on: [unlocks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unlocks_order_by!]

    """filter the rows returned"""
    where: unlocks_bool_exp
  ): unlocks_aggregate!
  verified: Boolean
  website: String
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  avg: users_avg_fields
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
  stddev: users_stddev_fields
  stddev_pop: users_stddev_pop_fields
  stddev_samp: users_stddev_samp_fields
  sum: users_sum_fields
  var_pop: users_var_pop_fields
  var_samp: users_var_samp_fields
  variance: users_variance_fields
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  avg: users_avg_order_by
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
  stddev: users_stddev_order_by
  stddev_pop: users_stddev_pop_order_by
  stddev_samp: users_stddev_samp_order_by
  sum: users_sum_order_by
  var_pop: users_var_pop_order_by
  var_samp: users_var_samp_order_by
  variance: users_variance_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""aggregate avg on columns"""
type users_avg_fields {
  id: Float
  oauth_id: Float
  team_id: Float
}

"""
order by avg() on columns of table "users"
"""
input users_avg_order_by {
  id: order_by
  oauth_id: order_by
  team_id: order_by
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  affiliation: String_comparison_exp
  avatar: String_comparison_exp
  awards: awards_bool_exp
  banned: Boolean_comparison_exp
  bracket: String_comparison_exp
  captain_of: teams_bool_exp
  comments: comments_bool_exp
  commentsByUserId: comments_bool_exp
  country: String_comparison_exp
  created: timestamp_comparison_exp
  email: String_comparison_exp
  field_entries: field_entries_bool_exp
  hidden: Boolean_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  oauth_id: Int_comparison_exp
  password: String_comparison_exp
  score: Int_comparison_exp
  score_timeline: score_timeline_user_bool_exp
  secret: String_comparison_exp
  solves: solves_bool_exp
  submissions: submissions_bool_exp
  team: teams_bool_exp
  team_id: Int_comparison_exp
  tokens: tokens_bool_exp
  trackings: tracking_bool_exp
  type: String_comparison_exp
  unlocks: unlocks_bool_exp
  verified: Boolean_comparison_exp
  website: String_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key

  """
  unique or primary key constraint on columns "oauth_id", "id"
  """
  users_id_oauth_id_key

  """
  unique or primary key constraint on columns "oauth_id"
  """
  users_oauth_id_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
input type for incrementing numeric columns in table "users"
"""
input users_inc_input {
  id: Int
  oauth_id: Int
  team_id: Int
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  affiliation: String
  awards: awards_arr_rel_insert_input
  banned: Boolean
  bracket: String
  captain_of: teams_obj_rel_insert_input
  comments: comments_arr_rel_insert_input
  commentsByUserId: comments_arr_rel_insert_input
  country: String
  created: timestamp
  email: String
  field_entries: field_entries_arr_rel_insert_input
  hidden: Boolean
  id: Int
  name: String
  oauth_id: Int
  password: String
  score_timeline: score_timeline_user_arr_rel_insert_input
  secret: String
  solves: solves_arr_rel_insert_input
  submissions: submissions_arr_rel_insert_input
  team: teams_obj_rel_insert_input
  team_id: Int
  tokens: tokens_arr_rel_insert_input
  trackings: tracking_arr_rel_insert_input
  type: String
  unlocks: unlocks_arr_rel_insert_input
  verified: Boolean
  website: String
}

"""aggregate max on columns"""
type users_max_fields {
  affiliation: String
  bracket: String
  country: String
  created: timestamp
  email: String
  id: Int
  name: String
  oauth_id: Int
  password: String
  secret: String
  team_id: Int
  type: String
  website: String
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  affiliation: order_by
  bracket: order_by
  country: order_by
  created: order_by
  email: order_by
  id: order_by
  name: order_by
  oauth_id: order_by
  password: order_by
  secret: order_by
  team_id: order_by
  type: order_by
  website: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  affiliation: String
  bracket: String
  country: String
  created: timestamp
  email: String
  id: Int
  name: String
  oauth_id: Int
  password: String
  secret: String
  team_id: Int
  type: String
  website: String
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  affiliation: order_by
  bracket: order_by
  country: order_by
  created: order_by
  email: order_by
  id: order_by
  name: order_by
  oauth_id: order_by
  password: order_by
  secret: order_by
  team_id: order_by
  type: order_by
  website: order_by
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "users"."""
input users_order_by {
  affiliation: order_by
  avatar: order_by
  awards_aggregate: awards_aggregate_order_by
  banned: order_by
  bracket: order_by
  captain_of: teams_order_by
  commentsByUserId_aggregate: comments_aggregate_order_by
  comments_aggregate: comments_aggregate_order_by
  country: order_by
  created: order_by
  email: order_by
  field_entries_aggregate: field_entries_aggregate_order_by
  hidden: order_by
  id: order_by
  name: order_by
  oauth_id: order_by
  password: order_by
  score: order_by
  score_timeline_aggregate: score_timeline_user_aggregate_order_by
  secret: order_by
  solves_aggregate: solves_aggregate_order_by
  submissions_aggregate: submissions_aggregate_order_by
  team: teams_order_by
  team_id: order_by
  tokens_aggregate: tokens_aggregate_order_by
  trackings_aggregate: tracking_aggregate_order_by
  type: order_by
  unlocks_aggregate: unlocks_aggregate_order_by
  verified: order_by
  website: order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  id: Int!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  affiliation

  """column name"""
  banned

  """column name"""
  bracket

  """column name"""
  country

  """column name"""
  created

  """column name"""
  email

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  name

  """column name"""
  oauth_id

  """column name"""
  password

  """column name"""
  secret

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  verified

  """column name"""
  website
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  affiliation: String
  banned: Boolean
  bracket: String
  country: String
  created: timestamp
  email: String
  hidden: Boolean
  id: Int
  name: String
  oauth_id: Int
  password: String
  secret: String
  team_id: Int
  type: String
  verified: Boolean
  website: String
}

"""aggregate stddev on columns"""
type users_stddev_fields {
  id: Float
  oauth_id: Float
  team_id: Float
}

"""
order by stddev() on columns of table "users"
"""
input users_stddev_order_by {
  id: order_by
  oauth_id: order_by
  team_id: order_by
}

"""aggregate stddev_pop on columns"""
type users_stddev_pop_fields {
  id: Float
  oauth_id: Float
  team_id: Float
}

"""
order by stddev_pop() on columns of table "users"
"""
input users_stddev_pop_order_by {
  id: order_by
  oauth_id: order_by
  team_id: order_by
}

"""aggregate stddev_samp on columns"""
type users_stddev_samp_fields {
  id: Float
  oauth_id: Float
  team_id: Float
}

"""
order by stddev_samp() on columns of table "users"
"""
input users_stddev_samp_order_by {
  id: order_by
  oauth_id: order_by
  team_id: order_by
}

"""aggregate sum on columns"""
type users_sum_fields {
  id: Int
  oauth_id: Int
  team_id: Int
}

"""
order by sum() on columns of table "users"
"""
input users_sum_order_by {
  id: order_by
  oauth_id: order_by
  team_id: order_by
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  affiliation

  """column name"""
  banned

  """column name"""
  bracket

  """column name"""
  country

  """column name"""
  created

  """column name"""
  email

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  name

  """column name"""
  oauth_id

  """column name"""
  password

  """column name"""
  secret

  """column name"""
  team_id

  """column name"""
  type

  """column name"""
  verified

  """column name"""
  website
}

"""aggregate var_pop on columns"""
type users_var_pop_fields {
  id: Float
  oauth_id: Float
  team_id: Float
}

"""
order by var_pop() on columns of table "users"
"""
input users_var_pop_order_by {
  id: order_by
  oauth_id: order_by
  team_id: order_by
}

"""aggregate var_samp on columns"""
type users_var_samp_fields {
  id: Float
  oauth_id: Float
  team_id: Float
}

"""
order by var_samp() on columns of table "users"
"""
input users_var_samp_order_by {
  id: order_by
  oauth_id: order_by
  team_id: order_by
}

"""aggregate variance on columns"""
type users_variance_fields {
  id: Float
  oauth_id: Float
  team_id: Float
}

"""
order by variance() on columns of table "users"
"""
input users_variance_order_by {
  id: order_by
  oauth_id: order_by
  team_id: order_by
}
